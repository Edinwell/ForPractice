<!--
 Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
 ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8">
	<TITLE>ネットワークのプロパティ</TITLE>
</HEAD>
<body lang="ja" dir="LTR">
<H1 ALIGN=CENTER>ネットワークのプロパティ</H1>
<P ALIGN=LEFT>java.netパッケージのさまざまなクラスのメカニズムと動作を変更するために使用される、いくつかの標準システム・プロパティがあります。一部はVMの起動時に1回だけチェックされるので、javaコマンドの-Dオプションを使用するのが適切な設定方法です。一方、他のプロパティの性質はより動的で、<a href="../../lang/System.html#setProperty(java.lang.String, java.lang.String)">System.setProperty()</a> APIを使用して変更することもできます。このドキュメントは、これらのすべてのプロパティのリストを示し、それらの詳細を説明することを目的としています。</P>
<P>特に注意書きがなければ、プロパティ値は使用されるたびにチェックされます。</P>
<a name="Ipv4IPv6"></a>
<H2>IPv4 / IPv6</H2>
<UL>
	<LI><P><b>java.net.preferIPv4Stack</b> (デフォルト: false)<br> IPv6を利用可能なオペレーティング・システムでは、ベースとなるネイティブ・ソケットは、デフォルトではIPv6ソケットです。これによりアプリケーションは、IPv4ホストとIPv6ホストの両方に接続したり、その両方のホストからの接続を受け入れたりできます。ただし、アプリケーションでIPv4専用ソケットを使用する場合、このプロパティを<b>true</b>に設定することができます。この場合、そのアプリケーションはIPv6専用ホストとは通信できません。</P>
	<LI><P><b>java.net.preferIPv6Addresses</b> (デフォルト: false)<br>IPv4アドレスとIPv6アドレスの両方を持つホストを扱う場合、IPv6を利用可能なオペレーティング・システムでは、IPv6アドレスよりもIPv4アドレスの使用を優先するのがデフォルトの動作です。これは、下位互換性を確保するためで、たとえば、IPv4のアドレス表現(例:  192.168.1.1)に依存するアプリケーションが挙げられます。可能な場合は、このプロパティを<b>true</b>に設定してその優先設定を変更し、IPv4アドレスではなくIPv6アドレスを使用することができます。</P>
</UL>
<P>これらのプロパティはどちらも、起動時に1回だけチェックされます。</P>
<a name="Proxies"></a>
<H2>プロキシ</H2>
<P>プロキシ・サーバーは、ネットワーク・サービスへの間接的な接続を可能にするもので、主に、セキュリティ上の理由(ファイアウォールを通過させる)とパフォーマンス上の理由(プロキシはキャッシュ・メカニズムを提供することが多い)のために使用されます。次のプロパティによって、さまざまな種類のプロキシを構成できます。</P>
<UL>
	<LI><P>HTTP</P>
	<P>次のプロキシ設定がHTTPプロトコル・ハンドラによって使用されます。</P>
	<UL>
		<LI><P><b>http.proxyHost</b> (デフォルト: &lt;なし>)<br>プロキシ・サーバーのホスト名またはアドレス。 
		</P>
		<LI><P><b>http.proxyPort</b> (デフォルト: 80)<br>プロキシ・サーバーのポート番号。</P>
		<LI><P><b>http.nonProxyHosts</b> (デフォルト: localhost|127.*|[::1])<br>プロキシを通過しないでアクセスすべきホストを指定します。通常これは内部ホストを定義します。このプロパティの値は、'|'文字で区切られたホストのリストです。さらに、パターン・マッチングのためにワイルドカード文字'*'も使用できます。たとえば<code>-Dhttp.nonProxyHosts=”*.foo.com|localhost”</code>は、foo.comドメイン内のすべてのホストで、プロキシ・サーバーが指定されている場合でもlocalhostは直接アクセスする必要があることを示します。</P>
                <P>デフォルト値には、ループバック・アドレスのあらゆる一般的なバリエーションが含まれません。</P>
        </UL>
	<LI><P>HTTPS<br>これはHTTP over SSLのことで、支払いサイトでのように、機密性が必要とされるときに使われるセキュアなバージョンのHTTPです。</P>
	<P>次のプロキシ設定がHTTPSプロトコル・ハンドラによって使用されます。</P>
	<UL>
		<LI><P><b>https.proxyHost</b> (デフォルト: &lt;なし>)<br>プロキシ・サーバーのホスト名またはアドレス。 
		</P>
		<LI><P><b>https.proxyPort</b> (デフォルト: 443)<br>プロキシ・サーバーのポート番号。</P>
		<P>HTTPSプロトコル・ハンドラは、HTTPプロトコルと同じnonProxyHostsプロパティを使用します。</P>
	</UL>
	<LI><P>FTP</P>
	<P>次のプロキシ設定がFTPプロトコル・ハンドラによって使用されます。</P>
	<UL>
		<LI><P><b>ftp.proxyHost</b> (デフォルト: &lt;なし>)<br>プロキシ・サーバーのホスト名またはアドレス。 
		</P>
		<LI><P><b>ftp.proxyPort</b> (デフォルト: 80)<br>プロキシ・サーバーのポート番号。</P>
		<LI><P><b>ftp.nonProxyHosts</b> (デフォルト: localhost|127.*|[::1])<br>プロキシを通過しないでアクセスすべきホストを指定します。通常これは内部ホストを定義します。このプロパティの値は、'|'文字で区切られたホストのリストです。さらに、パターン・マッチングのためにワイルドカード文字'*'も使用できます。たとえば<code>-Dhttp.nonProxyHosts=”*.foo.com|localhost”</code>は、foo.comドメイン内のすべてのホストで、プロキシ・サーバーが指定されている場合でもlocalhostは直接アクセスする必要があることを示します。</P>
                <P>デフォルト値には、ループバック・アドレスのあらゆる一般的なバリエーションが含まれません。</P>
	</UL>
	<LI><P>SOCKS<br>これは別の種類のプロキシです。これはTCPレベルで動作するため、低レベル型のトンネリングが可能です。実際には、SOCKSプロキシ・サーバーを設定しているJava(tm)プラットフォームでは、ほかのプロキシが指定されていなければ、すべてのTCP接続がそのプロキシを通過するようになります。Java SEの実装でSOCKSがサポートされている場合、次のプロパティが使用されます。</P>
	<UL>
		<LI><P><b>socksProxyHost</b> (デフォルト: &lt;なし>)<br>プロキシ・サーバーのホスト名またはアドレス。</P>
		<LI><P><b>socksProxyPort</b> (デフォルト: 1080)<br>プロキシ・サーバーのポート番号。</P>
                <LI><P><b>socksProxyVersion</b> (デフォルト: 5)<br>サーバーでサポートされているSOCKSプロトコルのバージョン。デフォルトはSOCKS V5を示す<code>5</code>ですが、SOCKS V4を表す<code>4</code>も指定できます。これら以外の値にプロパティを設定すると、未指定の動作が発生します。</P>
		<LI><P><b>java.net.socks.username</b> (デフォルト: &lt;なし>)<br>SOCKSv5サーバーが認証を要求し、java.net.Authenticatorインスタンスが見つからなかった場合に使用するユーザー名。</P>
		<LI><P><b>java.net.socks.password</b> (デフォルト: &lt;なし>)<br>SOCKSv5サーバーが認証を要求し、java.net.Authenticatorインスタンスが見つからなかった場合に使用するパスワード。</P>
		<P>上のプロパティまたはオーセンティケータのどちらも認証を提供していない場合、プロキシが認証を要求すると、パスワードなしで<b>user.name</b>プロパティが使用されます。</P>
	</UL>
	<LI><P><b>java.net.useSystemProxies</b> (デフォルト: false)<br>最近のWindowsシステムやGnome 2.xシステムでは、このプロパティを<b>true</b>に設定し、システムのプロキシ設定を使用するようにjava.net stackに指示できます(これらのどちらのシステムでも、ユーザー・インタフェースからプロキシをグローバルに設定可能)。このプロパティは起動時に1回だけチェックされることに注意してください。</P>
</UL>
<a name="MiscHTTP"></a>
<H2>その他のHTTPプロパティ</H2>
<UL>
	<LI><P><b>http.agent</b> (デフォルト: “Java/&lt;バージョン>”)<br>HTTP要求のUser-Agent要求ヘッダーに入れて送信される文字列を定義します。文字列“Java/&lt;バージョン>”は、プロパティ内に記述される文字列に追加されることに注意してください(例:  -Dhttp.agent=”foobar”が使用される場合、VMのバージョンが1.5.0であればUser-Agentヘッダーには“foobar Java/1.5.0”が格納される)。このプロパティは起動時に1回だけチェックされます。</P>
	<LI><P><b>http.keepalive</b> (デフォルト: true)<br>持続接続をサポートすべきかどうかを示します。これを使用すると、複数のHTTP要求に対して再利用されるベースとなるのソケット接続を許可することによって、パフォーマンスが改善されます。これがtrueに設定されている場合は、HTTP 1.1サーバーとの間で持続接続が要求されます。</P>
	<LI><P><b>http.maxConnections</b> (デフォルト: 5)<br>HTTPキープアライブが有効な場合(上を参照)、この値は、宛先ごとに同時にキープアライブされるアイドル接続の最大数を決定します。</P>
	<LI><P><b>http.maxRedirects</b> (デフォルト: 20)<br>この整数値は、特定の要求に関して、プロトコル・ハンドラが自動的に従うHTTPリダイレクトの最大数を決定します。</P>
	<LI><P><b>http.auth.digest.validateServer</b> (デフォルト: false)</P>
	<LI><P><b>http.auth.digest.validateProxy</b> (デフォルト: false)</P>
	<LI><P><b>http.auth.digest.cnonceRepeat</b> (デフォルト: 5)</P>
	<P>これら3つのプロパティは、HTTPダイジェスト認証機能の動作を変更します。ダイジェスト認証は、サーバーがそのユーザーのパスワードを認識していることをクライアントに証明することによって、サーバー自体をクライアントに認証させるための限定された機能をサーバーに提供します。ただしこの機能は、すべてのHTTPサーバーがサポートするわけではなく、デフォルトではオフになっています。最初の2つのプロパティは、trueに設定すると、それぞれオリジン・サーバーまたはプロキシ・サーバーとの認証で、このチェック機能を使用することができます。</P>
	<P>通常は、3つ目のプロパティを変更する必要はありません。これは、cnonce値を再使用する回数を決定します。このプロパティは、MD5-sessアルゴリズムを使用する場合に役に立ちます。この値を増やすと、各HTTP要求のためにハッシュしなければならない情報の量が減るので、クライアントとサーバーの両方で計算のオーバーヘッドが減少します。</P>
	<LI><P><b>http.auth.ntlm.domain</b> (デフォルト: &lt;none>)<br>NTLMはもう1つの認証スキームです。これはjava.net.Authenticatorクラスを使用して、必要なときにユーザー名とパスワードを取得します。しかし、NTLMの場合はNTドメイン名も必要です。そのドメインを指定するには、次の3つの方法があります。</P>
	<OL>
	  <LI><P>ドメインを指定しない。環境によっては、実際にはドメインが必要とされないので、アプリケーションで指定する必要がありません。</P>
	  <LI><P>ユーザー名の前にドメイン名+円記号「\」をつけることで、ドメイン名をユーザー名内にエンコードする。この方法では、ユーザーがこの表記方法を使用しなければならないということを意識すれば、Authenticatorクラスを使用する既存のアプリケーションを変更する必要がありません。</P>
	  <LI><P>ドメイン名を方法2)で指定せず、これらのシステム・プロパティが定義されている場合、この値がドメイン名として使用されます。</P>
	</OL>
</UL>
<P>これらのプロパティはすべて、起動時に1回だけチェックされます。</P>
<a name="AddressCache"></a>
<H2>アドレス・キャッシュ</H2>
<P>名前解決の実行時、java.netパッケージはセキュリティ上とパフォーマンス上の両方の理由で、アドレス・キャッシュを使用します。アドレス解決の試行は、前方解決(名前からIPアドレスへ)でも逆方向の解決(IPアドレスから名前へ)でもすべて、成功であったかどうかを問わず結果がキャッシュされます。そのため、以後の同一の要求はネーム・サービスにアクセスする必要がなくなります。これらのプロパティでは、キャッシュの動作方法をいくつかの設定でチューニングできます。</P>
<UL>
	<LI><P><b>networkaddress.cache.ttl</b> (デフォルト: 下記を参照)<br> 値は、成功した名前検索がキャッシュに保持される秒数に対応する整数です。-1の値や、その他の負の値はすべて、「ずっとキャッシュする」ことを意味します。値0は、キャッシュを使用しないという意味です。セキュリティ・マネージャがインストールされている場合のデフォルト値は -1 (ずっと)で、セキュリティ・マネージャがインストールされていない場合は実装固有となります。</P>
	<LI><P><b>networkaddress.cache.negative.ttl</b> (デフォルト: 10)<br> 値は、失敗した名前検索がキャッシュに保持される秒数に対応する整数です。-1の値や、その他の負の値はすべて、「ずっとキャッシュする」ことを意味します。値0は、キャッシュを使用しないという意味です。</P>
</UL>
<P>これらの2つのプロパティは、セキュリティ・ポリシーの一部であるため、-DオプションやSystem.setProperty() APIでは設定されません。そのかわり、これらのプロパティはセキュリティ・プロパティとして設定されます。</P>
</BODY>
</HTML>
