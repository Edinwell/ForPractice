<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>JVM(TM) Tool Interface 1.2.3</title>
<style type="text/css">
          td.tableHeader {font-size: larger}
        </style>
</head>
<body>
<table border="0" width="100%">
<tr>
<td align="center">
<h1>
    JVM<sup style="font-size: xx-small">TM</sup> Tool Interface
  </h1>
<h3>バージョン1.2</h3>
</td>
</tr>
</table>
<ul>
<li>
<a href="#SpecificationIntro"><b>はじめに</b></a>
<ul>
<li>
<a href="#whatIs"><b>JVM Tool Interfaceとは</b></a>
</li>
<li>
<a href="#architecture"><b>アーキテクチャ</b></a>
</li>
<li>
<a href="#writingAgents"><b>エージェントの作成</b></a>
</li>
<li>
<a href="#deployingAgents"><b>エージェントの配備</b></a>
</li>
<li>
<a href="#entry point"><b>静的リンク・エージェント(導入されたバージョン: 1.2.3)</b></a>
</li>
<li>
<a href="#starting"><b>エージェントのコマンド行オプション</b></a>
</li>
<li>
<a href="#startup"><b>エージェントの起動</b></a>
</li>
<li>
<a href="#onload"><b>エージェントの起動(OnLoad段階)</b></a>
</li>
<li>
<a href="#onattach"><b>エージェントの起動(ライブ段階)</b></a>
</li>
<li>
<a href="#onunload"><b>エージェントの停止</b></a>
</li>
<li>
<a href="#tooloptions"><b>JAVA_TOOL_OPTIONS</b></a>
</li>
<li>
<a href="#environments"><b>環境</b></a>
</li>
<li>
<a href="#bci"><b>バイト・コード・インストゥルメンテーション</b></a>
</li>
<li>
<a href="#mUTF"><b>修正UTF-8の文字列エンコーディング</b></a>
</li>
<li>
<a href="#context"><b>仕様のコンテキスト</b></a>
</li>
</ul>
</li>
<li>
<a href="#FunctionSection"><b>関数</b></a>
<ul>
<li>
<a href="#jvmtiEnvAccess"><b>関数のアクセス</b></a>
</li>
<li>
<a href="#functionReturn"><b>関数の戻り値</b></a>
</li>
<li>
<a href="#refs"><b>JNIオブジェクト参照の管理</b></a>
</li>
<li>
<a href="#prereqState"><b>関数呼出しの必要条件</b></a>
</li>
<li>
<a href="#functionsExceptions"><b>例外と関数</b></a>
</li>
<li>
<a href="#FunctionIndex"><b>関数の索引</b></a>
<ul>
<li>
<a href="#memory"><b>メモリー管理</b></a>
</li>
<li>
<a href="#threadCategory"><b>スレッド</b></a>
</li>
<li>
<a href="#thread_groups"><b>スレッド・グループ</b></a>
</li>
<li>
<a href="#stack"><b>スタック・フレーム</b></a>
</li>
<li>
<a href="#ForceEarlyReturn"><b>早期復帰の強制</b></a>
</li>
<li>
<a href="#Heap"><b>ヒープ</b></a>
</li>
<li>
<a href="#Heap_1_0"><b>ヒープ(1.0)</b></a>
</li>
<li>
<a href="#local"><b>局所変数</b></a>
</li>
<li>
<a href="#breakpointCategory"><b>ブレークポイント</b></a>
</li>
<li>
<a href="#fieldWatch"><b>監視されるフィールド</b></a>
</li>
<li>
<a href="#class"><b>クラス</b></a>
</li>
<li>
<a href="#object"><b>オブジェクト</b></a>
</li>
<li>
<a href="#fieldCategory"><b>フィールド</b></a>
</li>
<li>
<a href="#method"><b>メソッド</b></a>
</li>
<li>
<a href="#RawMonitors"><b>rawモニター</b></a>
</li>
<li>
<a href="#jniIntercept"><b>JNI関数の遮断</b></a>
</li>
<li>
<a href="#eventManagement"><b>イベント管理</b></a>
</li>
<li>
<a href="#extension"><b>拡張機能メカニズム</b></a>
</li>
<li>
<a href="#capability"><b>権限</b></a>
</li>
<li>
<a href="#timers"><b>タイマー</b></a>
</li>
<li>
<a href="#classLoaderSearch"><b>クラス・ローダー検索</b></a>
</li>
<li>
<a href="#props"><b>システム・プロパティ</b></a>
</li>
<li>
<a href="#general"><b>全般</b></a>
</li>
</ul>
</li>
<li>
<a href="#ErrorSection"><b>エラー・コード</b></a>
</li>
</ul>
</li>
<li>
<a href="#EventSection"><b>イベント</b></a>
<ul>
<li>
<a href="#EventIndex"><b>イベントの索引</b></a>
</li>
</ul>
</li>
<li>
<a href="#DataSection"><b>データ型</b></a>
<ul>
<li>
<a href="#jniTypes"><b>JVM Tool Interfaceで使用するJNIの型</b></a>
</li>
<li>
<a href="#jvmtiTypes"><b>JVM Tool Interface基底型</b></a>
</li>
<li>
<a href="#StructureTypeDefinitions"><b>構造型の定義</b></a>
</li>
<li>
<a href="#FunctionTypeDefinitions"><b>関数型の定義</b></a>
</li>
<li>
<a href="#EnumerationDefinitions"><b>列挙型の定義</b></a>
</li>
<li>
<a href="#FunctionTable"><b>関数テーブル</b></a>
</li>
</ul>
</li>
<li>
<a href="#ConstantIndex"><b>定数の索引</b></a>
</li>
<li>
<a href="#ChangeHistory"><b>変更履歴</b></a>
</li>
</ul>
<p></p>
<hr noshade size="3">
<p></p>
<p id="SpecificationIntro"></p>
<h4 id="whatIs">JVM Tool Interfaceとは</h4>
    JVM<sup style="font-size: xx-small">TM</sup> Tool Interface (JVM<small style="font-size: xx-small">&nbsp;</small>TI)は、開発ツールや監視ツールで使用されるプログラミング・インタフェースです。Java<sup style="font-size: xx-small">TM</sup>仮想マシン(VM)で動作するアプリケーションの状態検査と実行制御の両方の機能を提供します。
    <p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TIは、プロファイリング・ツール、デバッグ・ツール、監視ツール、スレッド分析ツール、カバレッジ分析ツールなど、VMの状態その他にアクセスする必要がある各種ツールのVMインタフェースとして機能します。
    <p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TIは、Java<sup style="font-size: xx-small">TM</sup>仮想マシンのすべての実装で使用できるとはかぎりません。
    <p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TIは双方向のインタフェースです。JVM<small style="font-size: xx-small">&nbsp;</small>TIのクライアント(以下<i>エージェント</i>と呼ぶ)は、興味のある事象について<a href="#EventSection">イベント</a>経由で通知を受け取ることができます。JVM<small style="font-size: xx-small">&nbsp;</small>TIは、多数の<a href="#FunctionSection">関数</a>を介して、アプリケーションのクエリーや制御を(イベントへの応答として、あるいはイベントから独立して)行えます。
    <p></p>
    個々のエージェントは同一のプロセスで実行され、検査対象のアプリケーションを実行する仮想マシンと直接通信します。この通信には、ネイティブ・インタフェース(JVM<small style="font-size: xx-small">&nbsp;</small>TI)が使用されます。ネイティブのインプロセス・インタフェースにより、ツール側への侵入は最小限に抑えながら、最大限の制御が可能になります。通常、エージェントは比較的コンパクトです。エージェントは、ターゲット・アプリケーションの通常の実行を妨げることなく、ツールの機能の大部分を実装する別のプロセスによって制御できます。
  <h4 id="architecture">アーキテクチャ</h4>
    ツールへの書込みは、JVM<small style="font-size: xx-small">&nbsp;</small>TIを使って直接行われるか、高度インタフェースを使って間接的に行われます。Java Platform Debugger Architectureには、JVM<small style="font-size: xx-small">&nbsp;</small>TIのほかに、より高いレベルのアウトプロセス・デバッガ・インタフェースも含まれています。多くのツールには、JVM<small style="font-size: xx-small">&nbsp;</small>TIよりも高いレベルのインタフェースの方が適しています。Java Platform Debugger Architectureの詳細については、<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/architecture.html">Java Platform Debugger ArchitectureのWebサイト</a>を参照してください。 
  <h4 id="writingAgents">エージェントの作成</h4>
    エージェントの作成には、C言語の呼出し規則とC/C++の定義をサポートする任意のネイティブ言語を使用できます。
    <p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TIを使用するために必要な関数、イベント、データ型、定数の定義は、インクルード・ファイル<code>jvmti.h</code>で定義されます。これらの定義を使用するには、J2SE<sup style="font-size: xx-small">TM</sup>インクルード・ディレクトリをインクルード・パスに追加し、
    <blockquote>
<pre>
#include &lt;jvmti.h&gt;
    </pre>
</blockquote>
    をソース・コードに追加してください。
  <h4 id="deployingAgents">エージェントの配備</h4>
    エージェントはプラットフォーム固有の方法で配備されますが、通常はそのプラットフォームでダイナミック・ライブラリに相当するものになります。たとえば、Windows<sup style="font-size: xx-small">TM</sup>オペレーティング・システムの場合、エージェント・ライブラリは「ダイナミック・リンク・ライブラリ」(DLL)になります。Solaris<sup style="font-size: xx-small">TM</sup>オペレーティング環境の場合、エージェント・ライブラリは共有オブジェクト(<code>.so</code>ファイル)になります。
    <p></p>

    VM起動時にエージェントを起動するには、<a href="#starting">コマンド行オプション</a>を使ってエージェント・ライブラリの名前を指定します。実装によっては、ライブ<a href="#GetPhase">段階</a>で<a href="#onattach">エージェントを起動</a>するメカニズムをサポートしている可能性があります。その起動方法の詳細は、実装に固有となります。
  <h4 id="entry point">静的リンク・エージェント(導入されたバージョン: 1.2.3)</h4>

      ネイティブJVMTIエージェントは、VMと<i>静的にリンク</i>できます。ライブラリ・イメージとVMイメージとの結合方法は、実装に依存します。イメージがVMと結合されたエージェントLが<i>静的リンク</i>として定義されるのは、そのエージェントがAgent_OnLoad_Lという名前の関数をエクスポートする場合のみです。
<p></p>
      <i>静的リンク</i>・エージェントLからAgent_OnLoad_Lという名前の関数とAgent_OnLoadという名前の関数がエクスポートされた場合、Agent_OnLoad関数は無視されます。エージェントLが<i>静的リンク</i>の場合、Agent_OnLoad関数で規定されたのと同じ引数と期待される戻り値を指定して、Agent_OnLoad_L関数が呼び出されます。<i>静的リンク</i>のエージェントLは、同名のエージェントが動的にロードされるのを禁止します。
<p></p>
      VMは、その実行中に動的エントリ・ポイントAgent_OnUnLoadが呼び出されていたのと同じポイントで、エージェントのAgent_OnUnload_L関数を呼び出します(そのような関数がエクスポートされていた場合)。静的にロードされたエージェントはアンロードできません。それでも、エージェントのシャットダウンに関する他のなんらかのタスクを行えるように、Agent_OnUnload_L関数が呼び出されます。<i>静的リンク</i>・エージェントLからAgent_OnUnLoad_Lという名前の関数とAgent_OnUnLoadという名前の関数がエクスポートされた場合、Agent_OnUnLoad関数は無視されます。
<p></p>
      エージェントLが<i>静的リンク</i>の場合、Agent_OnUnLoad関数で規定されたのと同じ引数と期待される戻り値を指定して、Agent_OnUnLoad_L関数が呼び出されます。<i>静的リンク</i>・エージェントLからAgent_OnAttach_Lという名前の関数とAgent_OnAttachという名前の関数がエクスポートされた場合、Agent_OnAttach関数は無視されます。
<h4 id="starting">エージェントのコマンド行オプション</h4>
    以下の「コマンド行オプション」という語は、JNI呼び出しAPIの<code>JNI_CreateJavaVM</code>関数において、<code>JavaVMInitArgs</code>引数で指定されるオプションを意味します。
    <p></p>
    エージェントを適切にロードして実行するには、VMの起動時に次の2つのうちいずれかのコマンド行オプションが必要です。これらの引数は、エージェントを含むライブラリと、起動時に渡されるオプションの文字列を指定します。 
    <dl>
      
<dt>
<code>-agentlib:</code><i>&lt;agent-lib-name></i><code>=</code><i>&lt;options></i>
</dt>
      
<dd>
	<code>-agentlib:</code>の後の名前は、ロードするライブラリの名前です。ライブラリの検索(その完全名と場所の両方)は、プラットフォーム固有の方法で進行します。通常、<i>&lt;agent-lib-name></i>はオペレーティング・システム固有のファイル名に展開されます。<i>&lt;options></i>は、起動時にエージェントに渡されます。たとえばオプション<code>-agentlib:foo=opt1,opt2</code>が指定された場合、VMは、Windows<sup style="font-size: xx-small">TM</sup>の下ではシステム<code>PATH</code>から共有ライブラリ<code>foo.dll</code>をロードしようとし、Solaris<sup style="font-size: xx-small">TM</sup>オペレーティング環境の下では<code>LD_LIBRARY_PATH</code>から<code>libfoo.so</code>をロードしようとします。エージェントのライブラリが実行可能ファイルに静的にリンクされている場合、実際のロード・タスクは発生しません。
    <p></p>
      
</dd>
      
<dt>
<code>-agentpath:</code><i>&lt;path-to-agent></i><code>=</code><i>&lt;options></i>
</dt>
      
<dd>
	<code>-agentpath:</code> の後ろには、ライブラリをロードする絶対パスを指定します。ライブラリ名の展開は行われません。<i>&lt;options></i>は、起動時にエージェントに渡されます。たとえば、オプション<code>-agentpath:c:\myLibs\foo.dll=opt1,opt2</code>が指定された場合、VMは、共有ライブラリ<code>c:\myLibs\foo.dll</code>をロードしようとします。エージェントのライブラリが実行可能ファイルに静的にリンクされている場合、実際のロード・タスクは発生しません。
    <p></p>
      
</dd>
    
</dl>
    動的共有ライブラリ・エージェントの場合、ライブラリ内の起動ルーチン<a href="#onload"><code>Agent_OnLoad</code></a>が呼び出されます。エージェントのライブラリが実行可能ファイルに静的にリンクされている場合、システムは<code>Agent_OnLoad_&lt;agent-lib-name></code>エントリ・ポイント(&lt;agent-lib-name>はエージェントのベース名)を呼び出そうとします。上の例(<code>-agentpath:c:\myLibs\foo.dll=opt1,opt2</code>)の場合、システムは<code>Agent_OnLoad_foo</code>起動ルーチンを見つけて呼び出そうとします。
    <p></p>
    バイト・コード・インストゥルメンテーション(<a href="#bci">bytecode instrumentation</a>)のために必要な場合、ツール内でJavaプログラミング言語コードを使用しやすくするため、<code>-agentlib:</code> または<code>-agentpath:</code>を指定してロードされたライブラリから、JNIネイティブ・メソッド実装が検索されます。
    <p></p>
    エージェント・ライブラリは、その他のすべてのライブラリが検索されたあと検索されます。非エージェント・メソッドのネイティブ・メソッド実装を上書きまたは遮断するエージェントは、<a href="#NativeMethodBind">NativeMethodBind</a>イベントを使用できます。
    <p></p>
    これらのスイッチは上記の処理のみを行います。VMやJVM<small style="font-size: xx-small">&nbsp;</small>TIの状態を変更することはありません。JVM<small style="font-size: xx-small">&nbsp;</small>TIやJVM<small style="font-size: xx-small">&nbsp;</small>TIの側面を有効にするためにコマンド行オプションを指定する必要はありません。これは、プログラム内で<a href="#capability">権限</a>を使用して処理されます。
  <h4 id="startup">エージェントの起動</h4>
    VMは、起動関数を呼び出すことで各エージェントを起動します。<code>OnLoad</code><a href="#GetPhase">段階</a>でエージェントを起動する場合は、関数<a href="#onload"><code>Agent_OnLoad</code></a>(静的リンク・エージェントの場合は<a href="#onload"><code>Agent_OnLoad_L</code></a>)が呼び出されます。ライブ<a href="#GetPhase">段階</a>でエージェントを起動する場合は、関数<a href="#onattach"><code>Agent_OnAttach</code></a>(静的リンク・エージェントの場合は<a href="#onattach"><code>Agent_OnAttach_L</code></a>)が呼び出されます。起動関数の呼出しは、エージェントごとに1回だけ行われます。  
  <h4 id="onload">エージェントの起動(OnLoad段階)</h4>
    <code>OnLoad</code>段階でエージェントを起動する場合、そのエージェント・ライブラリは次のプロトタイプを持つ起動関数をエクスポートする必要があります。
    <blockquote>
<pre>
JNIEXPORT jint JNICALL 
Agent_OnLoad(JavaVM *vm, char *options, void *reserved)</pre>
</blockquote>
    「L」という名前の静的リンク・エージェントの場合: 
    <blockquote>
<pre>
JNIEXPORT jint JNICALL 
Agent_OnLoad_L(JavaVM *vm, char *options, void *reserved)</pre>
</blockquote>

    VMは、この関数を呼び出すことでエージェントを起動します。この呼出しはVM初期化の早い段階で行われるため、次のことが言えます。
    <ul type="disc">
      
<li>
<a href="#SetSystemProperty">システム・プロパティ</a>は、VMの起動で使用される前に設定できる</li>
      
<li>すべての<a href="#capability">権限</a>を使用できる(ただし、VMを構成する権限はこのときしか使用できない。詳細は「<a href="#capability">権限関数</a>」セクションを参照)</li>
      
<li>バイト・コードが実行されていない</li>
      
<li>クラスがロードされていない</li>
      
<li>オブジェクトが作成されていない</li>
    
</ul>
    
<p></p>
    VMは、<code>Agent_OnLoad</code>または<code>Agent_OnLoad_&lt;agent-lib-name></code>関数を、第2引数に<i>&lt;options></i>を指定して呼び出します。つまり、コマンド行オプションの例で言えば、<code>Agent_OnLoad</code>の<code>char *options</code>引数に<code>"opt1,opt2"</code>が渡されます。<code>options</code>引数は<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされます。<i>=&lt;options></i>が指定されなかった場合は、長さゼロの文字列が<code>options</code>に渡されます。<code>options</code>文字列の存続期間は、<code>Agent_OnLoad</code>または<code>Agent_OnLoad_&lt;agent-lib-name></code>呼出しの間です。この期間を超えて必要な場合は、文字列または文字列の一部をコピーする必要があります。<code>Agent_OnLoad</code>が呼び出されてから復帰するまでの期間は、<i>OnLoad段階</i>と呼ばれます。OnLoad <a href="#GetPhase">段階</a>ではVMは初期化されていないため、<code>Agent_OnLoad</code>の内側で使用できる操作セットは限定されます(この時点で使用可能な機能については関数の説明を参照)。エージェントが安全に実行できるのは、オプションの処理や、<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>でイベント・コールバックを設定する処理です。エージェントはVM初期化イベントを受け取った後(つまり、<a href="#VMInit">VMInit</a>コールバックが呼び出された後)、初期化を完了させることができます。
    <p style="color: purple">
  原理の説明: 早い段階での起動が必要なのは、エージェントが目的の権限(その多くはVMの初期化前に設定する必要がある)を設定できるようにするためです。JVMDIでは-Xdebugコマンド行オプションによって、非常に粗粒度の権限制御機能が提供されていました。JVMPI実装では、様々なテクニックを使用して単一の「JVMPIオン」スイッチが提供されます。必要な権限とパフォーマンスへの影響のバランスを取るために必要な、細粒度の制御機能を提供できる適度なコマンド行オプションはありません。また、早い段階での起動は、エージェントが実行環境を制御できるようにする(ファイル・システムやシステム・プロパティを変更して機能をインストールできるようにする)ためにも必要です。
    </p>
    
<p></p>
    <code>Agent_OnLoad</code>または<code>Agent_OnLoad_&lt;agent-lib-name></code>の戻り値は、エラーを示すために使用されます。ゼロ以外の値はすべてエラーを示しており、エラーが発生するとVMは終了します。
  <h4 id="onattach">エージェントの起動(ライブ段階)</h4>
    VMによっては、そのVM内でライブ<a href="#GetPhase">段階</a>でエージェントを起動するメカニズムをサポートしている可能性があります。そのサポート方法の詳細は、実装に固有となります。たとえば、あるツールでは、何らかのプラットフォーム固有のメカニズムや実装固有のAPIを使用することで、実行中のVMに接続して特定のエージェントの起動を要求する可能性があります。
    <p></p>
    ライブ段階でエージェントを起動する場合、そのエージェント・ライブラリは次のプロトタイプを持つ起動関数をエクスポートする必要があります。
    <blockquote>
<pre>
JNIEXPORT jint JNICALL 
Agent_OnAttach(JavaVM* vm, char *options, void *reserved)</pre>
</blockquote>
「L」という名前の静的リンク・エージェントの場合: 
    <blockquote>
<pre>
JNIEXPORT jint JNICALL 
Agent_OnAttach_L(JavaVM* vm, char *options, void *reserved)</pre>
</blockquote>

    
<p></p>         
    VMは、この関数を呼び出すことでエージェントを起動します。これは、VMに接続されたスレッドのコンテキスト内で呼び出されます。第1引数の<i>&lt;vm></i>は、Java VMです。<i>&lt;options></i>引数はエージェントに提供される起動オプションです。<i>&lt;options></i>は<a href="#mUTF">修正UTF-8 </a>文字列としてエンコードされます。起動オプションが指定されなかった場合は、長さゼロの文字列が<code>options</code>に渡されます。<code>options</code>文字列の存続期間は、<code>Agent_OnAttach</code>または<code>Agent_OnAttach_&lt;agent-lib-name></code>呼出しの間です。この期間を超えて必要な場合は、文字列または文字列の一部をコピーする必要があります。
    <p></p>
    ライブ段階では<a href="#capability">権限</a>の一部が使用できない可能性があります。
    <p></p>
    <code>Agent_OnAttach</code>または<code>Agent_OnAttach_&lt;agent-lib-name></code>関数は、エージェントを初期化し、エラーが発生したかどうかを示す値をVMに返します。ゼロ以外の値はすべて、エラーを表します。エラーが発生してもVMは終了しません。代わりにVMは、そのエラーを無視するか、そのエラーを標準エラーに出力したりシステム・ログに記録したりするなど、何らかの実装固有のアクションを実行します。
  <h4 id="onunload">エージェントの停止</h4>
    ライブラリは、オプションで、次のプロトタイプを持つ停止関数をエクスポートできます。
    <blockquote>
<pre>
JNIEXPORT void JNICALL 
Agent_OnUnload(JavaVM *vm)</pre>
</blockquote>
    「L」という名前の静的リンク・エージェントの場合: 
    <blockquote>
<pre>
JNIEXPORT void JNICALL 
Agent_OnUnload_L(JavaVM *vm)</pre>
</blockquote>

    この関数は、ライブラリのアンロードの直前にVMによって呼び出されます。ライブラリは(実行可能ファイルに静的にリンクされたライブラリでないかぎり)アンロードされます。この関数が呼び出されるのは、なんらかのプラットフォーム固有のメカニズムによってアンロードが発生した場合(このドキュメントではアンロード・メカニズムについては規定していない)、あるいはVMの終了(正常終了または起動エラーなどのVMエラーによるもの)によってライブラリが(実質的に)アンロードされる場合です。もちろん、制御されないシャットダウンはこの規則の例外です。この関数と<a href="#VMDeath">VM終了イベント</a>の違いに注意してください。VM終了イベントが送信されるためには、VMが少なくとも初期化のポイントまで実行済であり、かつVMDeathのコールバックを設定し、このイベントを有効化した有効なJVM<small style="font-size: xx-small">&nbsp;</small>TI環境が存在している必要があります。<code>Agent_OnUnload</code>または<code>Agent_OnUnload_&lt;agent-lib-name></code>ではこれらの条件は一切不要です。また、その他の理由でライブラリがアンロードされる場合もこの関数が呼び出されます。VM終了イベントが送信される場合、それは、この関数が呼び出される前に送信されます(VMの終了によってこの関数が呼び出されると仮定した場合)。この関数を使えば、エージェントによって割り当てられたリソースをクリーンアップできます。
  <h4 id="tooloptions">JAVA_TOOL_OPTIONS</h4>
    埋め込みVMや単にスクリプト内の深い場所で起動されるVMなどでは、コマンド行のアクセスや変更が常に可能であるとはかぎらないため、<code>JAVA_TOOL_OPTIONS</code>変数が用意されています。これを使えば、そうした場合でもエージェントを起動できます。
    <p></p>
    環境変数などの名前付き文字列をサポートするプラットフォームでは、<code>JAVA_TOOL_OPTIONS</code>変数がサポートされている可能性があります。この変数は、空白文字の境界で複数のオプションに分解されます。空白文字には、空白、タブ、復帰(CR)、復帰改行(NL)、垂直タブ、用紙送り(FF)などがあります。一連の空白文字は単一の空白文字と同等とみなされます。空白文字は、引用符で囲まれていないかぎり、オプションには含められません。引用方法は次のとおりです。
    <ul type="disc">
        
<li>一重引用符の組('')に囲まれた、一重引用符を除くすべての文字は引用として囲まれる。</li>
        
<li>一重引用符の組の内部にある二重引用符には、特殊な意味はない。</li>
        
<li>二重引用符の組("")に囲まれた、二重引用符を除くすべての文字は引用として囲まれる。</li>
        
<li>二重引用符の組の内部にある一重引用符には、特殊な意味はない。</li>
        
<li>変数内の任意の場所を引用符で囲むことができる。</li>
        
<li>引用符で囲まれた空白文字には、特殊な意味はない。その他の文字と同様にオプションに含めることができ、区切り文字として機能しない。</li>
        
<li>引用符の組自体はオプションに含まれない。</li>
    
</ul>
    
<code>JNI_CreateJavaVM</code>(JNI呼出しAPI内)は、<code>JavaVMInitArgs</code>引数に指定されたオプションの先頭に、これらのオプションを付加します。セキュリティに問題がある場合、プラットフォームはこの機能を無効化することがあります。たとえばリファレンス実装は、UNIXシステムで実効ユーザーIDまたはグループIDが実際のIDと異なる場合に、この機能を無効化します。この機能はツールの初期化(具体的にはネイティブまたはJavaプログラミング言語エージェントの起動など)をサポートするためのものです。複数のツールがこの機能の使用を要求する可能性があるため、変数を上書きするのではなく、かわりに変数にオプションを追加すべきです。変数が処理されるのは、JNI呼出しAPIのVM作成呼出し時であるため、ランチャによって処理されるオプション(VM選択オプションなど)は処理されません。
  <h4 id="environments">環境</h4>
    JVM<small style="font-size: xx-small">&nbsp;</small>TI仕様では、複数JVM<small style="font-size: xx-small">&nbsp;</small>TIエージェントの同時使用がサポートされています。各エージェントはそれぞれ独自のJVM<small style="font-size: xx-small">&nbsp;</small>TI環境を持ちます。つまり、JVM<small style="font-size: xx-small">&nbsp;</small>TIの状態はエージェントごとに異なります。ある環境を変更しても、他の環境はその影響を受けません。JVM<small style="font-size: xx-small">&nbsp;</small>TI環境の状態を次に示します。
    <ul type="disc">
      
<li>
<a href="#SetEventCallbacks">イベント・コールバック</a>
</li>
      
<li>
<a href="#SetEventNotificationMode">有効なイベントのセット</a>
</li>
      
<li>
<a href="#capability">権限</a>
</li>
      
<li>
<a href="#memory">メモリーの割り当て/割当て解除フック</a>
</li>
    
</ul>
    エージェントのJVM<small style="font-size: xx-small">&nbsp;</small>TI状態はそれぞれ独立しているものの、エージェントはVMの共有状態を検査および変更するほか、実行先となるネイティブ環境も共有します。このため、あるエージェントが他のエージェントの結果を混乱させたり、他のエージェントの失敗の原因となる可能性があります。他のエージェントとの互換性のレベルを規定するのは、エージェント開発者の責任です。JVM<small style="font-size: xx-small">&nbsp;</small>TI実装には、エージェント間の破壊的な相互作用を回避する機能はありません。これらの問題が発生する可能性を減らす技法については、このドキュメントでは説明しません。
    <p></p>
    エージェントは、JNI呼び出しAPI関数<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/invocation.html#GetEnv">GetEnv</a>にインタフェースIDとしてJVM<small style="font-size: xx-small">&nbsp;</small>TIのバージョン情報を渡すことによって、JVM<small style="font-size: xx-small">&nbsp;</small>TI環境を作成します。JVM<small style="font-size: xx-small">&nbsp;</small>TI環境の作成と使用の詳細については、「<a href="#jvmtiEnvAccess">JVM<small style="font-size: xx-small">&nbsp;</small>TI関数のアクセス</a>」を参照してください。通常、JVM<small style="font-size: xx-small">&nbsp;</small>TI環境は、<a href="#onload"><code>Agent_OnLoad</code></a>から<code>GetEnv</code>を呼び出すことによって作成されます。
  <h4 id="bci">バイト・コード・インストゥルメンテーション</h4>
    このインタフェースには、プロファイリングをサポートするインタフェースに通常期待されるいくつかのイベントが含まれていません。例として、オブジェクト割当てイベントやフル・スピードのメソッド・エントリ/終了イベントがあげられます。このインタフェースではかわりに、<i>バイトコード・インストゥルメンテーション</i>(ターゲット・プログラムを構成するJava仮想マシン・バイトコード命令を変更する機能)のサポートが提供されます。これらの変更の目的は通常、メソッドのコードに「イベント」を追加すること(たとえば、メソッドの先頭に<code>MyProfiler.methodEntered()</code>呼出しを追加すること)です。変更は単に追加されるため、アプリケーションの状態や動作が変更されることはありません。挿入されるエージェント・コードは標準のバイトコードなので、VMをフル・スピードで実行できます(ターゲット・プログラムのみでなくインストゥルメンテーションも最適化される)。インストゥルメンテーションにバイトコード実行からの切替えが含まれていなければ、高コストの状態遷移が不要となります。その結果、イベントのパフォーマンスが高くなります。さらにこのアプローチは、完全な制御機能をエージェントに提供します。コードの「関心のある」部分(エンド・ユーザーのコードなど)にインストゥルメンテーションを限定可能で、しかも条件付きにできます。インストゥルメンテーションは、全体をJavaプログラミング言語コード内で実行することも、ネイティブ・エージェント内への呼出しを行うこともできます。インストゥルメンテーションは、単純にカウンタを保持することも、イベントの統計サンプリングを行うこともできます。
    <p></p>  
    インストゥルメンテーションの挿入は、次の3とおりのうちのいずれかの方法で行います。
    <ul type="disc">
      
<li>
	静的インストゥルメンテーション: クラス・ファイルは、たとえばインストゥルメンテーションを追加する目的で変更された<code>*.class</code>ファイルを含む複製ディレクトリを作成するなどの方法で、VMにロードされる前に計測されます。この方法はきわめて不自然であり、一般に、ロードされるクラス・ファイルの出所をエージェント側で知ることはできません。
      </li>
      
<li>
	ロード時のインストゥルメンテーション: クラス・ファイルがVMにロードされるとき、クラス・ファイルのrawバイトは、インストゥルメンテーション用としてエージェントに送信されます。クラスのロードによって発生した<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントが、この機能を提供します。このメカニズムは効率がよく、1回かぎりのインストゥルメンテーションに完全にアクセスできます。
      </li>
      
<li>
	動的インストゥルメンテーション: すでにロード済であり、場合によっては実行されている可能性もあるクラスが、変更されます。このオプション機能は、<a href="#RetransformClasses"><code>RetransformClasses</code></a>関数を呼び出すことでトリガーされる<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントによって提供されます。クラスは複数回変更できるほか、元の状態に戻すこともできます。このメカニズムを使えば、実行中に変化するインストゥルメンテーションを実現できます。
      </li>
    
</ul>
    
<p></p>  
    このインタフェースに用意されたクラス変更機能は、インストゥルメンテーションのメカニズムを提供し(<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントと<a href="#RetransformClasses"><code>RetransformClasses</code></a>関数)、開発時には修正しながらデバッグを続けていく(<a href="#RedefineClasses"><code>RedefineClasses</code></a>関数)ために用意されています。
    <p></p>  
    依存関係が混乱しないように、特にコア・クラスを計測する場合は、注意が必要です。たとえば、各オブジェクト割当ての通知を受けるアプローチでは、<code>Object</code>でコンストラクタを計測します。コンストラクタが最初は空であるとすると、このコンストラクタを次のように変更します。
    <blockquote>
<pre>
      public Object() {
        MyProfiler.allocationTracker(this);
      }
    </pre>
</blockquote>
    ただし、<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントを使用してこの変更を行った場合、その影響が次のように典型的なVMに及ぶ可能性があります。最初に作成されるオブジェクトがコンストラクタを呼び出し、その結果、<code>MyProfiler</code>のクラス・ロードが開始されます。次にオブジェクトが作成されますが、<code>MyProfiler</code>はまだロードされていないので無限再帰に陥り、スタック・オーバーフローが発生します。これを改良するには、安全な時間になるまで追跡メソッドの呼出しを遅らせます。たとえば、<code>VMInit</code>イベントのハンドラ内で<code>trackAllocations</code>を設定できます。
    <blockquote>
<pre>
      static boolean trackAllocations = false;

      public Object() {
        if (trackAllocations) {
          MyProfiler.allocationTracker(this);
        }
      }
    </pre>
</blockquote>
    
<p></p>
    <a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>を使えば、ラッパー・メソッドによるネイティブ・メソッドの計測が可能となります。
  <h4 id="mUTF">修正UTF-8の文字列エンコーディング</h4>
    JVM<small style="font-size: xx-small">&nbsp;</small>TIは、修正UTF-8を使って文字列をエンコードします。これは、JNIが使用するのと同じエンコーディングです。修正UTF-8と標準のUTF-8との違いは、補助文字とnull文字の表現方法にあります。詳細については、JNI仕様の「<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html#wp16542">変更後のUTF-8文字列</a>」セクションを参照してください。
  <h4 id="context">仕様のコンテキスト</h4>
    このインタフェースはJava仮想マシンで実行されるアプリケーションの状態にアクセスするため、用語はJavaプラットフォームに関するものであり、特に言及している場合を除いてネイティブ・プラット・フォームに関するものではありません。例を示します。
    <ul type="disc">
      
<li>「スレッド」はJavaプログラミング言語のスレッドを意味する。</li>
      
<li>「スタック・フレーム」はJava仮想マシンのスタック・フレームを意味する。</li>
      
<li>「クラス」はJavaプログラミング言語のクラスを意味する。</li>
      
<li>「ヒープ」はJava仮想マシンのヒープを意味する。</li>
      
<li>「モニター」はJavaプログラミング言語のオブジェクト・モニターを意味する。</li>
    
</ul>
    
<p></p>
    Sun、Sun Microsystems、Sun のロゴ、Java、および JVM は、米国ならびにその他の国における Oracle Corporation およびその関連会社の登録商標です。
  <p id="FunctionSection"></p>
<p></p>
<hr noshade size="3">
<h2>関数</h2>
<h4 id="jvmtiEnvAccess">関数のアクセス</h4>
    ネイティブ・コードは、JVM<small style="font-size: xx-small">&nbsp;</small>TI関数を呼び出してJVM<small style="font-size: xx-small">&nbsp;</small>TI機能にアクセスします。JVM<small style="font-size: xx-small">&nbsp;</small>TI関数には、<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/design.html">Java Native Interface (JNI)関数</a>のアクセス時と同様に、インタフェース・ポインタを使ってアクセスします。JVM<small style="font-size: xx-small">&nbsp;</small>TIインタフェース・ポインタを<i>環境ポインタ</i>と呼びます。
    <p></p>
    環境ポインタは、<code>jvmtiEnv*</code>型の環境へのポインタです。環境には、JVM<small style="font-size: xx-small">&nbsp;</small>TI接続に関する情報があります。環境内の最初の値は、関数テーブルへのポインタです。関数テーブルは、JVM<small style="font-size: xx-small">&nbsp;</small>TI関数へのポインタの配列です。どの関数ポインタも配列内の事前に定義されたオフセットにあります。 
    <p></p>
    C言語から使用される場合: 関数へのアクセス時に二重間接指定が使用されます。つまり環境ポインタは、コンテキストを提供するとともに、各関数呼出しの最初のパラメータになります。次に例を示します。
    <blockquote>
<pre>
jvmtiEnv *jvmti;
...
jvmtiError err = (*jvmti)-&gt;GetLoadedClasses(jvmti, &amp;class_count, &amp;classes);
    </pre>
</blockquote>
    
<p></p>
    C++言語から使用される場合: 各関数は<code>jvmtiEnv</code>のメンバー関数としてアクセスされ、環境ポインタが関数呼出しに渡されることはありません。次に例を示します。
    <blockquote>
<pre>
jvmtiEnv *jvmti;
...
jvmtiError err = jvmti-&gt;GetLoadedClasses(&amp;class_count, &amp;classes);
    </pre>
</blockquote>
    特に指定しないかぎり、この仕様に含まれる例や宣言はすべて、C言語を使用しています。
    <p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TI環境は、JNI呼び出しAPIの<code>GetEnv</code>関数を使って取得できます。
    <blockquote>
<pre>
jvmtiEnv *jvmti;
...
(*jvm)-&gt;GetEnv(jvm, &amp;jvmti, JVMTI_VERSION_1_0);
    </pre>
</blockquote>
    <code>GetEnv</code>を呼び出すたびに、新しいJVM<small style="font-size: xx-small">&nbsp;</small>TI接続、したがって新しいJVM<small style="font-size: xx-small">&nbsp;</small>TI環境が作成されます。<code>GetEnv</code>の<code>version</code>引数は、JVM<small style="font-size: xx-small">&nbsp;</small>TIのバージョンでなければいけません。返された環境のバージョンが要求されたバージョンと異なることもありますが、返された環境は互換性があるはずです。<code>GetEnv</code>から<code>JNI_EVERSION</code>が返されるのは、互換性のあるバージョンが使用可能でない場合、JVM<small style="font-size: xx-small">&nbsp;</small>TIがサポートされていない場合、または現在のVM構成でJVM<small style="font-size: xx-small">&nbsp;</small>TIがサポートされていない場合です。特定のコンテキストでJVM<small style="font-size: xx-small">&nbsp;</small>TI環境を作成するためのその他のインタフェースが追加される可能性があります。各環境はそれぞれ独自の状態(<a href="#SetEventNotificationMode">必要なイベント</a>、<a href="#SetEventCallbacks">イベント処理関数</a>、<a href="#AddCapabilities">権限</a>など)を持ちます。環境を解放するには<a href="#DisposeEnvironment"><code>DisposeEnvironment</code></a>を使用します。したがって、スレッドごとに1つの環境が用意されるJNIと異なり、JVM<small style="font-size: xx-small">&nbsp;</small>TI環境は複数のスレッドにわたって動作し、動的に作成されます。
  <h4 id="functionReturn">関数の戻り値</h4>
    JVM<small style="font-size: xx-small">&nbsp;</small>TI関数は、常に<a href="#jvmtiError"><code>jvmtiError</code></a>関数の戻り値から<a href="#ErrorSection">エラー・コード</a>を返します。関数によっては、呼出し側の関数で指定されたポインタにより、これ以外の値を返すことも可能です。JVM<small style="font-size: xx-small">&nbsp;</small>TIの関数の中にはメモリーを割り当てるものがありますが、この場合はプログラム内でそのメモリーを明示的に解放しなければなりません。これについては、個々のJVM<small style="font-size: xx-small">&nbsp;</small>TI関数の説明に明記されています。空のリスト、配列、シーケンスなどは、<code>NULL</code>として返されます。
    <p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TI関数がエラーに遭遇した場合は(戻り値が<code>JVMTI_ERROR_NONE</code>以外)、引数ポインタにより参照されるメモリー値は未定義です。しかし、メモリーおよびグローバル参照は何も割り当てられません。無効な入力のためにエラーが発生した場合、アクションは一切発生しません。
  <h4 id="refs">JNIオブジェクト参照の管理</h4>
    JVM<small style="font-size: xx-small">&nbsp;</small>TI関数は、JNI参照(<a href="#jobject"><code>jobject</code></a>と<a href="#jclass"><code>jclass</code></a>)およびそれらの派生物(<a href="#jthread"><code>jthread</code></a>と<a href="#jthreadGroup"><code>jthreadGroup</code></a>)を使用してオブジェクトを識別します。JVM<small style="font-size: xx-small">&nbsp;</small>TI関数に渡す参照はグローバル参照、ローカル参照のどちらでもかまいませんが、強い参照でなければいけません。JVM<small style="font-size: xx-small">&nbsp;</small>TI関数から返される参照はすべてローカル参照です。これらのローカル参照はJVM<small style="font-size: xx-small">&nbsp;</small>TI呼出し時に作成されます。ローカル参照は、管理が必要なリソースです(<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp18654">JNIドキュメント</a>を参照)。スレッドがネイティブ・コードから復帰する際に、すべてのローカル参照が解放されます。典型的なエージェント・スレッドを含む一部のスレッドは、決してネイティブ・コードから復帰しません。各スレッドは、明示的な管理を一切行わずに16個のローカル参照を作成できることが保証されています。限られた数のJVM<small style="font-size: xx-small">&nbsp;</small>TI呼出しを実行した後、ネイティブ・コードから復帰するようなスレッド(イベントを処理するスレッドなど)では、明示的な管理が不要であると判断される場合があります。ただし、長時間実行されるエージェント・スレッドでは、明示的なローカル参照管理が必要になります(通常はJNI関数<code>PushLocalFrame</code>と<code>PopLocalFrame</code>を使用)。逆に、ネイティブ・コードからの復帰後も参照を維持するには、それらをグローバル参照に変換する必要があります。これらの規則は<a href="#jmethodID"><code>jmethodID</code></a>と<a href="#jfieldID"><code>jfieldID</code></a>には適用されません。これらは<a href="#jobject"><code>jobject</code></a>ではないからです。
<h4 id="prereqState">関数呼出しの必要条件</h4>
      関数に、スレッドまたはVMを特定の状態(中断など)にするのはエージェントであると明示的に指定されていないかぎり、関数を実行するためにVMを一定の安全な状態にするのは、JVM<small style="font-size: xx-small">&nbsp;</small>TI実装になります。
    <h4 id="functionsExceptions">例外と関数</h4>
      JVM<small style="font-size: xx-small">&nbsp;</small>TI関数から例外がスローされることはありません。エラー状態は<a href="#functionReturn">関数の戻り値</a>として伝えられます。JVM<small style="font-size: xx-small">&nbsp;</small>TI関数が呼び出されている間、既存の例外状態はすべて維持されます。例外の処理については、JNI仕様の<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/design.html#wp770">Java例外</a>に関するセクションを参照してください。
    <h3 id="FunctionIndex">関数の索引</h3>
<ul>
<li>
<a href="#memory"><b>メモリー管理</b></a>
<ul>
<li>
<a href="#Allocate">Allocate</a>
</li>
<li>
<a href="#Deallocate">Deallocate</a>
</li>
</ul>
</li>
<li>
<a href="#threadCategory"><b>スレッド</b></a>
<ul>
<li>
<a href="#GetThreadState">スレッド状態の取得</a>
</li>
<li>
<a href="#GetCurrentThread">現在のスレッドの取得</a>
</li>
<li>
<a href="#GetAllThreads">すべてのスレッドの取得</a>
</li>
<li>
<a href="#SuspendThread">スレッドの中断</a>
</li>
<li>
<a href="#SuspendThreadList">スレッド・リストの中断</a>
</li>
<li>
<a href="#ResumeThread">スレッドの再開</a>
</li>
<li>
<a href="#ResumeThreadList">スレッド・リストの再開</a>
</li>
<li>
<a href="#StopThread">スレッドの停止</a>
</li>
<li>
<a href="#InterruptThread">スレッドの割り込み</a>
</li>
<li>
<a href="#GetThreadInfo">スレッド情報の取得</a>
</li>
<li>
<a href="#GetOwnedMonitorInfo">所有モニター情報の取得</a>
</li>
<li>
<a href="#GetOwnedMonitorStackDepthInfo">所有モニターのスタックの深さ情報の取得</a>
</li>
<li>
<a href="#GetCurrentContendedMonitor">現在競合しているモニターの取得</a>
</li>
<li>
<a href="#RunAgentThread">エージェント・スレッドの実行</a>
</li>
<li>
<a href="#SetThreadLocalStorage">スレッド・ローカルな記憶領域の設定</a>
</li>
<li>
<a href="#GetThreadLocalStorage">スレッド・ローカルな記憶領域の取得</a>
</li>
</ul>
</li>
<li>
<a href="#thread_groups"><b>スレッド・グループ</b></a>
<ul>
<li>
<a href="#GetTopThreadGroups">トップ・レベルのスレッド・グループの取得</a>
</li>
<li>
<a href="#GetThreadGroupInfo">スレッド・グループ情報の取得</a>
</li>
<li>
<a href="#GetThreadGroupChildren">子スレッド・グループの取得</a>
</li>
</ul>
</li>
<li>
<a href="#stack"><b>スタック・フレーム</b></a>
<ul>
<li>
<a href="#GetStackTrace">スタック・トレースの取得</a>
</li>
<li>
<a href="#GetAllStackTraces">すべてのスタック・トレースの取得</a>
</li>
<li>
<a href="#GetThreadListStackTraces">スレッド・リストのスタック・トレースの取得</a>
</li>
<li>
<a href="#GetFrameCount">フレーム・カウントの取得</a>
</li>
<li>
<a href="#PopFrame">フレームのポップ</a>
</li>
<li>
<a href="#GetFrameLocation">フレームの位置の取得</a>
</li>
<li>
<a href="#NotifyFramePop">フレームのポップの通知</a>
</li>
</ul>
</li>
<li>
<a href="#ForceEarlyReturn"><b>早期復帰の強制</b></a>
<ul>
<li>
<a href="#ForceEarlyReturnObject">早期復帰の強制 - オブジェクト型</a>
</li>
<li>
<a href="#ForceEarlyReturnInt">早期復帰の強制 - 整数型</a>
</li>
<li>
<a href="#ForceEarlyReturnLong">早期復帰の強制 - 長整数型</a>
</li>
<li>
<a href="#ForceEarlyReturnFloat">早期復帰の強制 - 浮動小数点数型</a>
</li>
<li>
<a href="#ForceEarlyReturnDouble">早期復帰の強制 - 倍精度浮動小数点数型</a>
</li>
<li>
<a href="#ForceEarlyReturnVoid">早期復帰の強制 - void型</a>
</li>
</ul>
</li>
<li>
<a href="#Heap"><b>ヒープ</b></a>
<ul>
<li>
<a href="#FollowReferences">参照の追跡</a>
</li>
<li>
<a href="#IterateThroughHeap">ヒープ内での反復</a>
</li>
<li>
<a href="#GetTag">タグの取得</a>
</li>
<li>
<a href="#SetTag">タグの設定</a>
</li>
<li>
<a href="#GetObjectsWithTags">タグを使ったオブジェクトの取得</a>
</li>
<li>
<a href="#ForceGarbageCollection">ガベージ・コレクションの強制</a>
</li>
</ul>
</li>
<li>
<a href="#Heap_1_0"><b>ヒープ(1.0)</b></a>
<ul>
<li>
<a href="#IterateOverObjectsReachableFromObject">オブジェクトから到達可能なオブジェクトの反復</a>
</li>
<li>
<a href="#IterateOverReachableObjects">到達可能なオブジェクトの反復</a>
</li>
<li>
<a href="#IterateOverHeap">ヒープの反復</a>
</li>
<li>
<a href="#IterateOverInstancesOfClass">クラスのインスタンスの反復</a>
</li>
</ul>
</li>
<li>
<a href="#local"><b>局所変数</b></a>
<ul>
<li>
<a href="#GetLocalObject">局所変数の取得 - オブジェクト型</a>
</li>
<li>
<a href="#GetLocalInstance">局所インスタンスの取得</a>
</li>
<li>
<a href="#GetLocalInt">局所変数の取得 - 整数型</a>
</li>
<li>
<a href="#GetLocalLong">局所変数の取得 - 長整数型</a>
</li>
<li>
<a href="#GetLocalFloat">局所変数の取得 - 浮動小数点数型</a>
</li>
<li>
<a href="#GetLocalDouble">局所変数の取得 - 倍精度浮動小数点数型</a>
</li>
<li>
<a href="#SetLocalObject">局所変数の設定 - オブジェクト型</a>
</li>
<li>
<a href="#SetLocalInt">局所変数の設定 - 整数型</a>
</li>
<li>
<a href="#SetLocalLong">局所変数の設定 - 長整数型</a>
</li>
<li>
<a href="#SetLocalFloat">局所変数の設定 - 浮動小数点数型</a>
</li>
<li>
<a href="#SetLocalDouble">局所変数の設定 - 倍精度浮動小数点数型</a>
</li>
</ul>
</li>
<li>
<a href="#breakpointCategory"><b>ブレークポイント</b></a>
<ul>
<li>
<a href="#SetBreakpoint">ブレークポイントの設定</a>
</li>
<li>
<a href="#ClearBreakpoint">ブレークポイントの解除</a>
</li>
</ul>
</li>
<li>
<a href="#fieldWatch"><b>監視されるフィールド</b></a>
<ul>
<li>
<a href="#SetFieldAccessWatch">フィールド・アクセスの監視の設定</a>
</li>
<li>
<a href="#ClearFieldAccessWatch">フィールド・アクセスの監視の解除</a>
</li>
<li>
<a href="#SetFieldModificationWatch">フィールド変更の監視の設定</a>
</li>
<li>
<a href="#ClearFieldModificationWatch">フィールド変更の監視の解除</a>
</li>
</ul>
</li>
<li>
<a href="#class"><b>クラス</b></a>
<ul>
<li>
<a href="#GetLoadedClasses">ロード済みクラスの取得</a>
</li>
<li>
<a href="#GetClassLoaderClasses">クラス・ローダー・クラスの取得</a>
</li>
<li>
<a href="#GetClassSignature">クラスのシグニチャの取得</a>
</li>
<li>
<a href="#GetClassStatus">クラスのステータスの取得</a>
</li>
<li>
<a href="#GetSourceFileName">ソース・ファイル名の取得</a>
</li>
<li>
<a href="#GetClassModifiers">クラスの修飾子の取得</a>
</li>
<li>
<a href="#GetClassMethods">クラスのメソッドの取得</a>
</li>
<li>
<a href="#GetClassFields">クラスのフィールドの取得</a>
</li>
<li>
<a href="#GetImplementedInterfaces">実装されたインタフェースの取得</a>
</li>
<li>
<a href="#GetClassVersionNumbers">クラス・バージョン番号の取得</a>
</li>
<li>
<a href="#GetConstantPool">定数プールの取得</a>
</li>
<li>
<a href="#IsInterface">インタフェースかどうかの検査</a>
</li>
<li>
<a href="#IsArrayClass">配列クラスかどうかの検査</a>
</li>
<li>
<a href="#IsModifiableClass">変更可能クラスかどうかの検査</a>
</li>
<li>
<a href="#GetClassLoader">クラス・ローダーの取得</a>
</li>
<li>
<a href="#GetSourceDebugExtension">ソース・デバッグ拡張機能の取得</a>
</li>
<li>
<a href="#RetransformClasses">クラスの再変換</a>
</li>
<li>
<a href="#RedefineClasses">クラスの再定義</a>
</li>
</ul>
</li>
<li>
<a href="#object"><b>オブジェクト</b></a>
<ul>
<li>
<a href="#GetObjectSize">オブジェクト・サイズの取得</a>
</li>
<li>
<a href="#GetObjectHashCode">オブジェクトのハッシュ・コードの取得</a>
</li>
<li>
<a href="#GetObjectMonitorUsage">オブジェクトのモニターの利用情報を取得</a>
</li>
</ul>
</li>
<li>
<a href="#fieldCategory"><b>フィールド</b></a>
<ul>
<li>
<a href="#GetFieldName">フィールドの名前とシグニチャの取得</a>
</li>
<li>
<a href="#GetFieldDeclaringClass">フィールドの宣言クラスの取得</a>
</li>
<li>
<a href="#GetFieldModifiers">フィールドの修飾子の取得</a>
</li>
<li>
<a href="#IsFieldSynthetic">合成フィールドかどうかの検査</a>
</li>
</ul>
</li>
<li>
<a href="#method"><b>メソッド</b></a>
<ul>
<li>
<a href="#GetMethodName">メソッドの名前とシグニチャの取得</a>
</li>
<li>
<a href="#GetMethodDeclaringClass">メソッドの宣言クラスの取得</a>
</li>
<li>
<a href="#GetMethodModifiers">メソッドの修飾子の取得</a>
</li>
<li>
<a href="#GetMaxLocals">局所変数の取得</a>
</li>
<li>
<a href="#GetArgumentsSize">引数のサイズの取得</a>
</li>
<li>
<a href="#GetLineNumberTable">行番号テーブルの取得</a>
</li>
<li>
<a href="#GetMethodLocation">メソッドの配置位置の取得</a>
</li>
<li>
<a href="#GetLocalVariableTable">局所変数テーブルの取得</a>
</li>
<li>
<a href="#GetBytecodes">バイト・コードの取得</a>
</li>
<li>
<a href="#IsMethodNative">ネイティブ・メソッドかどうかの検査</a>
</li>
<li>
<a href="#IsMethodSynthetic">合成メソッドかどうかの検査</a>
</li>
<li>
<a href="#IsMethodObsolete">廃棄されたメソッドかどうかの検査</a>
</li>
<li>
<a href="#SetNativeMethodPrefix">ネイティブ・メソッド接頭辞の設定</a>
</li>
<li>
<a href="#SetNativeMethodPrefixes">複数のネイティブ・メソッド接頭辞の設定</a>
</li>
</ul>
</li>
<li>
<a href="#RawMonitors"><b>rawモニター</b></a>
<ul>
<li>
<a href="#CreateRawMonitor">rawモニターの作成</a>
</li>
<li>
<a href="#DestroyRawMonitor">rawモニターの破棄</a>
</li>
<li>
<a href="#RawMonitorEnter">rawモニターの開始</a>
</li>
<li>
<a href="#RawMonitorExit">rawモニターの終了</a>
</li>
<li>
<a href="#RawMonitorWait">rawモニターの待機</a>
</li>
<li>
<a href="#RawMonitorNotify">rawモニターの通知</a>
</li>
<li>
<a href="#RawMonitorNotifyAll">rawモニターの通知(すべて)</a>
</li>
</ul>
</li>
<li>
<a href="#jniIntercept"><b>JNI関数の遮断</b></a>
<ul>
<li>
<a href="#SetJNIFunctionTable">JNI関数テーブルの設定</a>
</li>
<li>
<a href="#GetJNIFunctionTable">JNI関数テーブルの取得</a>
</li>
</ul>
</li>
<li>
<a href="#eventManagement"><b>イベント管理</b></a>
<ul>
<li>
<a href="#SetEventCallbacks">イベント・コールバックの設定</a>
</li>
<li>
<a href="#SetEventNotificationMode">イベント通知モードの設定</a>
</li>
<li>
<a href="#GenerateEvents">イベントの生成</a>
</li>
</ul>
</li>
<li>
<a href="#extension"><b>拡張機能メカニズム</b></a>
<ul>
<li>
<a href="#GetExtensionFunctions">拡張関数の取得</a>
</li>
<li>
<a href="#GetExtensionEvents">拡張イベントの取得</a>
</li>
<li>
<a href="#SetExtensionEventCallback">拡張イベント・コールバックの設定</a>
</li>
</ul>
</li>
<li>
<a href="#capability"><b>権限</b></a>
<ul>
<li>
<a href="#GetPotentialCapabilities">潜在的な権限の取得</a>
</li>
<li>
<a href="#AddCapabilities">権限の追加</a>
</li>
<li>
<a href="#RelinquishCapabilities">権限の放棄</a>
</li>
<li>
<a href="#GetCapabilities">権限の取得</a>
</li>
</ul>
</li>
<li>
<a href="#timers"><b>タイマー</b></a>
<ul>
<li>
<a href="#GetCurrentThreadCpuTimerInfo">現在のスレッドのCPUタイマー情報を取得</a>
</li>
<li>
<a href="#GetCurrentThreadCpuTime">現在のスレッドのCPU時間を取得</a>
</li>
<li>
<a href="#GetThreadCpuTimerInfo">スレッドのCPUタイマー情報を取得</a>
</li>
<li>
<a href="#GetThreadCpuTime">スレッドのCPU時間を取得</a>
</li>
<li>
<a href="#GetTimerInfo">タイマー情報の取得</a>
</li>
<li>
<a href="#GetTime">時間の取得</a>
</li>
<li>
<a href="#GetAvailableProcessors">使用可能なプロセッサの取得</a>
</li>
</ul>
</li>
<li>
<a href="#classLoaderSearch"><b>クラス・ローダー検索</b></a>
<ul>
<li>
<a href="#AddToBootstrapClassLoaderSearch">ブートストラップ・クラス・ローダー検索の追加</a>
</li>
<li>
<a href="#AddToSystemClassLoaderSearch">システム・クラス・ローダー検索の追加</a>
</li>
</ul>
</li>
<li>
<a href="#props"><b>システム・プロパティ</b></a>
<ul>
<li>
<a href="#GetSystemProperties">システム・プロパティの取得</a>
</li>
<li>
<a href="#GetSystemProperty">システム・プロパティの取得</a>
</li>
<li>
<a href="#SetSystemProperty">システム・プロパティの設定</a>
</li>
</ul>
</li>
<li>
<a href="#general"><b>全般</b></a>
<ul>
<li>
<a href="#GetPhase">段階の取得</a>
</li>
<li>
<a href="#DisposeEnvironment">環境の破棄</a>
</li>
<li>
<a href="#SetEnvironmentLocalStorage">環境ローカル記憶領域の設定</a>
</li>
<li>
<a href="#GetEnvironmentLocalStorage">環境ローカル記憶領域の取得</a>
</li>
<li>
<a href="#GetVersionNumber">バージョン番号の取得</a>
</li>
<li>
<a href="#GetErrorName">エラー名の取得</a>
</li>
<li>
<a href="#SetVerboseFlag">冗長フラグの設定</a>
</li>
<li>
<a href="#GetJLocationFormat">JLocation形式の取得</a>
</li>
</ul>
</li>
</ul>
<p id="memory"></p>
<hr noshade size="3">
<h2 align="center">メモリー管理</h2>メモリー管理関数:
  <ul>
<li>
<a href="#Allocate">Allocate</a>
</li>
<li>
<a href="#Deallocate">Deallocate</a>
</li>
</ul>
      これらの関数は、JVM<small style="font-size: xx-small">&nbsp;</small>TI機能で使用されるメモリの割当て/割当て解除機能を備えており、エージェント用の作業メモリーを提供するために使用できます。JVM<small style="font-size: xx-small">&nbsp;</small>TIで管理されるメモリーは、他のメモリー割当てライブラリやメカニズムとは互換性がありません。
    <p></p>
<hr noshade width="100%" size="1" id="Allocate">
<h3>Allocate</h3>
<blockquote>
<pre>jvmtiError
Allocate(jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)</pre>
</blockquote>
	JVM<small style="font-size: xx-small">&nbsp;</small>TIのアロケータを使用して、メモリーの領域を割り当てます。割り当てられたメモリーは、<a href="#Deallocate"><code>Deallocate</code></a>によって解放してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>46</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="Allocate.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    割り当てるバイト数。
	    <p style="color: purple">
  原理の説明: <code>jlong</code>はJVMDIとの互換性を実現するために使用される。
	    </p>
	  
</td>
</tr>
<tr>
<td><code id="Allocate.mem_ptr">mem_ptr</code></td><td><code>unsigned char**</code></td><td>
	    戻ったとき、割り当てられたメモリーの先頭を指すポインタ。<code>size</code>がゼロの場合、<code>NULL</code>が返される。
	  <p></p>エージェントは<code>unsigned char*</code>へのポインタを渡す。戻ったとき、<code>unsigned char*</code>は、サイズ<code>size</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OUT_OF_MEMORY"><code>JVMTI_ERROR_OUT_OF_MEMORY</code></a></td><td>
	  メモリー要求を履行できない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#Allocate.size"><code>size</code></a>がゼロより小さい。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#Allocate.mem_ptr"><code>mem_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="Deallocate">
<h3>Deallocate</h3>
<blockquote>
<pre>jvmtiError
Deallocate(jvmtiEnv* env,
            unsigned char* mem)</pre>
</blockquote>
	JVM<small style="font-size: xx-small">&nbsp;</small>TIのアロケータを使用して、<code>mem</code>を解放します。この関数は、JVM<small style="font-size: xx-small">&nbsp;</small>TIの関数によって割り当てられて返されたメモリー(<a href="#Allocate"><code>Allocate</code></a>を使用して割り当てられたメモリーを含む)を解放するために使用します。割り当てられたすべてのメモリーを解除するまで、メモリーを再生することはできません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>47</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="Deallocate.mem">mem</code></td><td><code> unsigned char *</code></td><td>
	    割り当てられたメモリーの先頭を指すポインタ。「On return, the elements are set」は無視してよい。
              
	  <p></p>エージェントは、<code>unsigned char</code>の配列を渡す。配列の要素の値は無視される。戻ったとき、要素が設定されている。<code>mem</code>が<code>NULL</code>の場合、呼出しが無視される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>を返します</td>
</tr>
</table>
<p id="threadCategory"></p>
<hr noshade size="3">
<h2 align="center">スレッド</h2>スレッド関数:
  <ul>
<li>
<a href="#GetThreadState">スレッド状態の取得</a>
</li>
<li>
<a href="#GetCurrentThread">現在のスレッドの取得</a>
</li>
<li>
<a href="#GetAllThreads">すべてのスレッドの取得</a>
</li>
<li>
<a href="#SuspendThread">スレッドの中断</a>
</li>
<li>
<a href="#SuspendThreadList">スレッド・リストの中断</a>
</li>
<li>
<a href="#ResumeThread">スレッドの再開</a>
</li>
<li>
<a href="#ResumeThreadList">スレッド・リストの再開</a>
</li>
<li>
<a href="#StopThread">スレッドの停止</a>
</li>
<li>
<a href="#InterruptThread">スレッドの割り込み</a>
</li>
<li>
<a href="#GetThreadInfo">スレッド情報の取得</a>
</li>
<li>
<a href="#GetOwnedMonitorInfo">所有モニター情報の取得</a>
</li>
<li>
<a href="#GetOwnedMonitorStackDepthInfo">所有モニターのスタックの深さ情報の取得</a>
</li>
<li>
<a href="#GetCurrentContendedMonitor">現在競合しているモニターの取得</a>
</li>
<li>
<a href="#RunAgentThread">エージェント・スレッドの実行</a>
</li>
<li>
<a href="#SetThreadLocalStorage">スレッド・ローカルな記憶領域の設定</a>
</li>
<li>
<a href="#GetThreadLocalStorage">スレッド・ローカルな記憶領域の取得</a>
</li>
</ul>スレッドの関数型:
    <ul>
<li>
<a href="#jvmtiStartFunction">エージェント起動関数</a>
</li>
</ul>スレッドの型:
    <ul>
<li>
<a href="#jvmtiThreadInfo"><code>jvmtiThreadInfo</code></a> - スレッド情報構造体</li>
<li>
<a href="#jvmtiMonitorStackDepthInfo"><code>jvmtiMonitorStackDepthInfo</code></a> - モニター・スタック深さ情報構造体</li>
</ul>スレッドのフラグおよび定数:
    <ul>
<li>
<a href="#jvmtiThreadState">スレッド状態のフラグ</a>
</li>
<li>
<a href="#jvmtiJavaLangThreadState">java.lang.Thread.State変換マスク</a>
</li>
<li>
<a href="#jvmtiThreadPriority">スレッド優先順位定数</a>
</li>
</ul>
    
<p></p>
<hr noshade width="100%" size="1" id="GetThreadState">
<h3>スレッド状態の取得</h3>
<blockquote>
<pre>jvmtiError
GetThreadState(jvmtiEnv* env,
            jthread thread,
            jint* thread_state_ptr)</pre>
</blockquote>
        スレッドの状態を取得します。スレッドの状態は、以下の一連の質問に答えることでわかります。
          <ul type="circle">
            
<li>
<i>活動状態か</i>
              
<ul type="disc">
                
<li>活動状態ではない。
                  <ul type="circle">
                    
<li>
<i>なぜ活動状態ではないか</i>
                      
<ul type="disc">
                        
<li>新規であるため。</li>
                        
<li>終了したため(<a href="#JVMTI_THREAD_STATE_TERMINATED"><code>JVMTI_THREAD_STATE_TERMINATED</code></a>)</li>
                      
</ul>
                    
</li>
                  
</ul>
                
</li>
                
<li>活動状態(<a href="#JVMTI_THREAD_STATE_ALIVE"><code>JVMTI_THREAD_STATE_ALIVE</code></a>)
                  <ul type="circle">
                    
<li>
<i>中断したか</i>
                      
<ul type="disc">
                        
<li>中断した(<a href="#JVMTI_THREAD_STATE_SUSPENDED"><code>JVMTI_THREAD_STATE_SUSPENDED</code></a>)</li>
                        
<li>中断していない</li>
                      
</ul>
                    
</li>
                    
<li>
<i>割り込みか</i>
                      
<ul type="disc">
                        
<li>割り込み(<a href="#JVMTI_THREAD_STATE_INTERRUPTED"><code>JVMTI_THREAD_STATE_INTERRUPTED</code></a>)</li>
                        
<li>割込みでない。</li>
                      
</ul>
                    
</li>
                    
<li>
<i>ネイティブ・コード内か</i>
                      
<ul type="disc">
                        
<li>ネイティブ・コード内(<a href="#JVMTI_THREAD_STATE_IN_NATIVE"><code>JVMTI_THREAD_STATE_IN_NATIVE</code></a>)</li>
                        
<li>Javaプログラミング言語コード内</li>
                      
</ul>
                    
</li>
                    
<li>
<i>どの活動状態か</i>
                      
<ul type="disc">
                        
<li>実行可能状態(<a href="#JVMTI_THREAD_STATE_RUNNABLE"><code>JVMTI_THREAD_STATE_RUNNABLE</code></a>)</li>
                        
<li>ロックされている(<a href="#JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER"><code>JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code></a>)</li>
                        
<li>待機中(<a href="#JVMTI_THREAD_STATE_WAITING"><code>JVMTI_THREAD_STATE_WAITING</code></a>)
                          <ul type="circle">
                            
<li>
<i>待機時間は</i>
                              
<ul type="disc">
                                
<li>未定義(<a href="#JVMTI_THREAD_STATE_WAITING_INDEFINITELY"><code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code></a>)
</li>
                                
<li>定義されている(<a href="#JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT"><code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code></a>)</li>
                              
</ul>
                            
</li>
                            
<li>
<i>待機理由は</i>
                              
<ul type="disc">
                                
<li>Object.wait (<a href="#JVMTI_THREAD_STATE_IN_OBJECT_WAIT"><code>JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code></a>)</li>
                                
<li>LockSupport.park (<a href="#JVMTI_THREAD_STATE_PARKED"><code>JVMTI_THREAD_STATE_PARKED</code></a>)</li>
                                
<li>スリープ中(<a href="#JVMTI_THREAD_STATE_SLEEPING"><code>JVMTI_THREAD_STATE_SLEEPING</code></a>)</li>
                              
</ul>
                            
</li>
                          
</ul>
                        
</li>
                      
</ul>
                    
</li>
                  
</ul>
                
</li>
              
</ul>
            
</li>
          
</ul>
        
<p></p>
	答えは次のビット・ベクトルで表されます。 
	<blockquote>
<a name="jvmtiThreadState"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">スレッド状態のフラグ</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_ALIVE">JVMTI_THREAD_STATE_ALIVE</code></td><td align="right">0x0001</td><td>
	    スレッドは活動状態。スレッドが新規(起動していない)または終了した場合は、0。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_TERMINATED">JVMTI_THREAD_STATE_TERMINATED</code></td><td align="right">0x0002</td><td>
	    スレッドは実行を完了した。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_RUNNABLE">JVMTI_THREAD_STATE_RUNNABLE</code></td><td align="right">0x0004</td><td>
	    スレッドは実行可能。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER">JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code></td><td align="right">0x0400</td><td>
	    スレッドは同期ブロックまたはメソッドの入力を待機中。または<code>Object.wait()</code>のあとで、同期ブロックまたはメソッドの再入力を待機中。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_WAITING">JVMTI_THREAD_STATE_WAITING</code></td><td align="right">0x0080</td><td>
	    スレッドは待機中。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_WAITING_INDEFINITELY">JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code></td><td align="right">0x0010</td><td>
	    スレッドはタイム・アウトなしで待機中。たとえば、<code>Object.wait()</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT">JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code></td><td align="right">0x0020</td><td>
	    スレッドは、指定された最大待機時間で待機中。たとえば、<code>Object.wait(long)</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_SLEEPING">JVMTI_THREAD_STATE_SLEEPING</code></td><td align="right">0x0040</td><td>
	    スレッドはスリープ中 - <code>Thread.sleep(long)</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_IN_OBJECT_WAIT">JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code></td><td align="right">0x0100</td><td>
	    スレッドはオブジェクト・モニターを待機中 - <code>Object.wait</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_PARKED">JVMTI_THREAD_STATE_PARKED</code></td><td align="right">0x0200</td><td>
	    スレッドは一時停止中。<code>LockSupport.park</code>、<code>LockSupport.parkUtil</code>、および<code>LockSupport.parkNanos</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_SUSPENDED">JVMTI_THREAD_STATE_SUSPENDED</code></td><td align="right">0x100000</td><td>
	    スレッドが中断された。<code>java.lang.Thread.suspend()</code>またはJVM<small style="font-size: xx-small">&nbsp;</small>TIの中断関数(<a href="#SuspendThread"><code>SuspendThread</code></a>など)がスレッドで呼び出された。このビットが設定されている場合、他のビットはスレッドの中断前の状態を表します。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_INTERRUPTED">JVMTI_THREAD_STATE_INTERRUPTED</code></td><td align="right">0x200000</td><td>
	    スレッド割込みが発生した。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_IN_NATIVE">JVMTI_THREAD_STATE_IN_NATIVE</code></td><td align="right">0x400000</td><td>
            スレッドはネイティブ・コード内にある。つまり、VMまたはJavaプログラミング言語コードに呼び戻されなかったネイティブ・メソッドが実行中。
            <p></p>
            このフラグは、VMでコンパイルされたJavaプログラミング言語コードの実行中、VMコードの実行中、VMサポート・コードの実行中は設定されない。JNIおよびJVM<small style="font-size: xx-small">&nbsp;</small>TI関数などのネイティブVMインタフェース関数は、VMコードとして実装することも可能。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_VENDOR_1">JVMTI_THREAD_STATE_VENDOR_1</code></td><td align="right">0x10000000</td><td>
            VMベンダーが定義する。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_VENDOR_2">JVMTI_THREAD_STATE_VENDOR_2</code></td><td align="right">0x20000000</td><td>
            VMベンダーが定義する。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_STATE_VENDOR_3">JVMTI_THREAD_STATE_VENDOR_3</code></td><td align="right">0x40000000</td><td>
            VMベンダーが定義する。
	  </td>
</tr>
</table>
</blockquote>
        次の定義は、JVM<small style="font-size: xx-small">&nbsp;</small>TIスレッド状態を<code>java.lang.Thread.State</code>形式の状態に変換するために使用します。
	<blockquote>
<a name="jvmtiJavaLangThreadState"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">java.lang.Thread.State変換マスク</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_MASK">JVMTI_JAVA_LANG_THREAD_STATE_MASK</code></td><td align="right">JVMTI_THREAD_STATE_TERMINATED | JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</td><td>
	    比較前に、この値で状態をマスクする
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_NEW">JVMTI_JAVA_LANG_THREAD_STATE_NEW</code></td><td align="right">0</td><td>
	    <code>java.lang.Thread.State.NEW</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED">JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED</code></td><td align="right">JVMTI_THREAD_STATE_TERMINATED</td><td>
	    <code>java.lang.Thread.State.TERMINATED</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE">JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE</td><td>
	    <code>java.lang.Thread.State.RUNNABLE</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED">JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</td><td>
	    <code>java.lang.Thread.State.BLOCKED</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_WAITING">JVMTI_JAVA_LANG_THREAD_STATE_WAITING</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY</td><td>
	    <code>java.lang.Thread.State.WAITING</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING">JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING</code></td><td align="right">JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</td><td>
	    <code>java.lang.Thread.State.TIMED_WAITING</code>
	  </td>
</tr>
</table>
</blockquote>
        
<b>規則</b>
        
<p></p>
        質問に対する回答は多くても1つですが、回答がないこともあります(回答が不明であるか、該当しないか、どの回答も正しくないため)。ある回答が設定されるのは、それを包含する回答が一致する場合のみです。つまり、次のいずれか1つ以上は設定できません。
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_RUNNABLE</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_WAITING</code>
</li>
          
</ul>
        <code>JVMTI_THREAD_STATE_ALIVE</code>が設定されている場合、J2SE<sup style="font-size: xx-small">TM</sup>準拠実装では、以上のいずれかが常に設定されます。いずれかが設定されている場合は、包含する回答<code>JVMTI_THREAD_STATE_ALIVE</code>が設定されます。以下のいずれか1つのみを
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code>
</li>
          
</ul>
        設定できます(<code>JVMTI_THREAD_STATE_WAITING</code>が設定されている場合、J2SE<sup style="font-size: xx-small">TM</sup>準拠実装では、これらのいずれかが常に設定されます)。いずれかが設定されている場合、包含する回答<code>JVMTI_THREAD_STATE_ALIVE</code>および<code>JVMTI_THREAD_STATE_WAITING</code>が設定されます。以下のいずれか1つのみを
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_PARKED</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_SLEEPING</code>
</li>
          
</ul>
        設定できます。いずれかが設定されている場合、包含する回答<code>JVMTI_THREAD_STATE_ALIVE</code>および<code>JVMTI_THREAD_STATE_WAITING</code>が設定されます。また<code>JVMTI_THREAD_STATE_SLEEPING</code>が設定されている場合は、<code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code>が設定されます。状態<i>A</i>が状態<i>B</i>のメカニズムを使用して実装されている場合、この関数で返されるのは状態<i>A</i>です。たとえば<code>Thread.sleep(long)</code>が<code>Object.wait(long)</code>を使用して実装されている場合は、返されるのは<code>JVMTI_THREAD_STATE_SLEEPING</code>のままです。以下は複数設定できます。
          <ul type="circle">
              
<li>
<code>JVMTI_THREAD_STATE_SUSPENDED</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_INTERRUPTED</code>
</li>
              
<li>
<code>JVMTI_THREAD_STATE_IN_NATIVE</code>
</li>
          
</ul>
        ただし、いずれかが設定されると、<code>JVMTI_THREAD_STATE_ALIVE</code>が設定されます。
        <p></p>
        そして、<code>JVMTI_THREAD_STATE_TERMINATED</code>は<code>JVMTI_THREAD_STATE_ALIVE</code>が設定されるまでは設定されません。  
        <p></p>
        スレッド状態の表現は、将来のバージョンの仕様での拡張を前提に設計されています。スレッド状態の値を使用する際にはその点に留意すべきです(つまり、序数として使用すべきではない)。ほとんどのクエリーは単一のビットをテストすることで行えますが、switch文で状態ビットを使用する必要がある場合には、状態ビットを対象のビットでマスクすべきです。上で定義されていないビットはすべて、将来用として予約されたものです。現在の仕様に準拠したVMは、予約ビットをゼロに設定する必要があります。エージェントは予約ビットを無視すべきです。予約ビットは、ゼロであると仮定すべきではなく、したがって比較式に含めるべきではありません。
        <p></p>
        
<b>例</b>
        
<p></p>
        これから説明する値は、予約ビットとベンダー・ビットを除外しています。
        <p></p>
        <code>synchronized</code>文でブロックされたスレッドの状態は次のようになります。
        <blockquote>
<pre>
            JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER
        </pre>
</blockquote>
        開始していないスレッドの状態は次のようになります。
        <blockquote>
<pre>
            0
        </pre>
</blockquote>
        <code>Object.wait(3000)</code>によるスレッドの状態は次のようになります。
        <blockquote>
<pre>
            JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_WAITING + 
                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + 
                JVMTI_THREAD_STATE_MONITOR_WAITING
        </pre>
</blockquote>
        実行可能中に中断されたスレッドの状態は次のようになります。
        <blockquote>
<pre>
            JVMTI_THREAD_STATE_ALIVE + JVMTI_THREAD_STATE_RUNNABLE + JVMTI_THREAD_STATE_SUSPENDED
        </pre>
</blockquote>
        
<p></p>
        
<b>状態のテスト</b>
        
<p></p>
        ほとんどの場合、スレッドの状態は該当する状態に対応する1ビットをテストすれば判明します。たとえば、スレッドがスリープ状態かどうかをテストするコードは次のとおりです。
        <blockquote>
<pre>
	jint state;
	jvmtiError err;

	err = (*jvmti)-&gt;GetThreadState(jvmti, thread, &amp;state);
	if (err == JVMTI_ERROR_NONE) {
	   if (state &amp; JVMTI_THREAD_STATE_SLEEPING) {  ...
        </pre>
</blockquote>
        
<p></p>
        待機中(<code>Object.wait</code>、一時停止中、またはスリープ中)の場合は、次のとおりです。
        <blockquote>
<pre>
	   if (state &amp; JVMTI_THREAD_STATE_WAITING) {  ...
        </pre>
</blockquote>
        状態によっては、複数ビットをテストする必要があります。スレッドが開始していないかどうかをテストする場合などです。
        <blockquote>
<pre>
	   if ((state &amp; (JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_TERMINATED)) == 0)  {  ...
        </pre>
</blockquote>
        時間指定した場合としていない場合の<code>Object.wait</code>を区別するには、次のようにします。
        <blockquote>
<pre>
	   if (state &amp; JVMTI_THREAD_STATE_IN_OBJECT_WAIT)  {  
             if (state &amp; JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT)  {
               printf("in Object.wait(long timeout)\n");
             } else {
               printf("in Object.wait()\n");
             }
           }
        </pre>
</blockquote>
        
<p></p>
        
<b><code>java.lang.Thread.State</code></b>との関係
        
<p></p>
        <code>java.lang.Thread.getState()</code>から返される<code>java.lang.Thread.State</code>で示されるスレッドの状態は、この関数から返される情報のサブセットです。対応する<code>java.lang.Thread.State</code>は、指定された変換マスクを使用して決定できます。たとえば、次のコードは<code>java.lang.Thread.State</code>スレッド状態の名前を返します。
        <blockquote>
<pre>
	    err = (*jvmti)-&gt;GetThreadState(jvmti, thread, &amp;state);
	    abortOnError(err);
            switch (state &amp; JVMTI_JAVA_LANG_THREAD_STATE_MASK) {
            case JVMTI_JAVA_LANG_THREAD_STATE_NEW:
              return "NEW";
            case JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED:
              return "TERMINATED";
            case JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE:
              return "RUNNABLE";
            case JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED:
              return "BLOCKED";
            case JVMTI_JAVA_LANG_THREAD_STATE_WAITING:
              return "WAITING";
            case JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING:
              return "TIMED_WAITING";
            }
        </pre>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>17</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadState.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      照会するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetThreadState.thread_state_ptr">thread_state_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、<a href="#jvmtiThreadState">スレッド状態フラグ</a>の定義に従って状態フラグをポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetThreadState.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadState.thread_state_ptr"><code>thread_state_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetCurrentThread">
<h3>現在のスレッドの取得</h3>
<blockquote>
<pre>jvmtiError
GetCurrentThread(jvmtiEnv* env,
            jthread* thread_ptr)</pre>
</blockquote>
        現在のスレッドを取得します。現在のスレッドとは、この関数を呼び出したJavaプログラミング言語スレッドのことです。
        <p></p>
        スレッドを引数に取るJVM<small style="font-size: xx-small">&nbsp;</small>TI関数のほとんどは、<code>NULL</code>を現在のスレッドを意味するものとして受け入れます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>18</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetCurrentThread.thread_ptr">thread_ptr</code></td><td><code><a href="#jthread">jthread</a>*</code></td><td>
	     戻ったとき、現在のスレッドをポイントする。
	  <p></p>エージェントは<code>jthread</code>へのポインタを渡す。戻ったとき、<code>jthread</code>が設定されている。<code>thread_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetCurrentThread.thread_ptr"><code>thread_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetAllThreads">
<h3>すべてのスレッドの取得</h3>
<blockquote>
<pre>jvmtiError
GetAllThreads(jvmtiEnv* env,
            jint* threads_count_ptr,
            jthread** threads_ptr)</pre>
</blockquote>
        すべてのライブ・スレッドを取得します。これらのスレッドは、Javaプログラミング言語のスレッド(つまりVMに接続されたスレッド)です。あるスレッドがライブ・スレッドになるのは、<code>java.lang.Thread.isAlive()</code>が<code>true</code>を返す場合(つまり、そのスレッドが起動後まだ終了していない場合)です。スレッドの領域はJVM<small style="font-size: xx-small">&nbsp;</small>TI環境のコンテキストによって決まりますが、それは通常、VMに接続されたすべてのスレッドになります。これにはJVM<small style="font-size: xx-small">&nbsp;</small>TIエージェント・スレッドも含まれます(<a href="#RunAgentThread"><code>RunAgentThread</code></a>を参照)。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>4</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetAllThreads.threads_count_ptr">threads_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、実行中のスレッドの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetAllThreads.threads_ptr">threads_ptr</code></td><td><code><a href="#jthread">jthread</a>**</code></td><td>
	      戻ったとき、参照(実行中のスレッドごとに1つずつ)の配列をポイントする。
	    <p></p>エージェントは<code>jthread*</code>へのポインタを渡す。戻ったとき、<code>jthread*</code>は、サイズ<code>*threads_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>threads_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetAllThreads.threads_count_ptr"><code>threads_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetAllThreads.threads_ptr"><code>threads_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SuspendThread">
<h3>スレッドの中断</h3>
<blockquote>
<pre>jvmtiError
SuspendThread(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
        指定されたスレッドを中断します。呼出し側スレッドが指定されている場合、この関数は、ほかのスレッドが<a href="#ResumeThread"><code>ResumeThread</code></a>を呼び出すまで戻りません。スレッドが現在中断されている場合、この関数は何も行わず、エラーを返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>5</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a></td><td>
	  スレッドを中断し、再開できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SuspendThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      中断するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_SUSPENDED"><code>JVMTI_ERROR_THREAD_SUSPENDED</code></a></td><td>
          スレッドはすでに中断されている。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#SuspendThread.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#SuspendThread.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SuspendThreadList">
<h3>スレッド・リストの中断</h3>
<blockquote>
<pre>jvmtiError
SuspendThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)</pre>
</blockquote>
        <a href="#SuspendThreadList.request_list"><code>request_list</code></a>配列に指定された<a href="#SuspendThreadList.request_count"><code>request_count</code></a>個のスレッドを中断します。スレッドの再開には、<a href="#ResumeThreadList"><code>ResumeThreadList</code></a>または<a href="#ResumeThread"><code>ResumeThread</code></a>を使用します。<a href="#SuspendThreadList.request_list"><code>request_list</code></a>配列に呼出し側スレッドが指定されている場合、この関数は、ほかのスレッドによって再開されるまで戻りません。スレッドの中断中に発生したエラーは、この関数の戻り値<b>ではな</b>く、<a href="#SuspendThreadList.results"><code>results</code></a>配列内に返されます。現在中断しているスレッドの状態は変わりません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>92</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a></td><td>
	  スレッドを中断し、再開できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SuspendThreadList.request_count">request_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    中断するスレッドの数。
	  </td>
</tr>
<tr>
<td><code id="SuspendThreadList.request_list">request_list</code></td><td><code>const <a href="#jthread">jthread</a>*</code></td><td>
	      中断するスレッドのリスト。
	    <p></p>エージェントは<code>jthread</code>の<code>request_count</code>要素の配列を渡す。 </td>
</tr>
<tr>
<td><code id="SuspendThreadList.results">results</code></td><td><code><a href="#jvmtiError">jvmtiError</a>*</code></td><td>
	    エージェントによって提供された<a href="#SuspendThreadList.request_count"><code>request_count</code></a>要素の配列。戻ったとき、対応するスレッドの中断のエラー・コードが入っている。スレッドがこの呼出しによって中断した場合、エラー・コードは<a href="#JVMTI_ERROR_NONE"><code>JVMTI_ERROR_NONE</code></a>になる。その他のエラー・コードは、<a href="#SuspendThread"><code>SuspendThread</code></a>に指定されたエラー・コード。
	  <p></p>エージェントは、<code>jvmtiError</code>の<code>request_count</code>要素を十分保持できる大きさの配列を渡す。配列の要素の値は無視される。戻ったとき、要素が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SuspendThreadList.request_count"><code>request_count</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#SuspendThreadList.request_list"><code>request_list</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#SuspendThreadList.results"><code>results</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ResumeThread">
<h3>スレッドの再開</h3>
<blockquote>
<pre>jvmtiError
ResumeThread(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
        中断されているスレッドの実行を再開します。現在JVM<small style="font-size: xx-small">&nbsp;</small>TI中断関数(例、<a href="#SuspendThread"><code>SuspendThread</code></a>)または<code>java.lang.Thread.suspend()</code>によって中断されているスレッドの実行を再開します。その他のスレッドには影響はありません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>6</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a></td><td>
	  スレッドを中断し、再開できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ResumeThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      再開するスレッド。
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
          スレッドは中断されていない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_TYPESTATE"><code>JVMTI_ERROR_INVALID_TYPESTATE</code></a></td><td>
          スレッドの状態が変更されたため、不整合が生じている。 
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#ResumeThread.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#ResumeThread.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ResumeThreadList">
<h3>スレッド・リストの再開</h3>
<blockquote>
<pre>jvmtiError
ResumeThreadList(jvmtiEnv* env,
            jint request_count,
            const jthread* request_list,
            jvmtiError* results)</pre>
</blockquote>
        <a href="#ResumeThreadList.request_list"><code>request_list</code></a>配列に指定された<a href="#ResumeThreadList.request_count"><code>request_count</code></a>個のスレッドを再開します。JVM<small style="font-size: xx-small">&nbsp;</small>TI中断関数(例: <a href="#SuspendThreadList"><code>SuspendThreadList</code></a>)または<code>java.lang.Thread.suspend()</code>経由で中断されたすべてのスレッドの実行が再開されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>93</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a></td><td>
	  スレッドを中断し、再開できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ResumeThreadList.request_count">request_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    再開するスレッドの数。
	  </td>
</tr>
<tr>
<td><code id="ResumeThreadList.request_list">request_list</code></td><td><code>const <a href="#jthread">jthread</a>*</code></td><td>
	      再開するスレッド。
	    <p></p>エージェントは<code>jthread</code>の<code>request_count</code>要素の配列を渡す。 </td>
</tr>
<tr>
<td><code id="ResumeThreadList.results">results</code></td><td><code><a href="#jvmtiError">jvmtiError</a>*</code></td><td>
	    エージェントによって提供された<a href="#ResumeThreadList.request_count"><code>request_count</code></a>要素の配列。戻ったとき、対応するスレッドの再開のエラー・コードが入っている。スレッドがこの呼出しによって中断した場合、エラー・コードは<a href="#JVMTI_ERROR_NONE"><code>JVMTI_ERROR_NONE</code></a>になる。その他のエラー・コードは、<a href="#ResumeThread"><code>ResumeThread</code></a>に指定されたエラー・コード。
	  <p></p>エージェントは、<code>jvmtiError</code>の<code>request_count</code>要素を十分保持できる大きさの配列を渡す。配列の要素の値は無視される。戻ったとき、要素が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_suspend"><code>can_suspend</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#ResumeThreadList.request_count"><code>request_count</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#ResumeThreadList.request_list"><code>request_list</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#ResumeThreadList.results"><code>results</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="StopThread">
<h3>スレッドの停止</h3>
<blockquote>
<pre>jvmtiError
StopThread(jvmtiEnv* env,
            jthread thread,
            jobject exception)</pre>
</blockquote>
	指定された非同期の例外を指定されたスレッドに送ります(<code>java.lang.Thread.stop</code>と同様)。通常、この関数は、指定されたスレッドを、例外<code>ThreadDeath</code>のインスタンスを使って終了させるために使います。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>7</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a></td><td>
	  スレッドに停止または割込み信号を送信できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="StopThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      停止するスレッド。
	    </td>
</tr>
<tr>
<td><code id="StopThread.exception">exception</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      非同期の例外オブジェクト。
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#StopThread.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#StopThread.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#StopThread.exception"><code>exception</code></a>がオブジェクトではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="InterruptThread">
<h3>スレッドの割込み</h3>
<blockquote>
<pre>jvmtiError
InterruptThread(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
	指定されたスレッドに割り込みます(<code>java.lang.Thread.interrupt</code>と同様)。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>8</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a></td><td>
	  スレッドに停止または割込み信号を送信できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="InterruptThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      割り込むスレッド。
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_signal_thread"><code>can_signal_thread</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#InterruptThread.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#InterruptThread.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetThreadInfo">
<h3>スレッド情報の取得</h3>
<blockquote>
<pre>typedef struct {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
} jvmtiThreadInfo;</pre>
<pre>jvmtiError
GetThreadInfo(jvmtiEnv* env,
            jthread thread,
            jvmtiThreadInfo* info_ptr)</pre>
</blockquote>
	スレッド情報を取得します。<a href="#jvmtiThreadInfo"><code>jvmtiThreadInfo</code></a>構造体のフィールドに、指定されたスレッドの詳細が入ります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>9</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p id="jvmtiThreadInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiThreadInfo</code> - スレッド情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.name">name</code></td><td><code>char*</code></td><td>
	    スレッド名。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.priority">priority</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    スレッドの優先順位。スレッド優先順位定数<a href="#jvmtiThreadPriority"><code>jvmtiThreadPriority</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.is_daemon">is_daemon</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	    デーモン・スレッドかどうか
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.thread_group">thread_group</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a></code></td><td>
	    このスレッドが属するスレッド・グループ。スレッドが停止している場合は<code>NULL</code>。
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadInfo.context_class_loader">context_class_loader</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      このスレッドに関連付けられているコンテキスト・クラス・ローダー。
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      照会するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetThreadInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiThreadInfo">jvmtiThreadInfo</a>*</code></td><td>
	    戻ったとき、指定されたスレッドについての情報が入っている。
	    <p></p>
	    コンテキスト・クラス・ローダーを認識しないJDK 1.1の実装の場合、<code>context_class_loader</code>フィールドはNULL。
	  <p></p>エージェントは<code>jvmtiThreadInfo</code>へのポインタを渡す。戻ったとき、<code>jvmtiThreadInfo</code>が設定されている。<code>jvmtiThreadInfo</code>の<code>name</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiThreadInfo</code>のフィールド<code>thread_group</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。<code>jvmtiThreadInfo</code>のフィールド<code>context_class_loader</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetThreadInfo.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadInfo.info_ptr"><code>info_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetOwnedMonitorInfo">
<h3>所有モニター情報の取得</h3>
<blockquote>
<pre>jvmtiError
GetOwnedMonitorInfo(jvmtiEnv* env,
            jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr)</pre>
</blockquote>
	指定されたスレッドが所有するモニターについての情報を取得します。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>10</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_owned_monitor_info"><code>can_get_owned_monitor_info</code></a></td><td>
	  モニターの所有に関する情報を取得できる - <a href="#GetOwnedMonitorInfo"><code>GetOwnedMonitorInfo</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      照会するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorInfo.owned_monitor_count_ptr">owned_monitor_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    返されるモニターの数。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorInfo.owned_monitors_ptr">owned_monitors_ptr</code></td><td><code><a href="#jobject">jobject</a>**</code></td><td>
	      所有されるモニターの配列。
	    <p></p>エージェントは<code>jobject*</code>へのポインタを渡す。戻ったとき、<code>jobject*</code>は、サイズ<code>*owned_monitor_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>owned_monitors_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_owned_monitor_info"><code>can_get_owned_monitor_info</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetOwnedMonitorInfo.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetOwnedMonitorInfo.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetOwnedMonitorInfo.owned_monitor_count_ptr"><code>owned_monitor_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetOwnedMonitorInfo.owned_monitors_ptr"><code>owned_monitors_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetOwnedMonitorStackDepthInfo">
<h3>所有モニターのスタックの深さ情報の取得</h3>
<blockquote>
<pre>typedef struct {
    jobject monitor;
    jint stack_depth;
} jvmtiMonitorStackDepthInfo;</pre>
<pre>jvmtiError
GetOwnedMonitorStackDepthInfo(jvmtiEnv* env,
            jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr)</pre>
</blockquote>
	指定されたスレッドが所有するモニターに関する情報と、それらのモニターをロックしているスタック・フレームの深さを取得します。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>153</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_owned_monitor_stack_depth_info"><code>can_get_owned_monitor_stack_depth_info</code></a></td><td>
	  所有されているモニターに関する情報とスタックの深さを取得できる - <a href="#GetOwnedMonitorStackDepthInfo"><code>GetOwnedMonitorStackDepthInfo</code></a>
	</td>
</tr>
</table>
<p id="jvmtiMonitorStackDepthInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiMonitorStackDepthInfo</code> - モニター・スタック深さ情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiMonitorStackDepthInfo.monitor">monitor</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      所有されるモニター。
	    </td>
</tr>
<tr>
<td><code id="jvmtiMonitorStackDepthInfo.stack_depth">stack_depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    スタックの深さ。<a href="#stack">スタック・フレーム関数</a>で使用されるスタックの深さに対応している。つまり、0は現在のフレームを、1は現在のフレームを呼び出したフレームをそれぞれ表す。また、実装がスタックの深さを判断できない場合は - 1になる(JNIの<code>MonitorEnter</code>を使って取得されたモニターの場合など)。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorStackDepthInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      照会するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorStackDepthInfo.monitor_info_count_ptr">monitor_info_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    返されるモニターの数。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetOwnedMonitorStackDepthInfo.monitor_info_ptr">monitor_info_ptr</code></td><td><code> <a href="#jvmtiMonitorStackDepthInfo">jvmtiMonitorStackDepthInfo</a> **</code></td><td>
	    所有されるモニターの深さ情報の配列。
	  <p></p>エージェントは<code>jvmtiMonitorStackDepthInfo*</code>へのポインタを渡す。戻ったとき、<code>jvmtiMonitorStackDepthInfo*</code>は、サイズ<code>*monitor_info_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiMonitorStackDepthInfo</code>のフィールド<code>monitor</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_owned_monitor_stack_depth_info"><code>can_get_owned_monitor_stack_depth_info</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.monitor_info_count_ptr"><code>monitor_info_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetOwnedMonitorStackDepthInfo.monitor_info_ptr"><code>monitor_info_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetCurrentContendedMonitor">
<h3>現在競合しているモニターの取得</h3>
<blockquote>
<pre>jvmtiError
GetCurrentContendedMonitor(jvmtiEnv* env,
            jthread thread,
            jobject* monitor_ptr)</pre>
</blockquote>
	指定されたスレッドが、<code>java.lang.Object.wait</code>を使ってオブジェクトのモニターに入るか、モニターを獲得し直すのを待機している場合に、そのオブジェクトを取得します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>11</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_current_contended_monitor"><code>can_get_current_contended_monitor</code></a></td><td>
	  <a href="#GetCurrentContendedMonitor"><code>GetCurrentContendedMonitor</code></a>が可能
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetCurrentContendedMonitor.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      照会するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetCurrentContendedMonitor.monitor_ptr">monitor_ptr</code></td><td><code><a href="#jobject">jobject</a>*</code></td><td>
	      戻ったとき、現在競合しているモニターが入っている。そのようなモニターがない場合はNULLが入っている。
	    <p></p>エージェントは<code>jobject</code>へのポインタを渡す。戻ったとき、<code>jobject</code>が設定されている。<code>monitor_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_current_contended_monitor"><code>can_get_current_contended_monitor</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetCurrentContendedMonitor.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetCurrentContendedMonitor.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetCurrentContendedMonitor.monitor_ptr"><code>monitor_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiStartFunction">
<h3>エージェント起動関数</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env, 
     JNIEnv* jni_env, 
     void* arg);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。この関数は、<a href="#RunAgentThread"><code>RunAgentThread</code></a>で開始されるエージェント・スレッドのエントリ・ポイントになります。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiStartFunction.jvmti_env">jvmti_env</code></td><td><code> <a href="#jvmtiEnv">jvmtiEnv</a> *</code></td><td>
	      JVM<small style="font-size: xx-small">&nbsp;</small>TI環境。
	    </td>
</tr>
<tr>
<td><code id="jvmtiStartFunction.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
              JNI環境。
            </td>
</tr>
<tr>
<td><code id="jvmtiStartFunction.arg">arg</code></td><td><code> void *</code></td><td>
                <a href="#RunAgentThread"><code>RunAgentThread</code></a>に渡された<code>arg</code>パラメータ。
              </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RunAgentThread">
<h3>エージェント・スレッドの実行</h3>
<blockquote>
<pre>jvmtiError
RunAgentThread(jvmtiEnv* env,
            jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority)</pre>
</blockquote>
	指定されたネイティブ関数を使って、エージェント・スレッドの実行を開始します。パラメータ<a href="#RunAgentThread.arg"><code>arg</code></a>は<a href="#jvmtiStartFunction">起動関数</a> (<a href="#RunAgentThread.proc"><code>proc</code></a>で指定)の単一の引数として転送されます。この関数により、<code>java.lang.Thread</code>の特別なサブクラスや<code>java.lang.Runnable</code>の実装側をロードせずに、別のプロセスとの通信処理またはイベント処理用のエージェント・スレッドを作成できます。その代わり、作成されたスレッドは完全にネイティブ・コード内で実行できます。ただし、作成するスレッドには、<code>java.lang.Thread</code>の新しく作成されたインスタンス(引数<code>thread</code>によって参照される)が必要で、そのインスタンスにスレッドを関連付けます。スレッド・オブジェクトは、JNI呼出しで作成できます。
	<p></p>
	次に一般的なスレッド優先順位を参考として示します。
	<blockquote>
<a name="jvmtiThreadPriority"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">スレッド優先順位定数</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_MIN_PRIORITY">JVMTI_THREAD_MIN_PRIORITY</code></td><td align="right">1</td><td>
	    いちばん低い優先順位
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_NORM_PRIORITY">JVMTI_THREAD_NORM_PRIORITY</code></td><td align="right">5</td><td>
	    中間の優先順位
	  </td>
</tr>
<tr>
<td><code id="JVMTI_THREAD_MAX_PRIORITY">JVMTI_THREAD_MAX_PRIORITY</code></td><td align="right">10</td><td>
	    いちばん高い優先順位
	  </td>
</tr>
</table>
</blockquote>
	
<p></p>
	新しいスレッドは、指定の<a href="#RunAgentThread.priority"><code>priority</code></a>で、デーモン・スレッドとして起動されます。有効な場合は、<a href="#ThreadStart"><code>ThreadStart</code></a>イベントが送信されます。
	<p></p>
        スレッドの起動が完了しているため、このスレッドはこの関数が戻る際にライブ状態になっています。ただし、このスレッドがすぐに終了した場合は除きます。
	<p></p>
        このスレッドのスレッド・グループは無視されます。具体的には、このスレッドは、スレッド・グループに追加されず、Javaプログラミング言語、JVM<small style="font-size: xx-small">&nbsp;</small>TIのいずれのレベルでもスレッド・グループのクエリーには表示されません。
	<p></p>
        このスレッドは、Javaプログラミング言語のクエリーでは表示されませんが、<a href="#GetAllThreads"><code>GetAllThreads</code></a>や<a href="#GetAllStackTraces"><code>GetAllStackTraces</code></a>など、JVM<small style="font-size: xx-small">&nbsp;</small>TIのクエリーには含まれます。
	<p></p>
	<code>proc</code>の実行時に、新しいスレッドはVMに接続されます。『Java Native Interface仕様』の「<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/invocation.html#wp1060">VMへの接続</a>」を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>12</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RunAgentThread.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      実行するスレッド。
	    </td>
</tr>
<tr>
<td><code id="RunAgentThread.proc">proc</code></td><td><code> <a href="#jvmtiStartFunction">jvmtiStartFunction</a> </code></td><td>
	    起動関数。
	  <p></p>
</td>
</tr>
<tr>
<td><code id="RunAgentThread.arg">arg</code></td><td><code>const void *</code></td><td>
	    起動関数の引数。
	  <p></p>エージェントがポインタを渡す。<code>arg</code>が<code>NULL</code>の場合、起動関数に<code>NULL</code>が渡される。
</td>
</tr>
<tr>
<td><code id="RunAgentThread.priority">priority</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    開始されるスレッドの優先順位。<code>java.lang.Thread.setPriority</code>で許可されているスレッド優先順位を使用できる(<a href="#jvmtiThreadPriority"><code>jvmtiThreadPriority</code></a>の優先順位を含む)。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_PRIORITY"><code>JVMTI_ERROR_INVALID_PRIORITY</code></a></td><td> 
            <a href="#RunAgentThread.priority"><code>priority</code></a>が<a href="#JVMTI_THREAD_MIN_PRIORITY"><code>JVMTI_THREAD_MIN_PRIORITY</code></a>より低いか<a href="#JVMTI_THREAD_MAX_PRIORITY"><code>JVMTI_THREAD_MAX_PRIORITY</code></a>より高い
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#RunAgentThread.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#RunAgentThread.proc"><code>proc</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetThreadLocalStorage">
<h3>スレッド・ローカルな記憶領域の設定</h3>
<blockquote>
<pre>jvmtiError
SetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            const void* data)</pre>
</blockquote>
	VMは、個々の環境スレッド・ペアに関連付けられているポインタ値を格納します。このポインタ値を<i>スレッド・ローカルな記憶領域</i>と呼びます。この関数で設定されない場合、値は<code>NULL</code>になります。エージェントは、スレッド固有の情報を格納するため、メモリーを割り当てることができます。スレッド・ローカルな記憶領域を設定することにより、<a href="#GetThreadLocalStorage"><code>GetThreadLocalStorage</code></a>を使ってアクセスできるようになります。
	<p></p>
        この関数は、JVM<small style="font-size: xx-small">&nbsp;</small>TIのスレッド・ローカルな記憶領域の値を設定するため、エージェントによって呼び出されます。JVM<small style="font-size: xx-small">&nbsp;</small>TIは、エージェントに対して、スレッドごとの情報を記録するために利用できる、ポインタ・サイズのスレッド・ローカルな記憶領域を提供します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>103</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetThreadLocalStorage.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      このスレッドを格納する。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="SetThreadLocalStorage.data">data</code></td><td><code>const void *</code></td><td>
	    スレッド・ローカルな記憶領域に入力する値。
	  <p></p>エージェントがポインタを渡す。<code>data</code>が<code>NULL</code>の場合、値は<code>NULL</code>に設定される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#SetThreadLocalStorage.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#SetThreadLocalStorage.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetThreadLocalStorage">
<h3>スレッド・ローカルな記憶領域の取得</h3>
<blockquote>
<pre>jvmtiError
GetThreadLocalStorage(jvmtiEnv* env,
            jthread thread,
            void** data_ptr)</pre>
</blockquote>
        JVM<small style="font-size: xx-small">&nbsp;</small>TIのスレッド・ローカルな記憶領域の値を取得するため、エージェントによって呼び出されます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>102</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadLocalStorage.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      このスレッドから取得する。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetThreadLocalStorage.data_ptr">data_ptr</code></td><td><code>void**</code></td><td>
	    スレッド・ローカルな記憶領域の値を返すポインタ。スレッド・ローカルな記憶領域が<a href="#SetThreadLocalStorage"><code>SetThreadLocalStorage</code></a>で設定されていない場合、返されるポインタは<code>NULL</code>。
	  <p></p>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetThreadLocalStorage.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetThreadLocalStorage.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadLocalStorage.data_ptr"><code>data_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="thread_groups"></p>
<hr noshade size="3">
<h2 align="center">スレッド・グループ</h2>スレッド・グループ関数:
  <ul>
<li>
<a href="#GetTopThreadGroups">トップ・レベルのスレッド・グループの取得</a>
</li>
<li>
<a href="#GetThreadGroupInfo">スレッド・グループ情報の取得</a>
</li>
<li>
<a href="#GetThreadGroupChildren">子スレッド・グループの取得</a>
</li>
</ul>スレッド・グループの型:
    <ul>
<li>
<a href="#jvmtiThreadGroupInfo"><code>jvmtiThreadGroupInfo</code></a> - スレッド・グループ情報構造体</li>
</ul>
    
<p></p>
<hr noshade width="100%" size="1" id="GetTopThreadGroups">
<h3>トップ・レベルのスレッド・グループの取得</h3>
<blockquote>
<pre>jvmtiError
GetTopThreadGroups(jvmtiEnv* env,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)</pre>
</blockquote>
	VM内のトップ・レベルの(親がない)スレッド・グループをすべて返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>13</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetTopThreadGroups.group_count_ptr">group_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、トップ・レベルのスレッド・グループの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetTopThreadGroups.groups_ptr">groups_ptr</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a>**</code></td><td>
	      戻ったとき、トップ・レベルのスレッド・グループの配列を指すポインタを参照する。
	    <p></p>エージェントは<code>jthreadGroup*</code>へのポインタを渡す。戻ったとき、<code>jthreadGroup*</code>は、サイズ<code>*group_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>groups_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetTopThreadGroups.group_count_ptr"><code>group_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetTopThreadGroups.groups_ptr"><code>groups_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetThreadGroupInfo">
<h3>スレッド・グループ情報の取得</h3>
<blockquote>
<pre>typedef struct {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
} jvmtiThreadGroupInfo;</pre>
<pre>jvmtiError
GetThreadGroupInfo(jvmtiEnv* env,
            jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr)</pre>
</blockquote>
	スレッド・グループの情報を取得します。<a href="#jvmtiThreadGroupInfo"><code>jvmtiThreadGroupInfo</code></a>構造体のフィールドに、指定されたスレッド・グループの詳細が入ります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>14</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p id="jvmtiThreadGroupInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiThreadGroupInfo</code> - スレッド・グループ情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.parent">parent</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a></code></td><td>
	    親スレッド・グループ。
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.name">name</code></td><td><code>char*</code></td><td>
	    スレッド・グループの名前。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.max_priority">max_priority</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    このスレッド・グループの最高の優先順位。
	  </td>
</tr>
<tr>
<td><code id="jvmtiThreadGroupInfo.is_daemon">is_daemon</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	    デーモン・スレッド・グループかどうか。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadGroupInfo.group">group</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a></code></td><td>
	    照会するスレッド・グループ。
	  </td>
</tr>
<tr>
<td><code id="GetThreadGroupInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiThreadGroupInfo">jvmtiThreadGroupInfo</a>*</code></td><td>
	    戻ったとき、指定されたスレッド・グループについての情報が入っている。 
	  <p></p>エージェントは<code>jvmtiThreadGroupInfo</code>へのポインタを渡す。戻ったとき、<code>jvmtiThreadGroupInfo</code>が設定されている。<code>jvmtiThreadGroupInfo</code>のフィールド<code>parent</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。<code>jvmtiThreadGroupInfo</code>の<code>name</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD_GROUP"><code>JVMTI_ERROR_INVALID_THREAD_GROUP</code></a></td><td>
	  <a href="#GetThreadGroupInfo.group"><code>group</code></a>はスレッド・グループ・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadGroupInfo.info_ptr"><code>info_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetThreadGroupChildren">
<h3>子スレッド・グループの取得</h3>
<blockquote>
<pre>jvmtiError
GetThreadGroupChildren(jvmtiEnv* env,
            jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr)</pre>
</blockquote>
	このスレッド・グループ内のライブ・スレッドとアクティブなサブグループを取得します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>15</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.group">group</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a></code></td><td>
	    照会するグループ。
	  </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.thread_count_ptr">thread_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、このスレッド・グループ内のライブ・スレッドの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.threads_ptr">threads_ptr</code></td><td><code><a href="#jthread">jthread</a>**</code></td><td>
	      戻ったとき、このスレッド・グループ内のライブ・スレッドの配列をポイントする。
	    <p></p>エージェントは<code>jthread*</code>へのポインタを渡す。戻ったとき、<code>jthread*</code>は、サイズ<code>*thread_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>threads_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.group_count_ptr">group_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、アクティブな子スレッド・グループの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetThreadGroupChildren.groups_ptr">groups_ptr</code></td><td><code><a href="#jthreadGroup">jthreadGroup</a>**</code></td><td>
	      戻ったとき、アクティブな子スレッド・グループの配列をポイントする。
	    <p></p>エージェントは<code>jthreadGroup*</code>へのポインタを渡す。戻ったとき、<code>jthreadGroup*</code>は、サイズ<code>*group_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>groups_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD_GROUP"><code>JVMTI_ERROR_INVALID_THREAD_GROUP</code></a></td><td>
	  <a href="#GetThreadGroupChildren.group"><code>group</code></a>はスレッド・グループ・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadGroupChildren.thread_count_ptr"><code>thread_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadGroupChildren.threads_ptr"><code>threads_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadGroupChildren.group_count_ptr"><code>group_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadGroupChildren.groups_ptr"><code>groups_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<p id="stack"></p>
<hr noshade size="3">
<h2 align="center">スタック・フレーム</h2>スタック・フレーム関数:
  <ul>
<li>
<a href="#GetStackTrace">スタック・トレースの取得</a>
</li>
<li>
<a href="#GetAllStackTraces">すべてのスタック・トレースの取得</a>
</li>
<li>
<a href="#GetThreadListStackTraces">スレッド・リストのスタック・トレースの取得</a>
</li>
<li>
<a href="#GetFrameCount">フレーム・カウントの取得</a>
</li>
<li>
<a href="#PopFrame">フレームのポップ</a>
</li>
<li>
<a href="#GetFrameLocation">フレームの位置の取得</a>
</li>
<li>
<a href="#NotifyFramePop">フレームのポップの通知</a>
</li>
</ul>スタック・フレームの型:
    <ul>
<li>
<a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a> - スタック・フレーム情報構造体</li>
<li>
<a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a> - スタック情報構造体</li>
</ul>
        これらの関数は、スレッドのスタックに関する情報を提供します。スタック・フレームは、深さで参照されます。深さゼロのフレームが現在のフレームです。
        <p></p>
        スタック・フレームについては、<cite>Java(tm)仮想マシン仕様のセクション3.6</cite>に記載されています。つまり、これらのフレームは、ネイティブ・メソッドを含むメソッドの呼出しに対応しているが、プラットフォーム固有のフレームやVM内部のフレームには対応していません。
        <p></p>
        JVM<small style="font-size: xx-small">&nbsp;</small>TI実装はメソッド呼び出しを使用してスレッドを起動する可能性があるので、対応するフレームがそれらの関数によって提供される情報として、スタック内に含まれる可能性があります。つまり、<code>main()</code>や<code>run()</code>よりも深い位置に表示されるフレームが存在する可能性があります。ただしこの表現は、スタック・フレームやスタックの深さを使用するすべてのJVM<small style="font-size: xx-small">&nbsp;</small>TI機能の間で一貫している必要があります。
    <h4 id="jvmtiFrameInfo">スタック・フレーム情報構造体</h4>
          スタック・フレームに関する情報は次の構造体で戻されます。
        <p></p>
<blockquote>
<pre>typedef struct {
    jmethodID method;
    jlocation location;
} jvmtiFrameInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiFrameInfo</code> - スタック・フレーム情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiFrameInfo.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      このフレーム内で実行されているメソッド。
	    </td>
</tr>
<tr>
<td><code id="jvmtiFrameInfo.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	    このフレーム内で実行されている命令のインデックス。フレームがネイティブ・メソッドを実行している場合は<code>-1</code>。
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiStackInfo">スタック情報構造体</h4>
          スタック・フレーム・セットに関する情報は次の構造体で戻されます。
        <p></p>
<blockquote>
<pre>typedef struct {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
} jvmtiStackInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiStackInfo</code> - スタック情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    戻ったとき、トレースされたスレッド。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.state">state</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    戻ったとき、スレッドの状態。<a href="#GetThreadState"><code>GetThreadState</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.frame_buffer">frame_buffer</code></td><td><code> <a href="#jvmtiFrameInfo">jvmtiFrameInfo</a> *</code></td><td>
	      戻ったとき、このエージェントによって割り当てられたバッファに、スタック・フレーム情報が入っている。  
	    </td>
</tr>
<tr>
<td><code id="jvmtiStackInfo.frame_count">frame_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    戻ったとき、レコード数が<code>frame_buffer</code>に入っている。これはmin(<code>max_frame_count</code>, <i>stackDepth</i>)になる。
	  </td>
</tr>
</table>
</blockquote>
<p></p>
<hr noshade width="100%" size="1" id="GetStackTrace">
<h3>スタック・トレースの取得</h3>
<blockquote>
<pre>jvmtiError
GetStackTrace(jvmtiEnv* env,
            jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr)</pre>
</blockquote>
        あるスレッドのスタックに関する情報を取得します。<a href="#GetStackTrace.max_frame_count"><code>max_frame_count</code></a>がスタックの深さより小さい場合、<a href="#GetStackTrace.max_frame_count"><code>max_frame_count</code></a>のいちばん上のフレームが返され、それ以外の場合はスタック全体が返されます。最後に呼び出されたフレームである最上位フレームが、返されるバッファの先頭になります。
        <p></p>
        次の例では、いちばん上のフレームから5つめまでのフレームが返されます。さらに、フレームがある場合は、現在実行しているメソッドの名前が出力されます。
        <blockquote>
<pre>
jvmtiFrameInfo frames[5];
jint count;
jvmtiError err;

err = (*jvmti)-&gt;GetStackTrace(jvmti, aThread, 0, 5, 
                               frames, &amp;count);
if (err == JVMTI_ERROR_NONE &amp;&amp; count &gt;= 1) {
   char *methodName;
   err = (*jvmti)-&gt;GetMethodName(jvmti, frames[0].method, 
                       &amp;methodName, NULL, NULL);
   if (err == JVMTI_ERROR_NONE) {
      printf("Executing method: %s", methodName);
   }
}
        </pre>
</blockquote>
        
        
<p></p>
        <a href="#GetStackTrace.thread"><code>thread</code></a>は、中断することなく、この関数を呼び出すことができます。  
        <p></p>
        位置と行番号のマッピングには、<a href="#GetLineNumberTable"><code>GetLineNumberTable</code></a>関数を使用できます。このマッピングは、遅延してもかまいません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>104</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetStackTrace.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      このスレッドのスタック・トレースをフェッチする。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetStackTrace.start_depth">start_depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    フレームの取得をこの深さから開始する。負でない場合は現在のフレームからカウントし、最初に取得されるフレームは深さ<code>start_depth</code>になる。たとえば、0の場合は現在のフレームから開始し、1の場合は現在のフレームの呼出し元から開始し、2の場合は現在のフレームの呼出し元の呼出し元から開始する、といった具合になる。負の場合、もっとも古いフレームの下からカウントし、最初に取得されるフレームは深さ<i>stackDepth</i><code> + start_depth</code>になる(<i>stackDepth</i>はスタックのフレーム数)。たとえば、マイナス1の場合はもっとも古いフレームのみが取得され、マイナス2の場合はもっとも古いフレームから呼び出されたフレームから開始する。
	  </td>
</tr>
<tr>
<td><code id="GetStackTrace.max_frame_count">max_frame_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    取得する<a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>レコードの最大数。
	  </td>
</tr>
<tr>
<td><code id="GetStackTrace.frame_buffer">frame_buffer</code></td><td><code> <a href="#jvmtiFrameInfo">jvmtiFrameInfo</a> *</code></td><td>
	      戻ったとき、このエージェントによって割り当てられたバッファに、スタック・フレーム情報が入っている。  
	    <p></p>エージェントは、<code>jvmtiFrameInfo</code>の<code>max_frame_count</code>要素を十分保持できる大きさの配列を渡す。配列の要素の値は無視される。戻ったとき、要素の<code>*count_ptr</code>が設定される。 </td>
</tr>
<tr>
<td><code id="GetStackTrace.count_ptr">count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、情報を入力されるレコードの数をポイントする。<code>start_depth</code>が負の数でない場合、min(<code>max_frame_count</code>, <i>stackDepth</i><code> - start_depth</code>)。<code>start_depth</code>が負の数の場合、min(<code>max_frame_count</code>, <code>-start_depth</code>)。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetStackTrace.start_depth"><code>start_depth</code></a>が正で、<i>stackDepth</i>と等しいかそれよりも大きい。または、<a href="#GetStackTrace.start_depth"><code>start_depth</code></a>が負で、<i>-stackDepth</i>よりも小さい。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetStackTrace.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetStackTrace.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetStackTrace.max_frame_count"><code>max_frame_count</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetStackTrace.frame_buffer"><code>frame_buffer</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetStackTrace.count_ptr"><code>count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetAllStackTraces">
<h3>すべてのスタック・トレースの取得</h3>
<blockquote>
<pre>jvmtiError
GetAllStackTraces(jvmtiEnv* env,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr)</pre>
</blockquote>
        すべてのライブ・スレッドのスタックに関する情報を取得します(<a href="#RunAgentThread">エージェント・スレッド</a>を含む)。<a href="#GetAllStackTraces.max_frame_count"><code>max_frame_count</code></a>がスタックの深さより小さい場合、そのスレッドについて<a href="#GetAllStackTraces.max_frame_count"><code>max_frame_count</code></a>のいちばん上のフレームが返され、それ以外の場合はスタック全体が返されます。最後に呼び出されたフレームである最上位フレームが、返されるバッファの先頭になります。
        <p></p>
        すべてのスタックは、同時に収集されます。つまり、あるスレッドのサンプリングと次のスレッドのサンプリングとの間には、スレッドの状態またはスタックに変更は発生しません。スレッドを中断する必要はありません。
        
        <blockquote>
<pre>
jvmtiStackInfo *stack_info;
jint thread_count;
int ti;
jvmtiError err;

err = (*jvmti)-&gt;GetAllStackTraces(jvmti, MAX_FRAMES, &amp;stack_info, &amp;thread_count); 
if (err != JVMTI_ERROR_NONE) {
   ...   
}
for (ti = 0; ti &lt; thread_count; ++ti) {
   jvmtiStackInfo *infop = &amp;stack_info[ti];
   jthread thread = infop-&gt;thread;
   jint state = infop-&gt;state;
   jvmtiFrameInfo *frames = infop-&gt;frame_buffer;
   int fi;

   myThreadAndStatePrinter(thread, state);
   for (fi = 0; fi &lt; infop-&gt;frame_count; fi++) {
      myFramePrinter(frames[fi].method, frames[fi].location);
   }
}
/* this one Deallocate call frees all data allocated by GetAllStackTraces */
err = (*jvmti)-&gt;Deallocate(jvmti, stack_info); 
        </pre>
</blockquote>
        

      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>100</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetAllStackTraces.max_frame_count">max_frame_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    スレッドごとに取得する<a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>レコードの最大数。
	  </td>
</tr>
<tr>
<td><code id="GetAllStackTraces.stack_info_ptr">stack_info_ptr</code></td><td><code> <a href="#jvmtiStackInfo">jvmtiStackInfo</a> **</code></td><td>
	      戻ったときに、このバッファに各スレッドのスタック情報が入っている。<a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a>のレコード数は、<a href="#GetAllStackTraces.thread_count_ptr"><code>thread_count_ptr</code></a>で決定される。
              <p></p>
              このバッファは、<a href="#jvmtiStackInfo.frame_buffer"><code>jvmtiStackInfo.frame_buffer</code></a>でポイントされた<a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>バッファを含むように割り当てられている。これらのバッファは、別々に解放してはならない。
	    <p></p>エージェントは<code>jvmtiStackInfo*</code>へのポインタを渡す。戻り時に、<code>jvmtiStackInfo*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiStackInfo</code>のフィールド<code>thread</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
<tr>
<td><code id="GetAllStackTraces.thread_count_ptr">thread_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    トレースされたスレッドの数。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetAllStackTraces.max_frame_count"><code>max_frame_count</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetAllStackTraces.stack_info_ptr"><code>stack_info_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetAllStackTraces.thread_count_ptr"><code>thread_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetThreadListStackTraces">
<h3>スレッド・リストのスタック・トレースの取得</h3>
<blockquote>
<pre>jvmtiError
GetThreadListStackTraces(jvmtiEnv* env,
            jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr)</pre>
</blockquote>
        指定されたスレッドのスタックに関する情報を取得します。<a href="#GetThreadListStackTraces.max_frame_count"><code>max_frame_count</code></a>がスタックの深さより小さい場合、そのスレッドについて<a href="#GetThreadListStackTraces.max_frame_count"><code>max_frame_count</code></a>のいちばん上のフレームが返され、それ以外の場合はスタック全体が返されます。最後に呼び出されたフレームである最上位フレームが、返されるバッファの先頭になります。
        <p></p>
        すべてのスタックは、同時に収集されます。つまり、あるスレッドのサンプリングと次のスレッドのサンプリングとの間には、スレッドの状態またはスタックに変更は発生しません。スレッドを中断する必要はありません。
        <p></p>
        スレッドがまだ起動されていないか、スタック情報が収集される前にスレッドが終了した場合は、長さ0のスタック(<a href="#jvmtiStackInfo.frame_count"><code>jvmtiStackInfo.frame_count</code></a>が0)が返されるため、スレッド<a href="#jvmtiStackInfo.state"><code>jvmtiStackInfo.state</code></a>をチェックできます。
        <p></p>
        例は、同様な関数<a href="#GetAllStackTraces"><code>GetAllStackTraces</code></a>を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>101</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.thread_count">thread_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    トレースするスレッドの数。
	  </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.thread_list">thread_list</code></td><td><code>const <a href="#jthread">jthread</a>*</code></td><td>
	      トレースするスレッドのリスト。
	    <p></p>エージェントは<code>jthread</code>の<code>thread_count</code>要素の配列を渡す。 </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.max_frame_count">max_frame_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    スレッドごとに取得する<a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>レコードの最大数。
	  </td>
</tr>
<tr>
<td><code id="GetThreadListStackTraces.stack_info_ptr">stack_info_ptr</code></td><td><code> <a href="#jvmtiStackInfo">jvmtiStackInfo</a> **</code></td><td>
	      戻ったときに、このバッファに各スレッドのスタック情報が入っている。<a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a>のレコード数は、<a href="#GetThreadListStackTraces.thread_count"><code>thread_count</code></a>で決定される。
              <p></p>
              このバッファは、<a href="#jvmtiStackInfo.frame_buffer"><code>jvmtiStackInfo.frame_buffer</code></a>でポイントされた<a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a>バッファを含むように割り当てられている。これらのバッファは、別々に解放してはならない。
	    <p></p>エージェントは<code>jvmtiStackInfo*</code>へのポインタを渡す。戻ったとき、<code>jvmtiStackInfo*</code>は、サイズ<code>*thread_count</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiStackInfo</code>のフィールド<code>thread</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  スレッド・オブジェクトでない要素が<a href="#GetThreadListStackTraces.thread_list"><code>thread_list</code></a>内に存在する。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetThreadListStackTraces.thread_count"><code>thread_count</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadListStackTraces.thread_list"><code>thread_list</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetThreadListStackTraces.max_frame_count"><code>max_frame_count</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadListStackTraces.stack_info_ptr"><code>stack_info_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetFrameCount">
<h3>フレーム・カウントの取得</h3>
<blockquote>
<pre>jvmtiError
GetFrameCount(jvmtiEnv* env,
            jthread thread,
            jint* count_ptr)</pre>
</blockquote>
	指定されたスレッドの呼出しスタックに現在入っているフレームの数を取得します。
	<p></p>
	アクティブにバイト・コードを実行しているスレッド(現在のスレッドではなく、中断されていないスレッドなど)のためにこの関数が呼び出された場合、一時的な情報が返されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>16</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetFrameCount.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      照会するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetFrameCount.count_ptr">count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、呼出しスタック内のフレームの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetFrameCount.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetFrameCount.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetFrameCount.count_ptr"><code>count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="PopFrame">
<h3>フレームのポップ</h3>
<blockquote>
<pre>jvmtiError
PopFrame(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
	<code>thread</code>スタックの現在のフレームをポップします。フレームをポップすると、直前のフレームに戻ります。スレッドが再開されると、スレッドの実行状態は、メソッドが呼び出される直前の状態にリセットされます。<cite>Java(tm)仮想マシン仕様</cite>の用語で説明すると、次のようになります。
	  <ul type="disc">
	    
<li>現在のフレームが破棄され、以前のフレームが現在のフレームになる</li>
	    
<li>オペランド・スタックは回復します。引数が再度追加され、呼出しが<code>invokestatic</code>ではなかった場合、<code>objectref</code>も再度追加されます。</li>
	    
<li>Java仮想マシンのPCが呼出し命令の操作コード(opcode)へ回復する</li>
	  
</ul>
	ただし、呼出し先のメソッドで発生した引数の変更内容は保持されます。実行を続行すると、最初の実行指示が呼び出しとなります。  
	<p></p>
	<code>PopFrame</code>の呼び出しとスレッドの再開の間、スタックの状態は未定義です。最初のフレームよりも前にフレームをポップするには、次の3つの手順を繰り返す必要があります。
	<ul type="disc">
	  
<li>イベントを通じてスレッドを中断する(ステップ、ブレークポイントなど)</li>
	  
<li><code>PopFrame</code>を呼び出す
</li>
	  
<li>スレッドを再開する</li>
	
</ul>
	
<p></p>
	被呼出しメソッドを呼び出すことによって獲得されたロック(これが<code>synchronized</code>メソッドの場合)と、被呼出しメソッド内の<code>synchronized</code>ブロックに入ることによって獲得されたロックは解放されます。注: これは、ネイティブ・ロックや<code>java.util.concurrent.locks</code>ロックには適用されません。
	<p></p>
	最終的に、ブロックは実行されません。
	<p></p>
	グローバル状態への変更には対応しないので、変更は行われません。
	<p></p>
	指定されたスレッドは中断されていなければいけません。これは、そのスレッドが現在のスレッドであってはいけないことを意味します。
	<p></p>
	被呼出しメソッドと呼出し側のメソッドのどちらも、非ネイティブのJavaプログラミング言語のメソッドとします。
	<p></p>
	この関数は、JVM<small style="font-size: xx-small">&nbsp;</small>TIイベントを生成しません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>80</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_pop_frame"><code>can_pop_frame</code></a></td><td>
	  スタックからフレームをポップできる - <a href="#PopFrame"><code>PopFrame</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="PopFrame.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      ポップする現在のフレームのスレッド。
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_pop_frame"><code>can_pop_frame</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  呼出し先メソッドまたは呼出し側メソッドがネイティブ・メソッドである。実装がこのフレームをポップできない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドは中断されていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  呼出しスタック上のスタック・フレームの数が、2個より少ない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#PopFrame.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#PopFrame.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetFrameLocation">
<h3>フレームの位置の取得</h3>
<blockquote>
<pre>jvmtiError
GetFrameLocation(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr)</pre>
</blockquote>
	
<p></p>
	Javaプログラミング言語のフレームについて、現在実行中の命令の位置を返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>19</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetFrameLocation.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    照会するフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetFrameLocation.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    照会するフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="GetFrameLocation.method_ptr">method_ptr</code></td><td><code><a href="#jmethodID">jmethodID</a>*</code></td><td>
	      戻ったとき、現在の位置のメソッドをポイントする。
	    <p></p>エージェントは<code>jmethodID</code>へのポインタを渡す。戻ったとき、<code>jmethodID</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetFrameLocation.location_ptr">location_ptr</code></td><td><code><a href="#jlocation">jlocation</a>*</code></td><td>
	    戻ったとき、現在実行中の命令のインデックスをポイントする。フレームがネイティブ・メソッドを実行している場合は<code>-1</code>に設定される。
	  <p></p>エージェントは<code>jlocation</code>へのポインタを渡す。戻ったとき、<code>jlocation</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetFrameLocation.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetFrameLocation.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetFrameLocation.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#GetFrameLocation.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetFrameLocation.method_ptr"><code>method_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetFrameLocation.location_ptr"><code>location_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="NotifyFramePop">
<h3>フレームのポップの通知</h3>
<blockquote>
<pre>jvmtiError
NotifyFramePop(jvmtiEnv* env,
            jthread thread,
            jint depth)</pre>
</blockquote>
	深さ<a href="#NotifyFramePop.depth"><code>depth</code></a>のフレームがスタックからポップされたとき、<a href="#FramePop"><code>FramePop</code></a>イベントを生成します。詳細は、<a href="#FramePop"><code>FramePop</code></a>イベントの説明を参照してください。非ネイティブJavaプログラミング言語のメソッドに対応するフレームだけが通知を受信できます。
        <p></p>
        指定したスレッドは現在のスレッドであるか、スレッドが中断したかのどちらかです。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>20</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a></td><td>
	  <a href="#FramePop"><code>FramePop</code></a>イベントを<a href="#NotifyFramePop">設定</a>し、取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="NotifyFramePop.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    フレームのポップ・イベントが生成されるフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="NotifyFramePop.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    フレームのポップ・イベントが生成されるフレームの深さ。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td> 
	  <code>depth</code>のフレームはネイティブ・メソッドを実行している。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドは中断されず、現在のスレッドではなかった。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#NotifyFramePop.thread"><code>thread</code></a>はスレッド・オブジェクトではない。	  
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#NotifyFramePop.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。	  
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#NotifyFramePop.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#NotifyFramePop.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
</table>
<p id="ForceEarlyReturn"></p>
<hr noshade size="3">
<h2 align="center">早期復帰の強制</h2>早期復帰の強制の関数:
  <ul>
<li>
<a href="#ForceEarlyReturnObject">早期復帰の強制 - オブジェクト型</a>
</li>
<li>
<a href="#ForceEarlyReturnInt">早期復帰の強制 - 整数型</a>
</li>
<li>
<a href="#ForceEarlyReturnLong">早期復帰の強制 - 長整数型</a>
</li>
<li>
<a href="#ForceEarlyReturnFloat">早期復帰の強制 - 浮動小数点数型</a>
</li>
<li>
<a href="#ForceEarlyReturnDouble">早期復帰の強制 - 倍精度浮動小数点数型</a>
</li>
<li>
<a href="#ForceEarlyReturnVoid">早期復帰の強制 - void型</a>
</li>
</ul>
      これらの関数を使うと、エージェントは、実行中の任意のポイントでの復帰をメソッドに強制できます。早期復帰するメソッドを<i>被呼出しメソッド</i>と呼びます。被呼出しメソッドは、<cite>Java(tm)仮想マシン仕様のセクション3.6</cite>に定義されているとおり、関数の呼出し時に、指定されたスレッドの現在のメソッドになります。
      <p></p>
      指定されたスレッドは、中断されているか、現在のスレッドでなければいけません。メソッドの復帰は、Javaプログラミング言語のコードの実行がこのスレッド上で再開されたときに行われます。これらの関数のいずれかを呼び出してからスレッドの実行が再開されるまでの間のスタックの状態は未定義です。  
      <p></p>
      被呼出しメソッドでは、これ以上の命令は実行されません。特に、最終的にブロックは実行されません。注: これにより、アプリケーション内で整合性のない状態が発生することがあります。
      <p></p>
      被呼出しメソッドを呼び出すことによって獲得されたロック(これが<code>synchronized</code>メソッドの場合)と、被呼出しメソッド内の<code>synchronized</code>ブロックに入ることによって獲得されたロックは解放されます。注: これは、ネイティブ・ロックや<code>java.util.concurrent.locks</code>ロックには適用されません。
      <p></p>
      通常復帰の場合と同様に、<a href="#MethodExit"><code>MethodExit</code></a>などのイベントが生成されます。
      <p></p>
      被呼出しメソッドは、非ネイティブのJavaプログラミング言語のメソッドとします。スタック上にフレームが1つだけある状態でスレッドへの強制復帰を行なった場合、スレッドが再開時に終了します。
    <p></p>
<hr noshade width="100%" size="1" id="ForceEarlyReturnObject">
<h3>早期復帰の強制 - オブジェクト型</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnObject(jvmtiEnv* env,
            jthread thread,
            jobject value)</pre>
</blockquote>
	この関数を使うと、結果の型が<code>Object</code>または<code>Object</code>のサブクラスであるメソッドから復帰できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>81</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a></td><td>
	  <a href="#ForceEarlyReturn">早期復帰の強制のカテゴリ</a>で説明しているように、メソッドから早期復帰できます。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnObject.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    現在のフレームが早期復帰するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnObject.value">value</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    被呼出しフレームの戻り値。オブジェクトまたは<code>NULL</code>。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  ネイティブ・メソッドに対応するフレームからの早期復帰が試みられた。または、実装がこのフレーム上でこの機能を提供できない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  被呼出しメソッドの結果の型が、<code>Object</code>でも、<code>Object</code>のサブクラスでもない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  指定された<a href="#ForceEarlyReturnObject.value"><code>value</code></a>と、被呼出しメソッドの結果の型に互換性がない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドが現在のスレッドではなく、中断されていなかった。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  呼出しスタックにこれ以上のフレームがない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#ForceEarlyReturnObject.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#ForceEarlyReturnObject.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#ForceEarlyReturnObject.value"><code>value</code></a>がオブジェクトではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ForceEarlyReturnInt">
<h3>早期復帰の強制 - 整数型</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnInt(jvmtiEnv* env,
            jthread thread,
            jint value)</pre>
</blockquote>
	この関数を使うと、結果の型が<code>int</code>、<code>short</code>、<code>char</code>、<code>byte</code>、<code>boolean</code>のいずれかであるメソッドから復帰できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>82</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a></td><td>
	  <a href="#ForceEarlyReturn">早期復帰の強制のカテゴリ</a>で説明しているように、メソッドから早期復帰できます。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnInt.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    現在のフレームが早期復帰するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnInt.value">value</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    被呼出しフレームの戻り値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  ネイティブ・メソッドに対応するフレームからの早期復帰が試みられた。または、実装がこのフレーム上でこの機能を提供できない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  被呼出しメソッドの結果の型が<code>int</code>、<code>short</code>、<code>char</code>、<code>byte</code>、<code>boolean</code>のいずれでもない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドが現在のスレッドではなく、中断されていなかった。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  呼出しスタックにフレームがない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#ForceEarlyReturnInt.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#ForceEarlyReturnInt.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ForceEarlyReturnLong">
<h3>早期復帰の強制 - 長整数型</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnLong(jvmtiEnv* env,
            jthread thread,
            jlong value)</pre>
</blockquote>
	この関数を使うと、結果の型が<code>long</code>であるメソッドから復帰できます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>83</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a></td><td>
	  <a href="#ForceEarlyReturn">早期復帰の強制のカテゴリ</a>で説明しているように、メソッドから早期復帰できます。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnLong.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    現在のフレームが早期復帰するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnLong.value">value</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    被呼出しフレームの戻り値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  ネイティブ・メソッドに対応するフレームからの早期復帰が試みられた。または、実装がこのフレーム上でこの機能を提供できない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  被呼出しメソッドの結果の型が<code>long</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドが現在のスレッドではなく、中断されていなかった。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  呼出しスタックにフレームがない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#ForceEarlyReturnLong.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#ForceEarlyReturnLong.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ForceEarlyReturnFloat">
<h3>早期復帰の強制 - 浮動小数点数型</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnFloat(jvmtiEnv* env,
            jthread thread,
            jfloat value)</pre>
</blockquote>
	この関数を使うと、結果の型が<code>float</code>であるメソッドから復帰できます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>84</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a></td><td>
	  <a href="#ForceEarlyReturn">早期復帰の強制のカテゴリ</a>で説明しているように、メソッドから早期復帰できます。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnFloat.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    現在のフレームが早期復帰するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnFloat.value">value</code></td><td><code><a href="#jfloat">jfloat</a></code></td><td>
	    被呼出しフレームの戻り値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  ネイティブ・メソッドに対応するフレームからの早期復帰が試みられた。または、実装がこのフレーム上でこの機能を提供できない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  被呼出しメソッドの結果の型が<code>float</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドが現在のスレッドではなく、中断されていなかった。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  呼出しスタックにフレームがない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#ForceEarlyReturnFloat.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#ForceEarlyReturnFloat.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ForceEarlyReturnDouble">
<h3>早期復帰の強制 - 倍精度浮動小数点数型</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnDouble(jvmtiEnv* env,
            jthread thread,
            jdouble value)</pre>
</blockquote>
	この関数を使うと、結果の型が<code>double</code>であるメソッドから復帰できます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>85</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a></td><td>
	  <a href="#ForceEarlyReturn">早期復帰の強制のカテゴリ</a>で説明しているように、メソッドから早期復帰できます。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnDouble.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    現在のフレームが早期復帰するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnDouble.value">value</code></td><td><code><a href="#jdouble">jdouble</a></code></td><td>
	    被呼出しフレームの戻り値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  ネイティブ・メソッドに対応するフレームからの早期復帰が試みられた。または、実装がこのフレーム上でこの機能を提供できない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  被呼出しメソッドの結果の型が<code>double</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドが現在のスレッドではなく、中断されていなかった。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  呼出しスタックにフレームがない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#ForceEarlyReturnDouble.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#ForceEarlyReturnDouble.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ForceEarlyReturnVoid">
<h3>早期復帰の強制 - void型</h3>
<blockquote>
<pre>jvmtiError
ForceEarlyReturnVoid(jvmtiEnv* env,
            jthread thread)</pre>
</blockquote>
	この関数を使うと、結果の型を持たないメソッドから復帰できます。つまり、被呼出しメソッドが<code>void</code>と宣言されていなければいけません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>86</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a></td><td>
	  <a href="#ForceEarlyReturn">早期復帰の強制のカテゴリ</a>で説明しているように、メソッドから早期復帰できます。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ForceEarlyReturnVoid.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    現在のフレームが早期復帰するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_force_early_return"><code>can_force_early_return</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  ネイティブ・メソッドに対応するフレームからの早期復帰が試みられた。または、実装がこのフレーム上でこの機能を提供できない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  被呼出しメソッドが結果の型を持っている。  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_SUSPENDED"><code>JVMTI_ERROR_THREAD_NOT_SUSPENDED</code></a></td><td>
	  スレッドが現在のスレッドではなく、中断されていなかった。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  呼出しスタックにフレームがない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#ForceEarlyReturnVoid.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#ForceEarlyReturnVoid.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
</table>
<p id="Heap"></p>
<hr noshade size="3">
<h2 align="center">ヒープ</h2>ヒープ関数:
  <ul>
<li>
<a href="#FollowReferences">参照の追跡</a>
</li>
<li>
<a href="#IterateThroughHeap">ヒープ内での反復</a>
</li>
<li>
<a href="#GetTag">タグの取得</a>
</li>
<li>
<a href="#SetTag">タグの設定</a>
</li>
<li>
<a href="#GetObjectsWithTags">タグを使ったオブジェクトの取得</a>
</li>
<li>
<a href="#ForceGarbageCollection">ガベージ・コレクションの強制</a>
</li>
</ul>ヒープの関数型:
    <ul>
<li>
<a href="#jvmtiHeapIterationCallback">ヒープ反復コールバック</a>
</li>
<li>
<a href="#jvmtiHeapReferenceCallback">ヒープ参照コールバック</a>
</li>
<li>
<a href="#jvmtiPrimitiveFieldCallback">プリミティブ・フィールド・コールバック</a>
</li>
<li>
<a href="#jvmtiArrayPrimitiveValueCallback">配列プリミティブ値コールバック</a>
</li>
<li>
<a href="#jvmtiStringPrimitiveValueCallback">文字列プリミティブ値コールバック</a>
</li>
<li>
<a href="#jvmtiReservedCallback">将来使用するために予約されたコールバック</a>
</li>
</ul>ヒープの型:
    <ul>
<li>
<a href="#jvmtiHeapReferenceKind"><code>jvmtiHeapReferenceKind</code></a> - ヒープ参照の列挙</li>
<li>
<a href="#jvmtiPrimitiveType"><code>jvmtiPrimitiveType</code></a> - プリミティブ型の列挙</li>
<li>
<a href="#jvmtiHeapReferenceInfoField"><code>jvmtiHeapReferenceInfoField</code></a> - フィールド参照用の参照情報構造体</li>
<li>
<a href="#jvmtiHeapReferenceInfoArray"><code>jvmtiHeapReferenceInfoArray</code></a> - 配列参照用の参照情報構造体</li>
<li>
<a href="#jvmtiHeapReferenceInfoConstantPool"><code>jvmtiHeapReferenceInfoConstantPool</code></a> - 定数プール参照用の参照情報構造体</li>
<li>
<a href="#jvmtiHeapReferenceInfoStackLocal"><code>jvmtiHeapReferenceInfoStackLocal</code></a> - 局所変数参照用の参照情報構造体</li>
<li>
<a href="#jvmtiHeapReferenceInfoJniLocal"><code>jvmtiHeapReferenceInfoJniLocal</code></a> - JNIローカル参照用の参照情報構造体</li>
<li>
<a href="#jvmtiHeapReferenceInfoReserved"><code>jvmtiHeapReferenceInfoReserved</code></a> - その他の参照用の参照情報構造体</li>
<li>
<a href="#jvmtiHeapReferenceInfo"><code>jvmtiHeapReferenceInfo</code></a> - 参照情報構造体</li>
<li>
<a href="#jvmtiHeapCallbacks"><code>jvmtiHeapCallbacks</code></a> - ヒープ・コールバック関数構造体</li>
</ul>ヒープのフラグおよび定数:
    <ul>
<li>
<a href="#jvmtiHeapFilter">ヒープ・フィルタ・フラグ</a>
</li>
<li>
<a href="#jvmtiHeapVisitControl">ヒープ・ビジット制御フラグ</a>
</li>
</ul>
      これらの関数は、ヒープの分析に使用されます。ヒープ内のオブジェクトの表示、これらのオブジェクトへのタグ付けなどの機能があります。
    <h4 id="objectTags">オブジェクトのタグ</h4>
      <i>タグ</i>は、オブジェクトに関連付けられる値です。タグは、エージェントにより、<a href="#SetTag"><code>SetTag</code></a>関数を使用して明示的に設定されます。または、<a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a>などのコールバック関数によって設定されます。    
      <p></p>
      タグは環境に対してローカルです。つまり、ある環境のタグを別の環境で表示することはできません。
      <p></p>
      <code>jlong</code>値であるタグを使えば、オブジェクトを単純にマークしたり、詳細情報へのポインタを格納したりできます。タグ付けされていないオブジェクトのタグはゼロになります。タグをゼロに設定すると、オブジェクトのタグ付けが解除されます。
    <h4 id="heapCallbacks">ヒープ・コールバック関数</h4>
        ヒープ関数は、ヒープ内での反復処理とオブジェクト参照の再帰的な追跡を行い、エージェントが指定したコールバック関数を使って情報提供を行います。
        <p></p>
        これらのヒープ・コールバック関数は次の制限に準拠する必要があります。これらのコールバックはJNI関数を使用してはいけません。これらのコールバックは、<i>コールバック安全</i>な関数(そのような使用を明確に許可している関数)以外のJVM<small style="font-size: xx-small">&nbsp;</small>TI関数を使用してはいけません(rawモニター関数、メモリー管理関数、環境ローカル・ストレージ関数を参照)。
        <p></p>
        実装は、内部スレッド上または反復関数を呼び出したスレッド上で、コールバックを呼び出せます。ヒープ・コールバックはシングル・スレッドです。一度に呼び出されるコールバックの数は最大1個になります。
        <p></p>
        ヒープ・フィルタ・フラグを使うと、オブジェクトまたはそのクラスのタグの状態に基づいて報告を行わないようにすることができます。フラグが設定されていない場合(<code>jint</code>がゼロの場合)、オブジェクトのフィルタ・リングは行われません。

        <blockquote>
<a name="jvmtiHeapFilter"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">ヒープ・フィルタ・フラグ</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_TAGGED">JVMTI_HEAP_FILTER_TAGGED</code></td><td align="right">0x4</td><td>
	    タグ付きのオブジェクトをフィルタ・リングする。タグの付いたオブジェクトが除外される。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_UNTAGGED">JVMTI_HEAP_FILTER_UNTAGGED</code></td><td align="right">0x8</td><td>
	    タグなしのオブジェクトをフィルタ・リングする。タグの付いていないオブジェクトが除外される。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_CLASS_TAGGED">JVMTI_HEAP_FILTER_CLASS_TAGGED</code></td><td align="right">0x10</td><td>
	    タグ付きのクラスを持つオブジェクトをフィルタ・リングする。タグの付いたクラスのオブジェクトが除外される。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_FILTER_CLASS_UNTAGGED">JVMTI_HEAP_FILTER_CLASS_UNTAGGED</code></td><td align="right">0x20</td><td>
	    タグなしのクラスを持つオブジェクトをフィルタ・リングする。タグの付いていないクラスのオブジェクトが除外される。
	  </td>
</tr>
</table>
</blockquote>

        
<p></p>
        ヒープ・コールバックによって返されるヒープ・ビジット制御フラグを使うと、反復処理を中止できます。また、<a href="#jvmtiHeapReferenceCallback">ヒープ参照コールバック</a>は、トラバース対象となる参照のグラフを取り除くために使うこともできます(<code>JVMTI_VISIT_OBJECTS</code>を設定しない)。

        <blockquote>
<a name="jvmtiHeapVisitControl"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">ヒープ・ビジット制御フラグ</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_VISIT_OBJECTS">JVMTI_VISIT_OBJECTS</code></td><td align="right">0x100</td><td>
            あるオブジェクトをビジットする際にこのコールバックが<a href="#FollowReferences"><code>FollowReferences</code></a>によって起動されたものであった場合、そのオブジェクトの参照をトラバースする。それ以外の場合は無視される。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VISIT_ABORT">JVMTI_VISIT_ABORT</code></td><td align="right">0x8000</td><td>
	    反復処理を中止。ほかのすべてのビットを無視する。
	  </td>
</tr>
</table>
</blockquote>

        
<p></p>
        ヒープ参照の列挙は、報告対象の参照の種類を記述する目的で、<a href="#jvmtiHeapReferenceCallback">ヒープ参照コールバック</a>と<a href="#jvmtiPrimitiveFieldCallback">プリミティブ・フィールド・コールバック</a>によって提供されます。

        <blockquote>
<a name="jvmtiHeapReferenceKind"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">ヒープ参照の列挙(<code>jvmtiHeapReferenceKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_CLASS">JVMTI_HEAP_REFERENCE_CLASS</code></td><td align="right">1</td><td>
	    オブジェクトからそのクラスへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_FIELD">JVMTI_HEAP_REFERENCE_FIELD</code></td><td align="right">2</td><td>
	    オブジェクトから、そのオブジェクトのいずれかのインスタンス・フィールド値への参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT">JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></td><td align="right">3</td><td>
	    配列から、その配列のいずれかの要素への参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_CLASS_LOADER">JVMTI_HEAP_REFERENCE_CLASS_LOADER</code></td><td align="right">4</td><td>
	    クラスからそのクラス・ローダーへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_SIGNERS">JVMTI_HEAP_REFERENCE_SIGNERS</code></td><td align="right">5</td><td>
	    クラスからその署名者の配列への参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN">JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN</code></td><td align="right">6</td><td>
	    クラスからその保護ドメインへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_INTERFACE">JVMTI_HEAP_REFERENCE_INTERFACE</code></td><td align="right">7</td><td>
            クラスから、そのクラスのいずれかのインタフェースへの参照。注: インタフェースは定数プール参照経由で定義されるため、参照されたインタフェースは参照の種類が<code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code>で報告される可能性もある。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_STATIC_FIELD">JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></td><td align="right">8</td><td>
	    クラスからそのいずれかのstaticフィールド値への参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_CONSTANT_POOL">JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></td><td align="right">9</td><td>
	    クラスから定数プール内の解決済みエントリへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_SUPERCLASS">JVMTI_HEAP_REFERENCE_SUPERCLASS</code></td><td align="right">10</td><td>
            クラスからそのスーパー・クラスへの参照。スーパー・クラスが<code>java.lang.Object</code>の場合、コールバックは送信されない。注: ロードされたクラスは定数プール参照経由でスーパー・クラスを定義するため、参照されたスーパー・クラスは参照の種類が<code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code>で報告される可能性もある。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_JNI_GLOBAL">JVMTI_HEAP_REFERENCE_JNI_GLOBAL</code></td><td align="right">21</td><td>
	    ヒープ・ルート参照: JNIグローバル参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_SYSTEM_CLASS">JVMTI_HEAP_REFERENCE_SYSTEM_CLASS</code></td><td align="right">22</td><td>
	    ヒープ・ルート参照: システム・クラス。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_MONITOR">JVMTI_HEAP_REFERENCE_MONITOR</code></td><td align="right">23</td><td>
	    ヒープ・ルート参照: モニター。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_STACK_LOCAL">JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></td><td align="right">24</td><td>
	    ヒープ・ルート参照: スタック上の局所変数。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_JNI_LOCAL">JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></td><td align="right">25</td><td>
	    ヒープ・ルート参照: JNIローカル参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_THREAD">JVMTI_HEAP_REFERENCE_THREAD</code></td><td align="right">26</td><td>
	    ヒープ・ルート参照: スレッド。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_REFERENCE_OTHER">JVMTI_HEAP_REFERENCE_OTHER</code></td><td align="right">27</td><td>
	    ヒープ・ルート参照: ほかのヒープ・ルート参照。
	  </td>
</tr>
</table>
</blockquote>

        
<p></p>
        プリミティブ型の単一文字型記述子の定義。

        <blockquote>
<a name="jvmtiPrimitiveType"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">プリミティブ型の列挙(<code>jvmtiPrimitiveType</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_BOOLEAN">JVMTI_PRIMITIVE_TYPE_BOOLEAN</code></td><td align="right">90</td><td>
            「Z」- Javaプログラミング言語の<code>boolean</code> - JNIの<code>jboolean</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_BYTE">JVMTI_PRIMITIVE_TYPE_BYTE</code></td><td align="right">66</td><td>
            「B」- Javaプログラミング言語の<code>byte</code> - JNIの<code>jbyte</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_CHAR">JVMTI_PRIMITIVE_TYPE_CHAR</code></td><td align="right">67</td><td>
            「C」- Javaプログラミング言語の<code>char</code> - JNIの<code>jchar</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_SHORT">JVMTI_PRIMITIVE_TYPE_SHORT</code></td><td align="right">83</td><td>
            「S」- Javaプログラミング言語の<code>short</code> - JNIの<code>jshort</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_INT">JVMTI_PRIMITIVE_TYPE_INT</code></td><td align="right">73</td><td>
            「I」- Javaプログラミング言語の<code>int</code> - JNIの<code>jint</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_LONG">JVMTI_PRIMITIVE_TYPE_LONG</code></td><td align="right">74</td><td>
            「J」- Javaプログラミング言語の<code>long</code> - JNIの<code>jlong</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_FLOAT">JVMTI_PRIMITIVE_TYPE_FLOAT</code></td><td align="right">70</td><td>
            「F」- Javaプログラミング言語の<code>float</code> - JNIの<code>jfloat</code>
	  </td>
</tr>
<tr>
<td><code id="JVMTI_PRIMITIVE_TYPE_DOUBLE">JVMTI_PRIMITIVE_TYPE_DOUBLE</code></td><td align="right">68</td><td>
            「D」- Javaプログラミング言語の<code>double</code> - JNIの<code>jdouble</code>
	  </td>
</tr>
</table>
</blockquote>
    
<h4 id="jvmtiHeapReferenceInfoField">フィールド参照用の参照情報構造体</h4>
          <a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>および<a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>参照に対して返される参照情報。
        <p></p>
<blockquote>
<pre>typedef struct {
    jint index;
} jvmtiHeapReferenceInfoField;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoField</code> - フィールド参照用の参照情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoField.index">index</code></td><td><code><a href="#jint">jint</a></code></td><td>	    
            <a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>の場合、参照側オブジェクトはクラスでもインタフェースでもありません。この場合、<code>index</code>は、参照側オブジェクトのクラスに含まれるフィールドのインデックスです。以降、このクラスを<i>C</i>と呼びます。
            <p></p>
            <a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>の場合、参照側オブジェクトは、クラス(以降<i>C</i>と呼ぶ)とインタフェース(以降<i>I</i>と呼ぶ)のいずれかになります。この場合、<code>index</code>は、そのクラスまたはインタフェースに含まれるフィールドのインデックスです。
            <p></p>
            参照側オブジェクトがインタフェースでない場合、フィールドのインデックスは次のようにして決定されます。 
            <ul type="disc">
              
<li><i>C</i>とそのスーパー・クラスに含まれるすべてのフィールドのリストが作成されます。このリストは、<code>java.lang.Object</code>内のすべてのフィールドで始まり、<i>C</i>内のすべてのフィールドで終わります。</li>
              
<li>このリスト内で、指定されたクラスのフィールドが<a href="#GetClassFields"><code>GetClassFields</code></a>から返された順番に並べられます。</li>
              
<li>このリスト内のフィールドに、インデックス<i>n</i>、<i>n</i>+1、... が順に割り当てられます。<i>n</i>は、<i>C</i>によって実装されたすべてのインタフェースに含まれるフィールドのカウント数です。<i>C</i>は、そのスーパークラスが直接実装しているすべてのインタフェースと、それらのインタフェースのすべてのスーパーインタフェースを実装しています。</li>
            
</ul>
            参照側オブジェクトがインタフェースである場合、フィールドのインデックスは次のようにして決定されます。
            <ul type="disc">
              
<li><i>I</i>内で直接宣言されているフィールドのリストが作成されます。</li>
              
<li>このリスト内のフィールドが<a href="#GetClassFields"><code>GetClassFields</code></a>から返された順番に並べられます。</li>
              
<li>このリスト内のフィールドに、インデックス<i>n</i>、<i>n</i>+1、... が順に割り当てられます。<i>n</i>は、<i>I</i>のすべてのスーパー・インタフェースに含まれるフィールドのカウント数です。</li>
            
</ul>
            この計算には、フィールド修飾子(static、public、privateなど)の種類にかかわらず、すべてのフィールドが含まれます。
            <p></p>
            たとえば、次のようなクラスとインタフェースが指定されているとします。
            <blockquote>
<pre>
interface I0 {
    int p = 0;
}

interface I1 extends I0 {
    int x = 1;
}

interface I2 extends I0 {
    int y = 2;
}

class C1 implements I1 {
    public static int a = 3;
    private int b = 4;
}

class C2 extends C1 implements I2 {
    static int q = 5;
    final int r = 6;
}
            </pre>
</blockquote>
            <code>C1</code>で呼び出された<a href="#GetClassFields"><code>GetClassFields</code></a>から、<code>C1</code>のフィールドa、bがこの順番で返され、<code>C2</code>のフィールドq、rがこの順番で返されるものとします。クラス<code>C1</code>のインスタンスのフィールド・インデックスは、次のようになります。
            <dl>
<dd>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
              
<tr>
                
<td align="center">
                  a
                </td>
                <td align="center">
                  2
                </td>
                <td align="left">
                  <code>C1</code>が実装するインタフェース内のフィールドのカウント数は2 (<i>n</i>=2)です。つまり、<code>I0</code>の<code>p</code>と<code>I1</code>の<code>x</code>です。
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  b
                </td>
                <td align="center">
                  3
                </td>
                <td align="left">
                  後続のインデックス。
                </td>
              
</tr>
            
</table>
</dd>
</dl>
            クラス<code>C1</code>も同じフィールド・インデックスを持ちます。
            <p></p>
            クラス<code>C2</code>のインスタンスのフィールド・インデックスは、次のようになります。
            <dl>
<dd>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
              
<tr>
                
<td align="center">
                  a
                </td>
                <td align="center">
                  3
                </td>
                <td align="left">
                  <code>C2</code>が実装するインタフェース内のフィールドのカウント数は3 (<i>n</i>=3)です。つまり、<code>I0</code>の<code>p</code>、<code>I1</code>の<code>x</code>、<code>I2</code>の<code>y</code> (<code>C2</code>のインタフェース)です。<code>I0</code>のフィールド<code>p</code>が含まれるのは、一度のみです。
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  b
                </td>
                <td align="center">
                  4
                </td>
                <td align="left">
                  「a」に続くインデックス。
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  q
                </td>
                <td align="center">
                  5
                </td>
                <td align="left">
                  「b」に続くインデックス。
                </td>
              
</tr>
              
<tr>
                
<td align="center">
                  r
                </td>
                <td align="center">
                  6
                </td>
                <td align="left">
                  「q」に続くインデックス。
                </td>
              
</tr>
            
</table>
</dd>
</dl>
            クラス<code>C2</code>も同じフィールド・インデックスを持ちます。上記のフィールド「a」のように、同じフィールドが、参照側オブジェクトごとに異なるインデックスを持つ可能性があります。また、コールバックからすべてのフィールド・インデックスが可視になるわけではありませんが、ここでは説明のためにすべてのインデックスを示しています。
            <p></p>
            インタフェース<code>I1</code>も同じフィールド・インデックスを持ちます。
            <dl>
<dd>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
              
<tr>
                
<td align="center">
                  x
                </td>
                <td align="center">
                  1
                </td>
                <td align="left">
                  <code>I1</code>のスーパー・インタフェース内のフィールドのカウント数は1 (<i>n</i>=1)です。つまり、<code>I0</code>の<code>p</code>です。
                </td>
              
</tr>
            
</table>
</dd>
</dl>
	  
</td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoArray">配列参照用の参照情報構造体</h4>
          <a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a>の参照に対して返される参照情報。
        <p></p>
<blockquote>
<pre>typedef struct {
    jint index;
} jvmtiHeapReferenceInfoArray;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoArray</code> - 配列参照用の参照情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoArray.index">index</code></td><td><code><a href="#jint">jint</a></code></td><td>	    
	    配列のインデックス。
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoConstantPool">定数プール参照用の参照情報構造体</h4>
          <a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a>の参照に対して返される参照情報。
        <p></p>
<blockquote>
<pre>typedef struct {
    jint index;
} jvmtiHeapReferenceInfoConstantPool;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoConstantPool</code> - 定数プール参照用の参照情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoConstantPool.index">index</code></td><td><code><a href="#jint">jint</a></code></td><td>	    
	    クラスの定数プール内のインデックス。<cite>Java(tm)仮想マシン仕様のセクション4.4</cite>を参照。
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoStackLocal">局所変数参照用の参照情報構造体</h4>
          <a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a>の参照に対して返される参照情報。
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
} jvmtiHeapReferenceInfoStackLocal;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoStackLocal</code> - 局所変数参照用の参照情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.thread_tag">thread_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    このスタックに対応するスレッドのタグ。タグ付けされていない場合はゼロ。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.thread_id">thread_id</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    このスタックに対応するスレッドの一意のスレッドID。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    フレームの深さ。 
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    このフレーム内で実行されているメソッド。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	    このフレーム内で現在実行されている位置。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoStackLocal.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    局所変数のスロット番号。
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoJniLocal">JNIローカル参照用の参照情報構造体</h4>
          <a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a>の参照に対して返される参照情報。
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
} jvmtiHeapReferenceInfoJniLocal;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoJniLocal</code> - JNIローカル参照用の参照情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.thread_tag">thread_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    このスタックに対応するスレッドのタグ。タグ付けされていない場合はゼロ。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.thread_id">thread_id</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    このスタックに対応するスレッドの一意のスレッドID。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    フレームの深さ。 
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoJniLocal.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    このフレーム内で実行されているメソッド。
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfoReserved">その他の参照用の参照情報構造体</h4>
          その他の参照に対して返される参照情報。
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
} jvmtiHeapReferenceInfoReserved;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfoReserved</code> - その他の参照用の参照情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved1">reserved1</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved2">reserved2</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved3">reserved3</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved4">reserved4</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved5">reserved5</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved6">reserved6</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved7">reserved7</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfoReserved.reserved8">reserved8</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapReferenceInfo">参照情報構造体</h4>
          参照側に関して返される情報。各種参照情報の共用体として表されます。
        <p></p>
<blockquote>
<pre>typedef union {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
} jvmtiHeapReferenceInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapReferenceInfo</code> - 参照情報構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.field">field</code></td><td><code><a href="#jvmtiHeapReferenceInfoField">jvmtiHeapReferenceInfoField</a></code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>および<a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>参照の参照側情報。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.array">array</code></td><td><code><a href="#jvmtiHeapReferenceInfoArray">jvmtiHeapReferenceInfoArray</a></code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a>参照の参照側情報。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.constant_pool">constant_pool</code></td><td><code><a href="#jvmtiHeapReferenceInfoConstantPool">jvmtiHeapReferenceInfoConstantPool</a></code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a>参照の参照側情報。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.stack_local">stack_local</code></td><td><code><a href="#jvmtiHeapReferenceInfoStackLocal">jvmtiHeapReferenceInfoStackLocal</a></code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a>参照の参照側情報。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.jni_local">jni_local</code></td><td><code><a href="#jvmtiHeapReferenceInfoJniLocal">jvmtiHeapReferenceInfoJniLocal</a></code></td><td>	    
	    <a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a>参照の参照側情報。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceInfo.other">other</code></td><td><code><a href="#jvmtiHeapReferenceInfoReserved">jvmtiHeapReferenceInfoReserved</a></code></td><td>	    
	    将来の使用のために予約済み。
	  </td>
</tr>
</table>
</blockquote>
<h4 id="jvmtiHeapCallbacks">ヒープ・コールバック関数構造体</h4>
<blockquote>
<pre>typedef struct {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
} jvmtiHeapCallbacks;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiHeapCallbacks</code> - ヒープ・コールバック関数構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.heap_iteration_callback">heap_iteration_callback</code></td><td><code> <a href="#jvmtiHeapIterationCallback">jvmtiHeapIterationCallback</a> </code></td><td>
	    ヒープ内のオブジェクトを記述するために呼び出されるコールバック。<a href="#IterateThroughHeap"><code>IterateThroughHeap</code></a>関数によって使用され、<a href="#FollowReferences"><code>FollowReferences</code></a>関数によって無視されます。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.heap_reference_callback">heap_reference_callback</code></td><td><code> <a href="#jvmtiHeapReferenceCallback">jvmtiHeapReferenceCallback</a> </code></td><td>
	    オブジェクト参照を記述するために呼び出されるコールバック。<a href="#FollowReferences"><code>FollowReferences</code></a>関数によって使用され、<a href="#IterateThroughHeap"><code>IterateThroughHeap</code></a>関数によって無視されます。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.primitive_field_callback">primitive_field_callback</code></td><td><code> <a href="#jvmtiPrimitiveFieldCallback">jvmtiPrimitiveFieldCallback</a> </code></td><td>
            プリミティブ・フィールドを記述するために呼び出されるコールバック。
          </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.array_primitive_value_callback">array_primitive_value_callback</code></td><td><code> <a href="#jvmtiArrayPrimitiveValueCallback">jvmtiArrayPrimitiveValueCallback</a> </code></td><td>
	    プリミティブ値の配列を記述するために呼び出されるコールバック。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.string_primitive_value_callback">string_primitive_value_callback</code></td><td><code> <a href="#jvmtiStringPrimitiveValueCallback">jvmtiStringPrimitiveValueCallback</a> </code></td><td>
	    String値を記述するために呼び出されるコールバック。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved5">reserved5</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved6">reserved6</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved7">reserved7</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved8">reserved8</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved9">reserved9</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved10">reserved10</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved11">reserved11</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved12">reserved12</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved13">reserved13</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved14">reserved14</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapCallbacks.reserved15">reserved15</code></td><td><code> <a href="#jvmtiReservedCallback">jvmtiReservedCallback</a> </code></td><td>
	    将来の使用のために予約済み。
	  </td>
</tr>
</table>
</blockquote>
      
<p style="color: purple">
  原理の説明: ヒープ・ダンプ機能(下記)では、オブジェクトごとにコールバックが使用されます。バッファ方式の方がスループットが高いように思われますが、テストでは、そのような結果は得られません。メモリー参照の場所または配列アクセスのオーバーヘッドによるものと考えられます。
      </p>

      

      

    
<p></p>
<hr noshade width="100%" size="1" id="jvmtiHeapIterationCallback">
<h3>ヒープ反復コールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jint length, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。ヒープ内のオブジェクトを記述しますが、値は渡しません。
        <p></p>
        この関数は、必要な<a href="#jvmtiHeapVisitControl">ビジット制御フラグ</a>のビット・ベクトルを返すはずです。これにより、反復処理の全体を中止すべきかどうかが決まります(<code>JVMTI_VISIT_OBJECTS</code>フラグは無視される)。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。オブジェクトが実行時クラスを表す場合、<code>class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    オブジェクトのタグ値(オブジェクトがタグ付けされていない場合はゼロ)。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。 
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.length">length</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    このオブジェクトが配列である場合はその配列の長さ。それ以外の場合はマイナス1 (-1)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapIterationCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiHeapReferenceCallback">
<h3>ヒープ参照コールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind, 
     const jvmtiHeapReferenceInfo* reference_info, 
     jlong class_tag, 
     jlong referrer_class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jlong* referrer_tag_ptr, 
     jint length, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。あるオブジェクトまたはVM (参照側)から別のオブジェクト(参照先)への参照、またはあるヒープ・ルートからある参照先への参照を記述します。
        <p></p>
        この関数は、必要な<a href="#jvmtiHeapVisitControl">ビジット制御フラグ</a>のビット・ベクトルを返すはずです。これにより、参照先が参照しているオブジェクトをビジットすべきかどうかや、反復処理の全体を中止すべきかどうかが決まります。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.reference_kind">reference_kind</code></td><td><code><a href="#jvmtiHeapReferenceKind">jvmtiHeapReferenceKind</a></code></td><td>
	    参照の種類。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.reference_info">reference_info</code></td><td><code>const <a href="#jvmtiHeapReferenceInfo">jvmtiHeapReferenceInfo</a> *</code></td><td>
	    参照に関する詳細。<a href="#jvmtiHeapReferenceCallback.reference_kind">reference_kind</a>が<a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>、<a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>、<a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a>、<a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a>、<a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a>、または<a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a>の場合に設定される。それ以外の場合は<code>NULL</code>。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    参照されるオブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。参照先オブジェクトが実行時クラスを表す場合、<code>class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.referrer_class_tag">referrer_class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
            参照側オブジェクトのクラスのタグ(クラスにタグが付いていないか参照先がヒープ・ルートである場合はゼロ)。参照側オブジェクトが実行時クラスを表す場合、<code>referrer_class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
          </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    参照されるオブジェクトのサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    参照オブジェクトのタグ値(オブジェクトがタグ付けされていない場合はゼロ)をポイントする。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.referrer_tag_ptr">referrer_tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    参照元オブジェクトのタグをポイントする(参照元オブジェクトがタグ付けされていない場合はゼロをポイントする)。参照元がオブジェクトでない場合(つまり、このコールバックの報告対象がヒープ・ルートである場合)は<code>NULL</code>。参照元オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。このコールバックの報告対象が、あるオブジェクトからそれ自身への参照である場合、<code>referrer_tag_ptr == tag_ptr</code>となる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.length">length</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    このオブジェクトが配列である場合はその配列の長さ。それ以外の場合はマイナス1 (-1)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapReferenceCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiPrimitiveFieldCallback">
<h3>プリミティブ・フィールド・コールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind, 
     const jvmtiHeapReferenceInfo* info, 
     jlong object_class_tag, 
     jlong* object_tag_ptr, 
     jvalue value, 
     jvmtiPrimitiveType value_type, 
     void* user_data);</pre>
</blockquote>
        あるオブジェクト(<i>オブジェクト</i>)のプリミティブ・フィールドを記述する、エージェントによって提供されるコールバック関数。プリミティブ・フィールドとは、型がプリミティブ型であるフィールドのことです。このコールバックは、オブジェクトがクラスの場合はstaticフィールドを、それ以外の場合はインスタンス・フィールドをそれぞれ記述します。
        <p></p>
        この関数は、必要な<a href="#jvmtiHeapVisitControl">ビジット制御フラグ</a>のビット・ベクトルを返すはずです。これにより、反復処理の全体を中止すべきかどうかが決まります(<code>JVMTI_VISIT_OBJECTS</code>フラグは無視される)。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.kind">kind</code></td><td><code><a href="#jvmtiHeapReferenceKind">jvmtiHeapReferenceKind</a></code></td><td>
	    フィールドの種類 -- インスタンスまたはstatic (<a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a>または<a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a>)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.info">info</code></td><td><code>const <a href="#jvmtiHeapReferenceInfo">jvmtiHeapReferenceInfo</a> *</code></td><td>
	    どのフィールドか(フィールドのインデックス)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.object_class_tag">object_class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
            オブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。オブジェクトが実行時クラスを表す場合、<code>object_class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.object_tag_ptr">object_tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    オブジェクトのタグ(オブジェクトがタグ付けされていない場合はゼロ)をポイントする。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.value">value</code></td><td><code><a href="#jvalue">jvalue</a></code></td><td>
	    フィールドの値。
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.value_type">value_type</code></td><td><code><a href="#jvmtiPrimitiveType">jvmtiPrimitiveType</a></code></td><td>
	    フィールドの型。
	  </td>
</tr>
<tr>
<td><code id="jvmtiPrimitiveFieldCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiArrayPrimitiveValueCallback">
<h3>配列プリミティブ値コールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jint element_count, 
     jvmtiPrimitiveType element_type, 
     const void* elements, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。プリミティブ型の配列内の値を記述します。
        <p></p>
        この関数は、必要な<a href="#jvmtiHeapVisitControl">ビジット制御フラグ</a>のビット・ベクトルを返すはずです。これにより、反復処理の全体を中止すべきかどうかが決まります(<code>JVMTI_VISIT_OBJECTS</code>フラグは無視される)。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    配列オブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。 
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    配列のサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    配列オブジェクトのタグ(オブジェクトがタグ付けされていない場合はゼロ)をポイントする。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.element_count">element_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    プリミティブ配列の長さ。
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.element_type">element_type</code></td><td><code><a href="#jvmtiPrimitiveType">jvmtiPrimitiveType</a></code></td><td>
	    配列の要素の型。
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.elements">elements</code></td><td><code>const void*</code></td><td>
	    配列の要素。この配列は、<code>element_type</code>のサイズを持つ<code>element_count</code>個の項目から成るパック配列となる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiArrayPrimitiveValueCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiStringPrimitiveValueCallback">
<h3>文字列プリミティブ値コールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     const jchar* value, 
     jint value_length, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。java.lang.Stringの値を記述します。
        <p></p>
        この関数は、必要な<a href="#jvmtiHeapVisitControl">ビジット制御フラグ</a>のビット・ベクトルを返すはずです。これにより、反復処理の全体を中止すべきかどうかが決まります(<code>JVMTI_VISIT_OBJECTS</code>フラグは無視される)。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    Stringクラスのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。 
            
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    文字列のサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    Stringオブジェクトのタグ(オブジェクトがタグ付けされていない場合はゼロ)をポイントする。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.value">value</code></td><td><code>const <a href="#jchar">jchar</a>*</code></td><td>
	    Stringの値。Unicode文字列としてエンコードされる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.value_length">value_length</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    文字列の長さ。この長さは、文字列内の16ビットUnicode文字の数に等しくなる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStringPrimitiveValueCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiReservedCallback">
<h3>将来使用するために予約されたコールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jint (JNICALL *jvmtiReservedCallback)
    ();</pre>
</blockquote>
        プレースホルダー -- 将来の使用のために予約済み。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="FollowReferences">
<h3>参照の追跡</h3>
<blockquote>
<pre>jvmtiError
FollowReferences(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)</pre>
</blockquote>	
        この関数は、指定されたオブジェクトから直接的、間接的に到達可能なオブジェクト(<code>initial_object</code>が指定されなかった場合はヒープ・ルートから到達可能なすべてのオブジェクト)に対してトラバーサルを開始します。ヒープ・ルートは、システム・クラス、JNIグローバル、スレッド・スタックからの参照、ガベージ・コレクションの目的でルートとして使用されるその他のオブジェクトのセットです。 
        <p></p>
        この関数は、参照グラフをトラバースすることで動作します。<i>A</i>、<i>B</i>、...がオブジェクトを表すとします。<i>A</i>から<i>B</i>への参照がトラバースされた場合、ヒープ・ルートから<i>B</i>への参照がトラバースされた場合、または<i>B</i>が<a href="#FollowReferences.initial_object"><code>initial_object</code></a>として指定された場合に、<i>B</i>が<i>ビジットされた</i>と言います。<i>A</i>から<i>B</i>への参照がトラバースされるのは、<i>A</i>がビジットされた後です。参照の報告順序は、参照のトラバース順序と同じになります。オブジェクト参照の報告は、エージェントから提供されたコールバック関数<a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>を呼び出すことで行われます。<i>A</i>から<i>B</i>への参照で、<i>A</i>は<i>参照元</i>、<i>B</i>は<i>参照先</i>と呼ばれます。コールバックの呼出しは、参照元からの参照ごとに1回ずつ行われます。これは、参照循環が存在する場合や参照元へのパスが複数存在する場合でも言えることです。参照元と参照先との間に参照が複数存在する可能性もありますが、その場合はそれぞれの参照が報告されます。これらの参照を区別するには、<a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>コールバックの<a href="#jvmtiHeapReferenceCallback.reference_kind"><code>reference_kind</code></a>および<a href="#jvmtiHeapReferenceCallback.reference_info"><code>reference_info</code></a>パラメータを確認します。
	<p></p>
        この関数が報告するのは、オブジェクト参照のJavaプログラミング言語ビューであり、仮想マシン実装ビューではありません。次のオブジェクト参照が報告されます(nullではない場合)。
        <ul type="disc">
          
<li>インスタンス・オブジェクトは、各非プリミティブ・インスタンス・フィールド(継承されたフィールドも含む)への参照を報告します。</li>
          
<li>インスタンス・オブジェクトは、そのオブジェクトの型(クラス)への参照を報告します。</li>
          
<li>クラスは、スーパー・クラスへの参照と、直接実装または拡張したインタフェースへの参照を報告します。</li>
          
<li>クラスは、クラス・ローダー、保護ドメイン、署名者、および定数プール内の解決済みエントリへの参照を報告します。</li>
          
<li>クラスは、直接宣言された各非プリミティブstaticフィールドへの参照を報告します。</li>
          
<li>配列は、その配列の型(クラス)と各配列要素への参照を報告する。</li>
          
<li>プリミティブ配列は、その配列の型への参照を報告します。</li>
        
</ul>
        
<p></p>
        またこの関数を使えば、プリミティブ(非オブジェクト)値を確認することもできます。配列またはStringのプリミティブ値が報告されるのは、オブジェクトがビジットされた後です。その報告時には、エージェントが提供するコールバック関数<a href="#jvmtiArrayPrimitiveValueCallback"><code>jvmtiArrayPrimitiveValueCallback</code></a>または<a href="#jvmtiStringPrimitiveValueCallback"><code>jvmtiStringPrimitiveValueCallback</code></a>が呼び出されます。あるプリミティブ・フィールドが報告されるのは、そのフィールドを含むオブジェクトがビジットされた後です。その報告時には、エージェントが提供するコールバック関数<a href="#jvmtiPrimitiveFieldCallback"><code>jvmtiPrimitiveFieldCallback</code></a>が呼び出されます。
        <p></p>
        コールバックが提供されるか<code>NULL</code>であるかは、そのコールバックが呼び出されるかどうかだけを決定し、どのオブジェクトがビジットされるかや、ほかのコールバックが呼び出されるかどうかには影響しません。ただし、<a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>から返される<a href="#jvmtiHeapVisitControl">ビジット制御フラグ</a>は、現在のオブジェクトが参照しているオブジェクトをビジットするかどうかを決定します。この関数のパラメータとして提供される<a href="#jvmtiHeapFilter">ヒープ・フィルタ・フラグ</a>と<a href="#FollowReferences.klass"><code>klass</code></a>は、ビジットされるオブジェクトは制御しませんが、コールバックによって報告されるオブジェクトおよびプリミティブ値は制御します。たとえば、設定された唯一のコールバックが<a href="#jvmtiHeapCallbacks.array_primitive_value_callback"><code>array_primitive_value_callback</code></a>であり、<code>klass</code>がバイト配列のクラスに設定された場合、バイト配列のみが報告されます。以上をまとめたのが次の表です。
        <p></p>
        
<table border="1" cellpadding="3" cellspacing="0" width="100%">
          
<tr>
            
<th bgcolor="#EEEEFF" align="center"></th>
            <th bgcolor="#EEEEFF" align="center">
              ビジット対象オブジェクトを制御する
            </th>
            <th bgcolor="#EEEEFF" align="center">
              報告対象オブジェクトを制御する
            </th>
            <th bgcolor="#EEEEFF" align="center">
              報告対象プリミティブを制御する
            </th>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a>によって返される<a href="#jvmtiHeapVisitControl">ヒープ・ビジット制御フラグ</a>
            </th>
            <td align="center">
              <b>はい</b>
            </td>
            <td align="center">
              <b>はい</b>、ビジットが制御されるため
            </td>
            <td align="center">
              <b>はい</b>、ビジットが制御されるため
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#FollowReferences.callbacks"><code>callbacks</code></a>セット内の<a href="#jvmtiHeapCallbacks.array_primitive_value_callback"><code>array_primitive_value_callback</code></a>
            </th>
            <td align="center">
              いいえ
            </td>
            <td align="center">
              <b>はい</b>
            </td>
            <td align="center">
              いいえ
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#FollowReferences.heap_filter"><code>heap_filter</code></a>
            </th>
            <td align="center">
              いいえ
            </td>
            <td align="center">
              <b>はい</b>
            </td>
            <td align="center">
              <b>はい</b>
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#FollowReferences.klass"><code>klass</code></a>
            </th>
            <td align="center">
              いいえ
            </td>
            <td align="center">
              <b>はい</b>
            </td>
            <td align="center">
              <b>はい</b>
            </td>
          
</tr>
        
</table>
        
<p></p>
        この関数の実行中、ヒープの状態は変化しません。オブジェクトの割当てやガベージ・コレクションは行われず、オブジェクトの状態(保持された値を含む)は変化しません。このため、Javaプログラミング言語コードを実行するスレッド、Javaプログラミング言語コードの実行を再開しようとしているスレッド、およびJNI関数を実行しようとしているスレッドは通常ストールされます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>115</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="FollowReferences.heap_filter">heap_filter</code></td><td><code><a href="#jint">jint</a></code></td><td>
            <a href="#jvmtiHeapFilter">ヒープ・フィルタ・フラグ</a>のこのビット・ベクトルは、コールバック関数の呼出し対象となるオブジェクトを制限します。これはオブジェクト・コールバックとプリミティブ・コールバックの両方に当てはまる。
          </td>
</tr>
<tr>
<td><code id="FollowReferences.klass">klass</code></td><td><code> <a href="#jclass">jclass</a> </code></td><td>
            コールバックが報告するのは、オブジェクトがこのクラスのインスタンスである場合だけである。<code>klass</code>のスーパー・クラスのインスタンスであるオブジェクトは、報告されません。<code>klass</code>がインタフェースの場合、オブジェクトは報告されません。これはオブジェクト・コールバックとプリミティブ・コールバックの両方に当てはまる。
          <p></p>
  <code>klass</code>が<code>NULL</code>の場合、コールバックは特定のクラスのインスタンスに制限されません。
</td>
</tr>
<tr>
<td><code id="FollowReferences.initial_object">initial_object</code></td><td><code> <a href="#jobject">jobject</a> </code></td><td>
            追跡するオブジェクト
          <p></p>
  <code>initial_object</code>が<code>NULL</code>の場合、ヒープ・ルートから参照の追跡が行われる。
</td>
</tr>
<tr>
<td><code id="FollowReferences.callbacks">callbacks</code></td><td><code>const <a href="#jvmtiHeapCallbacks">jvmtiHeapCallbacks</a> *</code></td><td>
            一連のコールバック関数を定義する構造体。
          <p></p>エージェントは<code>jvmtiHeapCallbacks</code>へのポインタを渡す。 </td>
</tr>
<tr>
<td><code id="FollowReferences.user_data">user_data</code></td><td><code>const void *</code></td><td>
            ユーザーが入力し、コールバックに渡されるデータ。 
          <p></p>エージェントがポインタを渡す。<code>user_data</code>が<code>NULL</code>の場合、<code>NULL</code>がユーザー指定データとして渡される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
          <a href="#FollowReferences.klass"><code>klass</code></a>は有効なクラスではない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
          <a href="#FollowReferences.initial_object"><code>initial_object</code></a>は有効なオブジェクトではない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
          <a href="#FollowReferences.callbacks"><code>callbacks</code></a>が<code>NULL</code>。
          
        </td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IterateThroughHeap">
<h3>ヒープ内での反復</h3>
<blockquote>
<pre>jvmtiError
IterateThroughHeap(jvmtiEnv* env,
            jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)</pre>
</blockquote>        
        ヒープ内のすべてのオブジェクトに対する反復処理を起動します。到達可能なオブジェクトも、そうでないオブジェクトも含まれます。オブジェクトのビジットは特定の順番では行われません。
        <p></p>
        ヒープ・オブジェクトの報告は、エージェントから提供されるコールバック関数<a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a>を呼び出すことで行われます。オブジェクト間の参照は報告されません。到達可能なオブジェクトのみが必要である場合や、オブジェクト参照の情報が必要である場合には、<a href="#FollowReferences"><code>FollowReferences</code></a>を使用してください。
        <p></p>
        またこの関数を使えば、プリミティブ(非オブジェクト)値を確認することもできます。配列またはStringのプリミティブ値が報告されるのは、オブジェクトがビジットされた後です。その報告時には、エージェントが提供するコールバック関数<a href="#jvmtiArrayPrimitiveValueCallback"><code>jvmtiArrayPrimitiveValueCallback</code></a>または<a href="#jvmtiStringPrimitiveValueCallback"><code>jvmtiStringPrimitiveValueCallback</code></a>が呼び出されます。あるプリミティブ・フィールドが報告されるのは、そのフィールドを含むオブジェクトがビジットされた後です。その報告時には、エージェントが提供するコールバック関数<a href="#jvmtiPrimitiveFieldCallback"><code>jvmtiPrimitiveFieldCallback</code></a>が呼び出されます。
        <p></p>
        コールバックから返される<a href="#jvmtiHeapVisitControl">ヒープ・ビジット制御フラグ</a>によって反復処理が中止されないかぎり、ヒープ内のすべてのオブジェクトがビジットされます。コールバックが提供されるか<code>NULL</code>であるかは、そのコールバックが呼び出されるかどうかだけを決定し、どのオブジェクトがビジットされるかや、ほかのコールバックが呼び出されるかどうかには影響しません。この関数のパラメータとして提供される<a href="#jvmtiHeapFilter">ヒープ・フィルタ・フラグ</a>と<a href="#IterateThroughHeap.klass"><code>klass</code></a>は、ビジットされるオブジェクトは制御しませんが、コールバックによって報告されるオブジェクトおよびプリミティブ値は制御します。たとえば、設定された唯一のコールバックが<a href="#jvmtiHeapCallbacks.array_primitive_value_callback"><code>array_primitive_value_callback</code></a>であり、<code>klass</code>がバイト配列のクラスに設定された場合、バイト配列のみが報告されます。これをまとめたのが下の表です(これを<a href="#FollowReferences"><code>FollowReferences</code></a>と比較してください)。
        <p></p>
        
<table border="1" cellpadding="3" cellspacing="0" width="100%">
          
<tr>
            
<th bgcolor="#EEEEFF" align="center"></th>
            <th bgcolor="#EEEEFF" align="center">
              ビジット対象オブジェクトを制御する
            </th>
            <th bgcolor="#EEEEFF" align="center">
              報告対象オブジェクトを制御する
            </th>
            <th bgcolor="#EEEEFF" align="center">
              報告対象プリミティブを制御する
            </th>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a>によって返される<a href="#jvmtiHeapVisitControl">ヒープ・ビジット制御フラグ</a>
            </th>
            <td align="center">
              いいえ<br>(反復処理が中止される場合は除く)
            </td>
            <td align="center">
              いいえ<br>(反復処理が中止される場合は除く)
            </td>
            <td align="center">
              いいえ<br>(反復処理が中止される場合は除く)
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#IterateThroughHeap.callbacks"><code>callbacks</code></a>セット内の<a href="#jvmtiHeapCallbacks.array_primitive_value_callback"><code>array_primitive_value_callback</code></a>
            </th>
            <td align="center">
              いいえ
            </td>
            <td align="center">
              <b>はい</b>
            </td>
            <td align="center">
              いいえ
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#IterateThroughHeap.heap_filter"><code>heap_filter</code></a>
            </th>
            <td align="center">
              いいえ
            </td>
            <td align="center">
              <b>はい</b>
            </td>
            <td align="center">
              <b>はい</b>
            </td>
          
</tr>
          
<tr>
            
<th bgcolor="#EEEEFF" align="left">
              <a href="#IterateThroughHeap.klass"><code>klass</code></a>
            </th>
            <td align="center">
              いいえ
            </td>
            <td align="center">
              <b>はい</b>
            </td>
            <td align="center">
              <b>はい</b>
            </td>
          
</tr>
        
</table>
        
<p></p>
        この関数の実行中、ヒープの状態は変化しません。オブジェクトの割当てやガベージ・コレクションは行われず、オブジェクトの状態(保持された値を含む)は変化しません。このため、Javaプログラミング言語コードを実行するスレッド、Javaプログラミング言語コードの実行を再開しようとしているスレッド、およびJNI関数を実行しようとしているスレッドは通常ストールされます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>116</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IterateThroughHeap.heap_filter">heap_filter</code></td><td><code><a href="#jint">jint</a></code></td><td>
            <a href="#jvmtiHeapFilter">ヒープ・フィルタ・フラグ</a>のこのビット・ベクトルは、コールバック関数の呼出し対象となるオブジェクトを制限します。これはオブジェクト・コールバックとプリミティブ・コールバックの両方に当てはまる。
          </td>
</tr>
<tr>
<td><code id="IterateThroughHeap.klass">klass</code></td><td><code> <a href="#jclass">jclass</a> </code></td><td>
            コールバックが報告するのは、オブジェクトがこのクラスのインスタンスである場合だけである。<code>klass</code>のスーパー・クラスのインスタンスであるオブジェクトは、報告されません。<code>klass</code>がインタフェースの場合、オブジェクトは報告されません。これはオブジェクト・コールバックとプリミティブ・コールバックの両方に当てはまる。
          <p></p>
  <code>klass</code>が<code>NULL</code>の場合、コールバックは特定のクラスのインスタンスに制限されません。
</td>
</tr>
<tr>
<td><code id="IterateThroughHeap.callbacks">callbacks</code></td><td><code>const <a href="#jvmtiHeapCallbacks">jvmtiHeapCallbacks</a> *</code></td><td>
            一連のコールバック関数を定義する構造体。
          <p></p>エージェントは<code>jvmtiHeapCallbacks</code>へのポインタを渡す。 </td>
</tr>
<tr>
<td><code id="IterateThroughHeap.user_data">user_data</code></td><td><code>const void *</code></td><td>
            ユーザーが入力し、コールバックに渡されるデータ。 
          <p></p>エージェントがポインタを渡す。<code>user_data</code>が<code>NULL</code>の場合、<code>NULL</code>がユーザー指定データとして渡される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
          <a href="#IterateThroughHeap.klass"><code>klass</code></a>は有効なクラスではない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
          <a href="#IterateThroughHeap.callbacks"><code>callbacks</code></a>が<code>NULL</code>。
          
        </td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetTag">
<h3>タグの取得</h3>
<blockquote>
<pre>jvmtiError
GetTag(jvmtiEnv* env,
            jobject object,
            jlong* tag_ptr)</pre>
</blockquote>
        オブジェクトに関連付けられているタグを取得します。タグは長整数値で、通常、オブジェクト情報の一意の識別子またはポインタを格納するために使用されます。タグの設定には、<a href="#SetTag"><code>SetTag</code></a>関数を使用します。タグが設定されていないオブジェクトは、タグ値としてゼロを返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>106</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetTag.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      タグが取得されるオブジェクト。
	    </td>
</tr>
<tr>
<td><code id="GetTag.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    戻ったとき、参照される長整数値にタグ値が設定されている。
	  <p></p>エージェントは<code>jlong</code>へのポインタを渡す。戻ったとき、<code>jlong</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#GetTag.object"><code>object</code></a>がオブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetTag.tag_ptr"><code>tag_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetTag">
<h3>タグの設定</h3>
<blockquote>
<pre>jvmtiError
SetTag(jvmtiEnv* env,
            jobject object,
            jlong tag)</pre>
</blockquote>
        オブジェクトに関連付けられているタグを設定します。タグは長整数値で、通常、オブジェクト情報の一意の識別子またはポインタを格納するために使用されます。タグの表示には、<a href="#GetTag"><code>GetTag</code></a>関数を使用します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>107</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetTag.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      タグが設定されるオブジェクト。
	    </td>
</tr>
<tr>
<td><code id="SetTag.tag">tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    タグの新しい値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#SetTag.object"><code>object</code></a>がオブジェクトではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetObjectsWithTags">
<h3>タグを使ったオブジェクトの取得</h3>
<blockquote>
<pre>jvmtiError
GetObjectsWithTags(jvmtiEnv* env,
            jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr)</pre>
</blockquote>
	ヒープ内の指定されたタグを持つオブジェクトを返します。オブジェクトとタグの並行配列の形式になります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>114</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.tag_count">tag_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	      走査するタグの数。
	    </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.tags">tags</code></td><td><code>const <a href="#jlong">jlong</a> *</code></td><td>
	      これらのタグが付けられたオブジェクトを走査する。この配列内では、ゼロは使用できない。
	    <p></p>エージェントは<code>jlong</code>の<code>tag_count</code>要素の配列を渡す。 </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.count_ptr">count_ptr</code></td><td><code> <a href="#jint">jint</a> *</code></td><td>
	      <a href="#GetObjectsWithTags.tags"><code>tags</code></a>内の任意のタグを持つオブジェクトの数を返す。
	    <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.object_result_ptr">object_result_ptr</code></td><td><code> <a href="#jobject">jobject</a> **</code></td><td>
	      <a href="#GetObjectsWithTags.tags"><code>tags</code></a>内の任意のタグを持つオブジェクトの配列を返す。
	    <p></p>エージェントは<code>jobject*</code>へのポインタを渡す。戻ったとき、<code>jobject*</code>は、サイズ<code>*count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>object_result_ptr</code>が<code>NULL</code>の場合、この情報は返されない。<code>object_result_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
<tr>
<td><code id="GetObjectsWithTags.tag_result_ptr">tag_result_ptr</code></td><td><code> <a href="#jlong">jlong</a> **</code></td><td>
	      <a href="#GetObjectsWithTags.object_result_ptr"><code>object_result_ptr</code></a>内の各オブジェクトに対して、対応するインデックスのタグを返す。
	    <p></p>エージェントは<code>jlong*</code>へのポインタを渡す。戻ったとき、<code>jlong*</code>は、サイズ<code>*count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>tag_result_ptr</code>が<code>NULL</code>の場合、この情報は返されない。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetObjectsWithTags.tags"><code>tags</code></a>内にゼロが存在する。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetObjectsWithTags.tag_count"><code>tag_count</code></a>が<code>0</code>より小さい。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetObjectsWithTags.tags"><code>tags</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetObjectsWithTags.count_ptr"><code>count_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ForceGarbageCollection">
<h3>ガベージ・コレクションの強制</h3>
<blockquote>
<pre>jvmtiError
ForceGarbageCollection(jvmtiEnv* env)</pre>
</blockquote>
        VMにガベージ・コレクションの実行を強制します。ガベージ・コレクションは可能なかぎり完全に行われます。この関数は、ファイナライザを実行させません。この関数は、ガベージ・コレクションが完了するまで終了しません。
        <p></p>
        ガベージ・コレクションは可能なかぎり完全に実行されますが、この関数が戻るまでにすべての<a href="#ObjectFree"><code>ObjectFree</code></a>イベントが送信されているという保証はありません。特に、ファイナライズ待ちのオブジェクトが解放されない可能性があります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>108</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>を返します</td>
</tr>
</table>
<p id="Heap_1_0"></p>
<hr noshade size="3">
<h2 align="center">ヒープ(1.0)</h2>ヒープ(1.0)の関数:
  <ul>
<li>
<a href="#IterateOverObjectsReachableFromObject">オブジェクトから到達可能なオブジェクトの反復</a>
</li>
<li>
<a href="#IterateOverReachableObjects">到達可能なオブジェクトの反復</a>
</li>
<li>
<a href="#IterateOverHeap">ヒープの反復</a>
</li>
<li>
<a href="#IterateOverInstancesOfClass">クラスのインスタンスの反復</a>
</li>
</ul>ヒープ(1.0)の関数型:
    <ul>
<li>
<a href="#jvmtiHeapObjectCallback">ヒープ・オブジェクトのコールバック</a>
</li>
<li>
<a href="#jvmtiHeapRootCallback">ヒープ・ルート・オブジェクトのコールバック</a>
</li>
<li>
<a href="#jvmtiStackReferenceCallback">スタック参照オブジェクトのコールバック</a>
</li>
<li>
<a href="#jvmtiObjectReferenceCallback">オブジェクト参照のコールバック</a>
</li>
</ul>ヒープ(1.0)の型:
    <ul>
<li>
<a href="#jvmtiHeapObjectFilter"><code>jvmtiHeapObjectFilter</code></a> - ヒープ・オブジェクトのフィルタの列挙</li>
<li>
<a href="#jvmtiHeapRootKind"><code>jvmtiHeapRootKind</code></a> - ヒープ・ルートの種類の列挙</li>
<li>
<a href="#jvmtiObjectReferenceKind"><code>jvmtiObjectReferenceKind</code></a> - オブジェクト参照の列挙</li>
<li>
<a href="#jvmtiIterationControl"><code>jvmtiIterationControl</code></a> - 反復制御の列挙</li>
</ul>
      
<b>これらの関数およびデータ型は元のJVM<small style="font-size: xx-small">&nbsp;</small>TI Version 1.0で導入されたものであり、</b><a href="#Heap"><b>より強力で柔軟性の高いバージョンで置き換えられました。</b></a><b>新しいバージョンの特徴を次に示します。</b>
      
<ul type="disc">
        
<li>
          
<b>プリミティブ値(Strings、配列、およびプリミティブ・フィールドの値)へのアクセスを可能にする</b>
        
</li>
        
<li>
          
<b>参照側のタグを設定できるようにする。このため、より効率的なローカライズされた参照グラフの構築が可能となる</b>
        
</li>
        
<li>
          
<b>より広範なフィルタ・リング機能を提供する</b>
        
</li>
        
<li>
          
<b>拡張可能である。このため、JVM<small style="font-size: xx-small">&nbsp;</small>TIの将来のバージョンで拡張を施すことができる</b>
        
</li>
      
</ul>
      
<p></p>
      
<a href="#Heap"><b>現在のヒープ関数</b></a><b>を使用してください</b>。
        <p></p>
        
<blockquote>
<a name="jvmtiHeapObjectFilter"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">ヒープ・オブジェクトのフィルタの列挙(<code>jvmtiHeapObjectFilter</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_OBJECT_TAGGED">JVMTI_HEAP_OBJECT_TAGGED</code></td><td align="right">1</td><td>
	    タグ付きオブジェクトのみ。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_OBJECT_UNTAGGED">JVMTI_HEAP_OBJECT_UNTAGGED</code></td><td align="right">2</td><td>
	    タグなしオブジェクトのみ。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_OBJECT_EITHER">JVMTI_HEAP_OBJECT_EITHER</code></td><td align="right">3</td><td>
	    タグ付きオブジェクトまたはタグなしオブジェクト。
	  </td>
</tr>
</table>
</blockquote>

        
<blockquote>
<a name="jvmtiHeapRootKind"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">ヒープ・ルートの種類の列挙(<code>jvmtiHeapRootKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_JNI_GLOBAL">JVMTI_HEAP_ROOT_JNI_GLOBAL</code></td><td align="right">1</td><td>
	    JNIグローバル参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_SYSTEM_CLASS">JVMTI_HEAP_ROOT_SYSTEM_CLASS</code></td><td align="right">2</td><td>
	    システム・クラス。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_MONITOR">JVMTI_HEAP_ROOT_MONITOR</code></td><td align="right">3</td><td>
	    モニター。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_STACK_LOCAL">JVMTI_HEAP_ROOT_STACK_LOCAL</code></td><td align="right">4</td><td>
	    スタック・ローカル。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_JNI_LOCAL">JVMTI_HEAP_ROOT_JNI_LOCAL</code></td><td align="right">5</td><td>
	    JNIローカル参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_THREAD">JVMTI_HEAP_ROOT_THREAD</code></td><td align="right">6</td><td>
	    スレッド。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_HEAP_ROOT_OTHER">JVMTI_HEAP_ROOT_OTHER</code></td><td align="right">7</td><td>
	    その他。
	  </td>
</tr>
</table>
</blockquote>

        
<blockquote>
<a name="jvmtiObjectReferenceKind"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">オブジェクト参照の列挙(<code>jvmtiObjectReferenceKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_CLASS">JVMTI_REFERENCE_CLASS</code></td><td align="right">1</td><td>
	    オブジェクトからそのクラスへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_FIELD">JVMTI_REFERENCE_FIELD</code></td><td align="right">2</td><td>
	    オブジェクトから、そのオブジェクトのいずれかのインスタンス・フィールド値への参照。この種の参照の場合、<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>の<code>referrer_index</code>パラメータはインスタンス・フィールドのインデックス。インデックスは、すべてのオブジェクトのフィールドの順序が基になる。クラスで直接宣言されたstaticおよびインスタンス・フィールドが含まれるほか、スーパー・クラスおよびスーパー・インタフェースで宣言されたすべてのフィールド(publicとprivateの両方)が含まれる。そのためインデックスは、直接宣言されたクラスにあるフィールドのインデックス(<a href="#GetClassFields"><code>GetClassFields</code></a>参照)と、すべてのスーパー・クラスおよびスーパー・インタフェースで宣言されたフィールド(publicとprivateの両方)の合計数を足し合わせたもので計算されます。インデックスは0から始まる。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_ARRAY_ELEMENT">JVMTI_REFERENCE_ARRAY_ELEMENT</code></td><td align="right">3</td><td>
	    配列から、その配列のいずれかの要素への参照。この種の参照の場合、<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>の<code>referrer_index</code>パラメータは配列のインデックス。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_CLASS_LOADER">JVMTI_REFERENCE_CLASS_LOADER</code></td><td align="right">4</td><td>
	    クラスからそのクラス・ローダーへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_SIGNERS">JVMTI_REFERENCE_SIGNERS</code></td><td align="right">5</td><td>
	    クラスからその署名者の配列への参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_PROTECTION_DOMAIN">JVMTI_REFERENCE_PROTECTION_DOMAIN</code></td><td align="right">6</td><td>
	    クラスからその保護ドメインへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_INTERFACE">JVMTI_REFERENCE_INTERFACE</code></td><td align="right">7</td><td>
	    クラスから、そのクラスのいずれかのインタフェースへの参照。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_STATIC_FIELD">JVMTI_REFERENCE_STATIC_FIELD</code></td><td align="right">8</td><td>
	    クラスからそのいずれかのstaticフィールド値への参照。この種の参照の場合、<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>の<code>referrer_index</code>パラメータはstaticフィールドのインデックス。インデックスは、すべてのオブジェクトのフィールドの順序が基になる。クラスで直接宣言されたstaticおよびインスタンス・フィールドが含まれるほか、スーパー・クラスおよびスーパー・インタフェースで宣言されたすべてのフィールド(publicとprivateの両方)が含まれる。そのためインデックスは、直接宣言されたクラスにあるフィールドのインデックス(<a href="#GetClassFields"><code>GetClassFields</code></a>参照)と、すべてのスーパー・クラスおよびスーパー・インタフェースで宣言されたフィールド(publicとprivateの両方)の合計数を足し合わせたもので計算されます。インデックスは0から始まる。注: この定義は、JVM<small style="font-size: xx-small">&nbsp;</small>TI 1.0仕様での定義と異なる。
            <p style="color: purple">
  原理の説明: 既知の実装のなかで、1.0の定義を使用したものはない。</p>
	  
</td>
</tr>
<tr>
<td><code id="JVMTI_REFERENCE_CONSTANT_POOL">JVMTI_REFERENCE_CONSTANT_POOL</code></td><td align="right">9</td><td>
	    クラスから定数プール内の解決済みエントリへの参照。この種の参照の場合、<a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a>の<code>referrer_index</code>パラメータは、クラスの定数プール・テーブルのインデックスで、1から始まる。<cite>Java(tm)仮想マシン仕様のセクション4.4</cite>を参照。
	  </td>
</tr>
</table>
</blockquote>

        
<blockquote>
<a name="jvmtiIterationControl"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">反復制御の列挙(<code>jvmtiIterationControl</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_ITERATION_CONTINUE">JVMTI_ITERATION_CONTINUE</code></td><td align="right">1</td><td>
	    反復処理を継続。参照の反復処理の場合、このオブジェクトの参照に従う。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_ITERATION_IGNORE">JVMTI_ITERATION_IGNORE</code></td><td align="right">2</td><td>
	    反復処理を継続。参照の反復処理の場合、このオブジェクトの参照を無視する。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_ITERATION_ABORT">JVMTI_ITERATION_ABORT</code></td><td align="right">0</td><td>
	    反復処理を中止。
	  </td>
</tr>
</table>
</blockquote>
    
<p></p>
<hr noshade width="100%" size="1" id="jvmtiHeapObjectCallback">
<h3>ヒープ・オブジェクトのコールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。ヒープ内のオブジェクトを記述しますが、値は渡しません。
        <p></p>
        反復処理を継続する場合、戻り値は<code>JVMTI_ITERATION_CONTINUE</code>です。反復処理を停止する場合、戻り値は<code>JVMTI_ITERATION_ABORT</code>です。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。オブジェクトが実行時クラスを表す場合、<code>class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    オブジェクトのタグ値(オブジェクトがタグ付けされていない場合はゼロ)。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。 
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapObjectCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiHeapRootCallback">
<h3>ヒープ・ルート・オブジェクトのコールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind, 
     jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。ガベージ・コレクションの目的で、ルート・オブジェクトについて説明しますが、値は渡しません。
        <p></p>
        戻り値は、反復処理を継続する場合は<code>JVMTI_ITERATION_CONTINUE</code>、参照側オブジェクトからの参照を続行しないで反復処理を継続する場合は<code>JVMTI_ITERATION_IGNORE</code>、反復処理を停止する場合は<code>JVMTI_ITERATION_ABORT</code>のはずです。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.root_kind">root_kind</code></td><td><code><a href="#jvmtiHeapRootKind">jvmtiHeapRootKind</a></code></td><td>
	    ヒープ・ルートの種類。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。オブジェクトが実行時クラスを表す場合、<code>class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    オブジェクトのタグ値(オブジェクトがタグ付けされていない場合はゼロ)。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiHeapRootCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiStackReferenceCallback">
<h3>スタック参照オブジェクトのコールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind, 
     jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jlong thread_tag, 
     jint depth, 
     jmethodID method, 
     jint slot, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。ガベージ・コレクションの目的で、スタック上のルート・オブジェクトについて説明しますが、値は渡しません。
        <p></p>
        戻り値は、反復処理を継続する場合は<code>JVMTI_ITERATION_CONTINUE</code>、参照側オブジェクトからの参照を続行しないで反復処理を継続する場合は<code>JVMTI_ITERATION_IGNORE</code>、反復処理を停止する場合は<code>JVMTI_ITERATION_ABORT</code>のはずです。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.root_kind">root_kind</code></td><td><code><a href="#jvmtiHeapRootKind">jvmtiHeapRootKind</a></code></td><td>
	    ルートの種類(<code>JVMTI_HEAP_ROOT_STACK_LOCAL</code>または<code>JVMTI_HEAP_ROOT_JNI_LOCAL</code>)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
           オブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。オブジェクトが実行時クラスを表す場合、<code>class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    オブジェクトのタグ値(オブジェクトがタグ付けされていない場合はゼロ)。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.thread_tag">thread_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    このスタックに対応するスレッドのタグ。タグ付けされていない場合はゼロ。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    フレームの深さ。 
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    このフレーム内で実行されているメソッド。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    スロット番号。
	  </td>
</tr>
<tr>
<td><code id="jvmtiStackReferenceCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiObjectReferenceCallback">
<h3>オブジェクト参照のコールバック</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind, 
     jlong class_tag, 
     jlong size, 
     jlong* tag_ptr, 
     jlong referrer_tag, 
     jint referrer_index, 
     void* user_data);</pre>
</blockquote>
        エージェントによって提供されるコールバック関数。あるオブジェクト(参照側)から別のオブジェクト(参照先)の参照について説明します。
        <p></p>
        戻り値は、反復処理を継続する場合は<code>JVMTI_ITERATION_CONTINUE</code>、参照側オブジェクトからの参照を続行しないで反復処理を継続する場合は<code>JVMTI_ITERATION_IGNORE</code>、反復処理を停止する場合は<code>JVMTI_ITERATION_ABORT</code>のはずです。
        <p></p>
        <a href="#heapCallbacks">ヒープ・コールバック関数の制約</a>を参照してください。
      <p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.reference_kind">reference_kind</code></td><td><code><a href="#jvmtiObjectReferenceKind">jvmtiObjectReferenceKind</a></code></td><td>
	    参照型。
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.class_tag">class_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    参照されるオブジェクトのクラスのタグ(タグ付けされていないクラスの場合はゼロ)。参照先オブジェクトが実行時クラスを表す場合、<code>class_tag</code>は<code>java.lang.Class</code>に関連付けされたタグです(<code>java.lang.Class</code>がタグ付けされていない場合はゼロ)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    参照されるオブジェクトのサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.tag_ptr">tag_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    参照オブジェクトのタグ値(オブジェクトがタグ付けされていない場合はゼロ)。オブジェクトと関連付けるタグの値を設定するため、エージェントはパラメータによってポイントされる<code>jlong</code>を設定する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.referrer_tag">referrer_tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    参照側のオブジェクトのタグ値。タグ付けされていないオブジェクトの場合はゼロ。
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.referrer_index">referrer_index</code></td><td><code><a href="#jint">jint</a></code></td><td>	    
	    <code>JVMTI_REFERENCE_FIELD</code>または<code>JVMTI_REFERENCE_STATIC_FIELD</code>型の参照の場合、参照元オブジェクト内のフィールドのインデックス。このインデックスは、オブジェクトのすべてのフィールドの順番に基づく。詳しい説明については、<a href="#JVMTI_REFERENCE_FIELD">JVMTI_REFERENCE_FIELD</a>または<a href="#JVMTI_REFERENCE_STATIC_FIELD">JVMTI_REFERENCE_STATIC_FIELD </a>を参照。
	    <p></p>
	    型<code>JVMTI_REFERENCE_ARRAY_ELEMENT</code>の参照の場合は、配列インデックス。詳細な説明については、<a href="#JVMTI_REFERENCE_ARRAY_ELEMENT">JVMTI_REFERENCE_ARRAY_ELEMENT</a>を参照。
	    <p></p>
	    型<code>JVMTI_REFERENCE_CONSTANT_POOL</code>の参照の場合は、クラスの定数プールに対するインデックス。詳細な説明については、<a href="#JVMTI_REFERENCE_CONSTANT_POOL">JVMTI_REFERENCE_CONSTANT_POOL</a>を参照。
	    <p></p>
	    その他の参照の場合、<code>referrer_index</code>は<code>-1</code>。
	  </td>
</tr>
<tr>
<td><code id="jvmtiObjectReferenceCallback.user_data">user_data</code></td><td><code>void*</code></td><td>
	    ユーザーが入力し、反復関数に渡されたデータ。 
	  </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IterateOverObjectsReachableFromObject">
<h3>オブジェクトから到達可能なオブジェクトの反復</h3>
<blockquote>
<pre>jvmtiError
IterateOverObjectsReachableFromObject(jvmtiEnv* env,
            jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data)</pre>
</blockquote>	
        この関数は、指定されたオブジェクトから直接的または間接的に到達可能なすべてのオブジェクトに対して反復処理を行います。オブジェクト<i>B</i>を参照する各オブジェクト<i>A</i>(参照元と呼ばれる)に対し、そのオブジェクト参照を記述する目的で、指定されたコールバック関数が呼び出されます。コールバックの呼出しは、参照元からの参照ごとに1回ずつ行われます。これは、参照循環が存在する場合や参照元へのパスが複数存在する場合でも言えることです。参照元と参照先との間の参照は複数存在する可能性があります。これらを区別するには、<a href="#jvmtiObjectReferenceCallback.reference_kind"><code>jvmtiObjectReferenceCallback.reference_kind</code></a>および<a href="#jvmtiObjectReferenceCallback.referrer_index"><code>jvmtiObjectReferenceCallback.referrer_index</code></a>を使用します。あるオブジェクトのコールバックは必ず、その参照元のコールバックの後で発生します。
        <p></p>
        報告されるオブジェクト参照については、<a href="#FollowReferences"><code>FollowReferences</code></a>を参照してください。
        <p></p>
        この関数の実行中、ヒープの状態は変化しません。オブジェクトの割当てやガベージ・コレクションは行われず、オブジェクトの状態(保持された値を含む)は変化しません。このため、Javaプログラミング言語コードを実行するスレッド、Javaプログラミング言語コードの実行を再開しようとしているスレッド、およびJNI関数を実行しようとしているスレッドは通常ストールされます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>109</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IterateOverObjectsReachableFromObject.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      オブジェクト
	    </td>
</tr>
<tr>
<td><code id="IterateOverObjectsReachableFromObject.object_reference_callback">object_reference_callback</code></td><td><code> <a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a> </code></td><td>
	      各オブジェクト参照を記述するために呼び出されるコールバック。
	    <p></p>
</td>
</tr>
<tr>
<td><code id="IterateOverObjectsReachableFromObject.user_data">user_data</code></td><td><code>const void *</code></td><td>
	    ユーザーが入力し、コールバックに渡されるデータ。 
	  <p></p>エージェントがポインタを渡す。<code>user_data</code>が<code>NULL</code>の場合、<code>NULL</code>がユーザー指定データとして渡される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#IterateOverObjectsReachableFromObject.object"><code>object</code></a>がオブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IterateOverObjectsReachableFromObject.object_reference_callback"><code>object_reference_callback</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IterateOverReachableObjects">
<h3>到達可能なオブジェクトの反復</h3>
<blockquote>
<pre>jvmtiError
IterateOverReachableObjects(jvmtiEnv* env,
            jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data)</pre>
</blockquote>
        この関数は、ルート・オブジェクトと、ルート・オブジェクトから直接または間接的に到達可能なすべてのオブジェクトに対して反復処理を行います。ルート・オブジェクトは、システム・クラス、JNIグローバル、スレッド・スタックからの参照、ガベージ・コレクションの目的でルートとして使用されるその他のオブジェクトのセットで構成されます。 
	<p></p>
	各ルートに対して、<a href="#IterateOverReachableObjects.heap_root_callback"><code>heap_root_callback</code></a>または<a href="#IterateOverReachableObjects.stack_ref_callback"><code>stack_ref_callback</code></a>コールバックが呼び出されます。オブジェクトは複数の理由でルート・オブジェクトになる可能性がありますが、その場合、対応するコールバックが理由ごとに呼び出されます。
	<p></p>
	各オブジェクト参照について、そのオブジェクト参照を記述する目的で<a href="#IterateOverReachableObjects.object_ref_callback"><code>object_ref_callback</code></a>コールバック関数が呼び出されます。コールバックの呼出しは、参照元からの参照ごとに1回ずつ行われます。これは、参照循環が存在する場合や参照元へのパスが複数存在する場合でも言えることです。参照元と参照先との間の参照は複数存在する可能性があります。これらを区別するには、<a href="#jvmtiObjectReferenceCallback.reference_kind"><code>jvmtiObjectReferenceCallback.reference_kind</code></a>および<a href="#jvmtiObjectReferenceCallback.referrer_index"><code>jvmtiObjectReferenceCallback.referrer_index</code></a>を使用します。あるオブジェクトのコールバックは必ず、その参照元のコールバックの後で発生します。
        <p></p>
        報告されるオブジェクト参照については、<a href="#FollowReferences"><code>FollowReferences</code></a>を参照してください。
	<p></p>
	ルートは、常に、オブジェクト参照が報告される前に、プロファイラに報告されます。つまり、<a href="#IterateOverReachableObjects.object_ref_callback"><code>object_ref_callback</code></a>は、すべてのルートに対して適切なコールバックが呼び出されるまで、呼び出されません。<a href="#IterateOverReachableObjects.object_ref_callback"><code>object_ref_callback</code></a>が<code>NULL</code>と指定されている場合、この関数は、プロファイラにルート・オブジェクトを報告したあと、終了します。
        <p></p>
        この関数の実行中、ヒープの状態は変化しません。オブジェクトの割当てやガベージ・コレクションは行われず、オブジェクトの状態(保持された値を含む)は変化しません。このため、Javaプログラミング言語コードを実行するスレッド、Javaプログラミング言語コードの実行を再開しようとしているスレッド、およびJNI関数を実行しようとしているスレッドは通常ストールされます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>110</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.heap_root_callback">heap_root_callback</code></td><td><code> <a href="#jvmtiHeapRootCallback">jvmtiHeapRootCallback</a> </code></td><td>
	      <code>JVMTI_HEAP_ROOT_JNI_GLOBAL</code>、<code>JVMTI_HEAP_ROOT_SYSTEM_CLASS</code>、<code>JVMTI_HEAP_ROOT_MONITOR</code>、<code>JVMTI_HEAP_ROOT_THREAD</code>、または<code>JVMTI_HEAP_ROOT_OTHER</code>型の各ヒープ・ルートのために呼び出されるコールバック関数。
	    <p></p>
  <code>heap_root_callback</code>が<code>NULL</code>の場合、ヒープ・ルートの報告は行わない。
</td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.stack_ref_callback">stack_ref_callback</code></td><td><code> <a href="#jvmtiStackReferenceCallback">jvmtiStackReferenceCallback</a> </code></td><td>
	      <code>JVMTI_HEAP_ROOT_STACK_LOCAL</code>または<code>JVMTI_HEAP_ROOT_JNI_LOCAL</code>の各ヒープ・ルートのために呼び出されるコールバック関数。
	    <p></p>
  <code>stack_ref_callback</code>が<code>NULL</code>の場合、スタック参照の報告は行わない。
</td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.object_ref_callback">object_ref_callback</code></td><td><code> <a href="#jvmtiObjectReferenceCallback">jvmtiObjectReferenceCallback</a> </code></td><td>
	      各オブジェクト参照のために呼び出されるコールバック関数。
	    <p></p>
  <code>object_ref_callback</code>が<code>NULL</code>の場合、ルート・オブジェクトからの参照には従わない。
</td>
</tr>
<tr>
<td><code id="IterateOverReachableObjects.user_data">user_data</code></td><td><code>const void *</code></td><td>
	    ユーザーが入力し、コールバックに渡されるデータ。 
	  <p></p>エージェントがポインタを渡す。<code>user_data</code>が<code>NULL</code>の場合、<code>NULL</code>がユーザー指定データとして渡される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IterateOverHeap">
<h3>ヒープの反復</h3>
<blockquote>
<pre>jvmtiError
IterateOverHeap(jvmtiEnv* env,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)</pre>
</blockquote>        
        ヒープ内のすべてのオブジェクトに対して反復処理を行います。到達可能なオブジェクトも、そうでないオブジェクトも含まれます。
	<p></p>
	<a href="#IterateOverHeap.object_filter"><code>object_filter</code></a>パラメータは、どのオブジェクトのためにコールバック関数が呼び出されるかを示します。パラメータが<code>JVMTI_HEAP_OBJECT_TAGGED</code>の場合、コールバックは、すべてのタグ付きオブジェクトに対してのみ呼び出されます。パラメータが<code>JVMTI_HEAP_OBJECT_UNTAGGED</code>の場合、コールバックは、すべてのタグなしオブジェクトに対してのみ呼び出されます。パラメータが<code>JVMTI_HEAP_OBJECT_EITHER</code>の場合、コールバックは、タグが付いているかどうかに関係なく、ヒープ内のすべてのオブジェクトに対して呼び出されます。
        <p></p>
        この関数の実行中、ヒープの状態は変化しません。オブジェクトの割当てやガベージ・コレクションは行われず、オブジェクトの状態(保持された値を含む)は変化しません。このため、Javaプログラミング言語コードを実行するスレッド、Javaプログラミング言語コードの実行を再開しようとしているスレッド、およびJNI関数を実行しようとしているスレッドは通常ストールされます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>111</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IterateOverHeap.object_filter">object_filter</code></td><td><code><a href="#jvmtiHeapObjectFilter">jvmtiHeapObjectFilter</a></code></td><td>
	    どのオブジェクトに対してコールバック関数が呼び出されるかを示す。
	  </td>
</tr>
<tr>
<td><code id="IterateOverHeap.heap_object_callback">heap_object_callback</code></td><td><code> <a href="#jvmtiHeapObjectCallback">jvmtiHeapObjectCallback</a> </code></td><td>
	      <a href="#IterateOverHeap.object_filter"><code>object_filter</code></a>に一致する各オブジェクトに対して呼び出される反復関数。
	    <p></p>
</td>
</tr>
<tr>
<td><code id="IterateOverHeap.user_data">user_data</code></td><td><code>const void *</code></td><td>
	    ユーザーが入力し、コールバックに渡されるデータ。 
	  <p></p>エージェントがポインタを渡す。<code>user_data</code>が<code>NULL</code>の場合、<code>NULL</code>がユーザー指定データとして渡される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#IterateOverHeap.object_filter"><code>object_filter</code></a>がjvmtiHeapObjectFilterではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IterateOverHeap.heap_object_callback"><code>heap_object_callback</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IterateOverInstancesOfClass">
<h3>クラスのインスタンスの反復</h3>
<blockquote>
<pre>jvmtiError
IterateOverInstancesOfClass(jvmtiEnv* env,
            jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data)</pre>
</blockquote>
        指定されたクラスのインスタンスになっている、ヒープ内のすべてのオブジェクトに対して反復処理を行います。これには、指定されたクラスの直接のインスタンスと、指定されたクラスのすべてのサブクラスのインスタンスが含まれます。到達可能なオブジェクトも、そうでないオブジェクトも含まれます。
	<p></p>
	<a href="#IterateOverInstancesOfClass.object_filter"><code>object_filter</code></a>パラメータは、どのオブジェクトのためにコールバック関数が呼び出されるかを示します。パラメータが<code>JVMTI_HEAP_OBJECT_TAGGED</code>の場合、コールバックは、すべてのタグ付きオブジェクトに対してのみ呼び出されます。パラメータが<code>JVMTI_HEAP_OBJECT_UNTAGGED</code>の場合、コールバックは、すべてのタグなしオブジェクトに対してのみ呼び出されます。パラメータが<code>JVMTI_HEAP_OBJECT_EITHER</code>の場合、コールバックは、タグが付いているかどうかに関係なく、ヒープ内のすべてのオブジェクトに対して呼び出されます。
	<p></p>
	この関数の実行中、ヒープの状態は変化しません。オブジェクトの割当てやガベージ・コレクションは行われず、オブジェクトの状態(保持された値を含む)は変化しません。このため、Javaプログラミング言語コードを実行するスレッド、Javaプログラミング言語コードの実行を再開しようとしているスレッド、およびJNI関数を実行しようとしているスレッドは通常ストールされます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>112</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a></td><td>
	  <a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      このクラスのオブジェクトに対してのみ反復処理を行う。
	    </td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.object_filter">object_filter</code></td><td><code><a href="#jvmtiHeapObjectFilter">jvmtiHeapObjectFilter</a></code></td><td>
	    どのオブジェクトに対してコールバック関数が呼び出されるかを示す。
	  </td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.heap_object_callback">heap_object_callback</code></td><td><code> <a href="#jvmtiHeapObjectCallback">jvmtiHeapObjectCallback</a> </code></td><td>
	      <a href="#IterateOverInstancesOfClass.object_filter"><code>object_filter</code></a>に一致する各<a href="#IterateOverInstancesOfClass.klass"><code>klass</code></a>インスタンスに対して呼び出される反復関数。
	    <p></p>
</td>
</tr>
<tr>
<td><code id="IterateOverInstancesOfClass.user_data">user_data</code></td><td><code>const void *</code></td><td>
	    ユーザーが入力し、コールバックに渡されるデータ。 
	  <p></p>エージェントがポインタを渡す。<code>user_data</code>が<code>NULL</code>の場合、<code>NULL</code>がユーザー指定データとして渡される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_tag_objects"><code>can_tag_objects</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#IterateOverInstancesOfClass.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#IterateOverInstancesOfClass.object_filter"><code>object_filter</code></a>がjvmtiHeapObjectFilterではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IterateOverInstancesOfClass.heap_object_callback"><code>heap_object_callback</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<p id="local"></p>
<hr noshade size="3">
<h2 align="center">局所変数</h2>局所変数関数:
  <ul>
<li>
<a href="#GetLocalObject">局所変数の取得 - オブジェクト型</a>
</li>
<li>
<a href="#GetLocalInstance">局所インスタンスの取得</a>
</li>
<li>
<a href="#GetLocalInt">局所変数の取得 - 整数型</a>
</li>
<li>
<a href="#GetLocalLong">局所変数の取得 - 長整数型</a>
</li>
<li>
<a href="#GetLocalFloat">局所変数の取得 - 浮動小数点数型</a>
</li>
<li>
<a href="#GetLocalDouble">局所変数の取得 - 倍精度浮動小数点数型</a>
</li>
<li>
<a href="#SetLocalObject">局所変数の設定 - オブジェクト型</a>
</li>
<li>
<a href="#SetLocalInt">局所変数の設定 - 整数型</a>
</li>
<li>
<a href="#SetLocalLong">局所変数の設定 - 長整数型</a>
</li>
<li>
<a href="#SetLocalFloat">局所変数の設定 - 浮動小数点数型</a>
</li>
<li>
<a href="#SetLocalDouble">局所変数の設定 - 倍精度浮動小数点数型</a>
</li>
</ul>
      これらの関数は、局所変数の値を取得または設定するために使います。変数は、変数の値を含んでいるフレームの深さと、そのフレーム内の変数のスロット番号によって識別されます。変数からスロット番号へのマッピングは、関数<a href="#GetLocalVariableTable"><code>GetLocalVariableTable</code></a>を使って取得できます。
    <p></p>
<hr noshade width="100%" size="1" id="GetLocalObject">
<h3>局所変数の取得 - オブジェクト型</h3>
<blockquote>
<pre>jvmtiError
GetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr)</pre>
</blockquote>
	この関数を使うと、型が<code>Object</code>または<code>Object</code>のサブクラスである局所変数の値を取得できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>21</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLocalObject.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetLocalObject.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="GetLocalObject.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="GetLocalObject.value_ptr">value_ptr</code></td><td><code><a href="#jobject">jobject</a>*</code></td><td>
	      戻ったとき、変数の値をポイントする。 
	    <p></p>エージェントは<code>jobject</code>へのポインタを渡す。戻ったとき、<code>jobject</code>が設定されている。<code>value_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
          変数の型が<code>Object</code>でも<code>Object</code>のサブクラスでもない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td> 
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetLocalObject.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetLocalObject.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetLocalObject.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#GetLocalObject.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalObject.value_ptr"><code>value_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetLocalInstance">
<h3>局所インスタンスの取得</h3>
<blockquote>
<pre>jvmtiError
GetLocalInstance(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jobject* value_ptr)</pre>
</blockquote>
        この関数を使うと、静的でないフレームからスロット0 (「<code>this</code>」オブジェクト)の局所オブジェクト変数の値を取得できます。この関数は、ネイティブ・メソッドのフレームから「<code>this</code>」オブジェクトを取得しますが、この場合、<code>GetLocalObject()</code>は<code>JVMTI_ERROR_OPAQUE_FRAME</code>を返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>155</td><td>1.2</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLocalInstance.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetLocalInstance.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="GetLocalInstance.value_ptr">value_ptr</code></td><td><code><a href="#jobject">jobject</a>*</code></td><td>
	      戻ったとき、変数の値をポイントする。 
	    <p></p>エージェントは<code>jobject</code>へのポインタを渡す。戻ったとき、<code>jobject</code>が設定されている。<code>value_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  指定されたフレームが静的なメソッドのフレームである場合。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetLocalInstance.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetLocalInstance.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetLocalInstance.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#GetLocalInstance.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalInstance.value_ptr"><code>value_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetLocalInt">
<h3>局所変数の取得 - 整数型</h3>
<blockquote>
<pre>jvmtiError
GetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr)</pre>
</blockquote>
	この関数を使うと、型が<code>int</code>、<code>short</code>、<code>char</code>、<code>byte</code>、<code>boolean</code>のいずれかである局所変数の値を取得できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>22</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLocalInt.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetLocalInt.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="GetLocalInt.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="GetLocalInt.value_ptr">value_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、変数の値をポイントする。 
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>int</code>、<code>short</code>、<code>char</code>、<code>byte</code>、または<code>boolean</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td> 
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetLocalInt.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetLocalInt.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetLocalInt.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#GetLocalInt.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalInt.value_ptr"><code>value_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetLocalLong">
<h3>局所変数の取得 - 長整数型</h3>
<blockquote>
<pre>jvmtiError
GetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr)</pre>
</blockquote>
	この関数を使うと、型が<code>long</code>である局所変数の値を取得できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>23</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLocalLong.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetLocalLong.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="GetLocalLong.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="GetLocalLong.value_ptr">value_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    戻ったとき、変数の値をポイントする。 
	  <p></p>エージェントは<code>jlong</code>へのポインタを渡す。戻ったとき、<code>jlong</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>long</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td> 
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetLocalLong.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetLocalLong.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetLocalLong.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#GetLocalLong.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalLong.value_ptr"><code>value_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetLocalFloat">
<h3>局所変数の取得 - 浮動小数点数型</h3>
<blockquote>
<pre>jvmtiError
GetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr)</pre>
</blockquote>
	この関数を使うと、型が<code>float</code>である局所変数の値を取得できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>24</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLocalFloat.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetLocalFloat.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="GetLocalFloat.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="GetLocalFloat.value_ptr">value_ptr</code></td><td><code><a href="#jfloat">jfloat</a>*</code></td><td>
	    戻ったとき、変数の値をポイントする。 
	  <p></p>エージェントは<code>jfloat</code>へのポインタを渡す。戻ったとき、<code>jfloat</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>float</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td> 
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetLocalFloat.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetLocalFloat.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetLocalFloat.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#GetLocalFloat.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalFloat.value_ptr"><code>value_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetLocalDouble">
<h3>局所変数の取得 - 倍精度浮動小数点数型</h3>
<blockquote>
<pre>jvmtiError
GetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr)</pre>
</blockquote>
	この関数を使うと、型が<code>long</code>である局所変数の値を取得できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>25</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLocalDouble.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetLocalDouble.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="GetLocalDouble.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="GetLocalDouble.value_ptr">value_ptr</code></td><td><code><a href="#jdouble">jdouble</a>*</code></td><td>
	    戻ったとき、変数の値をポイントする。 
	  <p></p>エージェントは<code>jdouble</code>へのポインタを渡す。戻ったとき、<code>jdouble</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>double</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td> 
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetLocalDouble.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetLocalDouble.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetLocalDouble.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#GetLocalDouble.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalDouble.value_ptr"><code>value_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetLocalObject">
<h3>局所変数の設定 - オブジェクト型</h3>
<blockquote>
<pre>jvmtiError
SetLocalObject(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jobject value)</pre>
</blockquote>
	この関数を使うと、型が<code>Object</code>または<code>Object</code>のサブクラスである局所変数の値を設定できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>26</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetLocalObject.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="SetLocalObject.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="SetLocalObject.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="SetLocalObject.value">value</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      変数の新しい値。
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td>
	  変数の型が<code>Object</code>でも<code>Object</code>のサブクラスでもない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td>
	  指定された<a href="#SetLocalObject.value"><code>value</code></a>と変数の型に互換性がない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#SetLocalObject.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#SetLocalObject.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetLocalObject.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#SetLocalObject.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#SetLocalObject.value"><code>value</code></a>がオブジェクトではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetLocalInt">
<h3>局所変数の設定 - 整数型</h3>
<blockquote>
<pre>jvmtiError
SetLocalInt(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jint value)</pre>
</blockquote>
	この関数を使うと、型が<code>int</code>、<code>short</code>、<code>char</code>、<code>byte</code>、<code>boolean</code>のいずれかである局所変数の値を設定できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>27</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetLocalInt.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="SetLocalInt.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="SetLocalInt.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="SetLocalInt.value">value</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の新しい値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>int</code>、<code>short</code>、<code>char</code>、<code>byte</code>、または<code>boolean</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#SetLocalInt.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#SetLocalInt.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetLocalInt.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#SetLocalInt.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetLocalLong">
<h3>局所変数の設定 - 長整数型</h3>
<blockquote>
<pre>jvmtiError
SetLocalLong(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jlong value)</pre>
</blockquote>
	この関数を使うと、型が<code>long</code>である局所変数の値を設定できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>28</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetLocalLong.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="SetLocalLong.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="SetLocalLong.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="SetLocalLong.value">value</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    変数の新しい値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>long</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#SetLocalLong.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#SetLocalLong.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetLocalLong.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#SetLocalLong.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetLocalFloat">
<h3>局所変数の設定 - 浮動小数点数型</h3>
<blockquote>
<pre>jvmtiError
SetLocalFloat(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jfloat value)</pre>
</blockquote>
	この関数を使うと、型が<code>float</code>である局所変数の値を設定できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>29</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetLocalFloat.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="SetLocalFloat.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="SetLocalFloat.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="SetLocalFloat.value">value</code></td><td><code><a href="#jfloat">jfloat</a></code></td><td>
	    変数の新しい値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>float</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#SetLocalFloat.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#SetLocalFloat.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetLocalFloat.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#SetLocalFloat.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetLocalDouble">
<h3>局所変数の設定 - 倍精度浮動小数点数型</h3>
<blockquote>
<pre>jvmtiError
SetLocalDouble(jvmtiEnv* env,
            jthread thread,
            jint depth,
            jint slot,
            jdouble value)</pre>
</blockquote>
	この関数を使うと、型が<code>double</code>である局所変数の値を設定できます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>30</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetLocalDouble.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    変数の値を含むフレームのスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="SetLocalDouble.depth">depth</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数の値を含むフレームの深さ。
	  </td>
</tr>
<tr>
<td><code id="SetLocalDouble.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    変数のスロット番号。
	  </td>
</tr>
<tr>
<td><code id="SetLocalDouble.value">value</code></td><td><code><a href="#jdouble">jdouble</a></code></td><td>
	    変数の新しい値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_SLOT"><code>JVMTI_ERROR_INVALID_SLOT</code></a></td><td>
	  無効な<code>slot</code>。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_TYPE_MISMATCH"><code>JVMTI_ERROR_TYPE_MISMATCH</code></a></td><td> 
	  変数の型が<code>double</code>ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_OPAQUE_FRAME"><code>JVMTI_ERROR_OPAQUE_FRAME</code></a></td><td>
	  可視のフレームではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#SetLocalDouble.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#SetLocalDouble.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetLocalDouble.depth"><code>depth</code></a>がゼロより小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NO_MORE_FRAMES"><code>JVMTI_ERROR_NO_MORE_FRAMES</code></a></td><td>
	  指定された<a href="#SetLocalDouble.depth"><code>depth</code></a>にスタック・フレームがない。
	  
	</td>
</tr>
</table>
<p id="breakpointCategory"></p>
<hr noshade size="3">
<h2 align="center">ブレークポイント</h2>ブレークポイント関数:
  <ul>
<li>
<a href="#SetBreakpoint">ブレークポイントの設定</a>
</li>
<li>
<a href="#ClearBreakpoint">ブレークポイントの解除</a>
</li>
</ul>
    
<p></p>
<hr noshade width="100%" size="1" id="SetBreakpoint">
<h3>ブレークポイントの設定</h3>
<blockquote>
<pre>jvmtiError
SetBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
	<code>method</code>および<code>location</code>で指定された命令にブレークポイントを設定します。1つの命令に対して設定できるブレークポイントは1つだけです。
	<p></p>
	指定した命令が実行される直前に、<a href="#Breakpoint"><code>Breakpoint</code></a>イベントが生成されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>38</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a></td><td>
	  <a href="#Breakpoint"><code>Breakpoint</code></a>イベントを<a href="#SetBreakpoint">設定</a>し、取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetBreakpoint.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      ブレークポイントを設定するメソッド
	    </td>
</tr>
<tr>
<td><code id="SetBreakpoint.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	    ブレークポイントを設定する命令のインデックス

	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_DUPLICATE"><code>JVMTI_ERROR_DUPLICATE</code></a></td><td> 
	  指定されたバイト・コードにはブレークポイントがすでに設定されている。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#SetBreakpoint.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_LOCATION"><code>JVMTI_ERROR_INVALID_LOCATION</code></a></td><td>
	  <a href="#SetBreakpoint.location"><code>location</code></a>が有効な位置ではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ClearBreakpoint">
<h3>ブレークポイントの解除</h3>
<blockquote>
<pre>jvmtiError
ClearBreakpoint(jvmtiEnv* env,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
	<code>method</code>および<code>location</code>で指定されたバイト・コードに設定されているブレークポイントを解除します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>39</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a></td><td>
	  <a href="#Breakpoint"><code>Breakpoint</code></a>イベントを<a href="#SetBreakpoint">設定</a>し、取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ClearBreakpoint.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      ブレークポイントを解除するメソッド
	    </td>
</tr>
<tr>
<td><code id="ClearBreakpoint.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	    ブレークポイントを解除する命令のインデックス
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_FOUND"><code>JVMTI_ERROR_NOT_FOUND</code></a></td><td> 
	  指定されたバイト・コードにはブレークポイントが設定されていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#ClearBreakpoint.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_LOCATION"><code>JVMTI_ERROR_INVALID_LOCATION</code></a></td><td>
	  <a href="#ClearBreakpoint.location"><code>location</code></a>が有効な位置ではない。
	  
	</td>
</tr>
</table>
<p id="fieldWatch"></p>
<hr noshade size="3">
<h2 align="center">監視されるフィールド</h2>監視されるフィールド関数:
  <ul>
<li>
<a href="#SetFieldAccessWatch">フィールド・アクセスの監視の設定</a>
</li>
<li>
<a href="#ClearFieldAccessWatch">フィールド・アクセスの監視の解除</a>
</li>
<li>
<a href="#SetFieldModificationWatch">フィールド変更の監視の設定</a>
</li>
<li>
<a href="#ClearFieldModificationWatch">フィールド変更の監視の解除</a>
</li>
</ul>
    
<p></p>
<hr noshade width="100%" size="1" id="SetFieldAccessWatch">
<h3>フィールド・アクセスの監視の設定</h3>
<blockquote>
<pre>jvmtiError
SetFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>
	<code>klass</code>および<code>field</code>で指定されたフィールドがアクセスされようとした時点で、<a href="#FieldAccess"><code>FieldAccess</code></a>イベントを生成します。イベントは、<a href="#ClearFieldAccessWatch"><code>ClearFieldAccessWatch</code></a>を使用して取り消されるまで、フィールドがアクセスされるたびに生成されます。Javaプログラミング言語コードまたはJNIコードからのフィールド・アクセスが監視され、他の手段で変更されるフィールドは監視されません。JVM<small style="font-size: xx-small">&nbsp;</small>TIのユーザーは、自分自身のフィールド・アクセスによって監視イベントがトリガーされることに注意してください。1つのフィールドに対し、フィールド・アクセスの監視を1つのみ設定できます。フィールドの変更はアクセスとはみなされません。変更を監視するには<a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>を使用します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>41</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a></td><td>
	  フィールド・アクセスにウォッチポイントを設定できる - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetFieldAccessWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      監視するフィールドを含むクラス
	    </td>
</tr>
<tr>
<td><code id="SetFieldAccessWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      監視するフィールド

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_DUPLICATE"><code>JVMTI_ERROR_DUPLICATE</code></a></td><td> 
	  指定されたフィールドはすでにアクセスが監視されている。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#SetFieldAccessWatch.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#SetFieldAccessWatch.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ClearFieldAccessWatch">
<h3>フィールド・アクセスの監視の解除</h3>
<blockquote>
<pre>jvmtiError
ClearFieldAccessWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>
	<a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>を使って以前に設定した、<code>klass</code>および<code>field</code>で指定されるフィールドに対するフィールド・アクセスの監視を取り消します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>42</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a></td><td>
	  フィールド・アクセスにウォッチポイントを設定できる - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ClearFieldAccessWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      監視するフィールドを含むクラス
	    </td>
</tr>
<tr>
<td><code id="ClearFieldAccessWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      監視するフィールド

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_FOUND"><code>JVMTI_ERROR_NOT_FOUND</code></a></td><td> 
	  指定されたフィールドはアクセスが監視されていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#ClearFieldAccessWatch.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#ClearFieldAccessWatch.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetFieldModificationWatch">
<h3>フィールド変更の監視の設定</h3>
<blockquote>
<pre>jvmtiError
SetFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>
	<code>klass</code>および<code>field</code>で指定されたフィールドが変更されようとした時点で、<a href="#FieldModification"><code>FieldModification</code></a>イベントを生成します。イベントは、<a href="#ClearFieldModificationWatch"><code>ClearFieldModificationWatch</code></a>を使って取り消されるまで、フィールドが変更されるたびに生成されます。Javaプログラミング言語コードまたはJNIコードからのフィールド変更が監視され、ほかの手段で変更されるフィールドは監視されません。JVM<small style="font-size: xx-small">&nbsp;</small>TIのユーザーは、自分自身のフィールド変更によって監視イベントがトリガーされることに注意してください。1つのフィールドに対し、フィールド変更の監視を1つだけ設定できます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>43</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a></td><td>
	  フィールドの変更にウォッチポイントを設定できる - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetFieldModificationWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      監視するフィールドを含むクラス
	    </td>
</tr>
<tr>
<td><code id="SetFieldModificationWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      監視するフィールド

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_DUPLICATE"><code>JVMTI_ERROR_DUPLICATE</code></a></td><td> 
	  指定されたフィールドはすでに変更が監視されている。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#SetFieldModificationWatch.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#SetFieldModificationWatch.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="ClearFieldModificationWatch">
<h3>フィールド変更の監視の解除</h3>
<blockquote>
<pre>jvmtiError
ClearFieldModificationWatch(jvmtiEnv* env,
            jclass klass,
            jfieldID field)</pre>
</blockquote>

	<code>klass</code>および<code>field</code>で指定されるフィールドに対して、<a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>を使って以前に設定したフィールド変更の監視を取り消します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>44</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a></td><td>
	  フィールドの変更にウォッチポイントを設定できる - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ClearFieldModificationWatch.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      監視するフィールドを含むクラス
	    </td>
</tr>
<tr>
<td><code id="ClearFieldModificationWatch.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      監視するフィールド

	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_FOUND"><code>JVMTI_ERROR_NOT_FOUND</code></a></td><td> 
	  指定されたフィールドは変更が監視されていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#ClearFieldModificationWatch.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#ClearFieldModificationWatch.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
</table>
<p id="class"></p>
<hr noshade size="3">
<h2 align="center">クラス</h2>クラス関数:
  <ul>
<li>
<a href="#GetLoadedClasses">ロード済みクラスの取得</a>
</li>
<li>
<a href="#GetClassLoaderClasses">クラス・ローダー・クラスの取得</a>
</li>
<li>
<a href="#GetClassSignature">クラスのシグニチャの取得</a>
</li>
<li>
<a href="#GetClassStatus">クラスのステータスの取得</a>
</li>
<li>
<a href="#GetSourceFileName">ソース・ファイル名の取得</a>
</li>
<li>
<a href="#GetClassModifiers">クラスの修飾子の取得</a>
</li>
<li>
<a href="#GetClassMethods">クラスのメソッドの取得</a>
</li>
<li>
<a href="#GetClassFields">クラスのフィールドの取得</a>
</li>
<li>
<a href="#GetImplementedInterfaces">実装されたインタフェースの取得</a>
</li>
<li>
<a href="#GetClassVersionNumbers">クラス・バージョン番号の取得</a>
</li>
<li>
<a href="#GetConstantPool">定数プールの取得</a>
</li>
<li>
<a href="#IsInterface">インタフェースかどうかの検査</a>
</li>
<li>
<a href="#IsArrayClass">配列クラスかどうかの検査</a>
</li>
<li>
<a href="#IsModifiableClass">変更可能クラスかどうかの検査</a>
</li>
<li>
<a href="#GetClassLoader">クラス・ローダーの取得</a>
</li>
<li>
<a href="#GetSourceDebugExtension">ソース・デバッグ拡張機能の取得</a>
</li>
<li>
<a href="#RetransformClasses">クラスの再変換</a>
</li>
<li>
<a href="#RedefineClasses">クラスの再定義</a>
</li>
</ul>クラスの型:
    <ul>
<li>
<a href="#jvmtiClassDefinition"><code>jvmtiClassDefinition</code></a> - クラスの再定義の説明</li>
</ul>クラスのフラグおよび定数:
    <ul>
<li>
<a href="#jvmtiClassStatus">クラスのステータス・フラグ</a>
</li>
</ul>
    
<p></p>
<hr noshade width="100%" size="1" id="GetLoadedClasses">
<h3>ロード済みクラスの取得</h3>
<blockquote>
<pre>jvmtiError
GetLoadedClasses(jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)</pre>
</blockquote>
	仮想マシンにロードされている全クラスの配列を返します。配列内のクラスの数は<code>class_count_ptr</code>、配列自体は<code>classes_ptr</code>によって返されます。
	<p></p>
	返されるリストには、すべての型の配列クラス(プリミティブ型の配列を含む)が含まれます。プリミティブ・クラス(たとえば、<code>java.lang.Integer.TYPE</code>)は、このリストには含まれ<i>ません</i>。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>78</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLoadedClasses.class_count_ptr">class_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、クラスの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetLoadedClasses.classes_ptr">classes_ptr</code></td><td><code><a href="#jclass">jclass</a>**</code></td><td>
	      戻ったとき、各クラスへの参照(クラスごとに1つずつ)の配列をポイントする。
	    <p></p>エージェントは<code>jclass*</code>へのポインタを渡す。戻ったとき、<code>jclass*</code>は、サイズ<code>*class_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>classes_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLoadedClasses.class_count_ptr"><code>class_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLoadedClasses.classes_ptr"><code>classes_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassLoaderClasses">
<h3>クラス・ローダー・クラスの取得</h3>
<blockquote>
<pre>jvmtiError
GetClassLoaderClasses(jvmtiEnv* env,
            jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr)</pre>
</blockquote>
	このクラス・ローダーが起動ローダーとして記録されているクラスの配列を返します。返される配列内の各クラスは、このクラス・ローダーによって直接定義されて作成されたものか、または別のクラス・ローダーに委譲して作成されたものです。<cite>Java(tm)仮想マシン仕様のセクション5.3</cite>を参照してください。
	<p></p>
	JDK 1.1の実装では、起動クラス・ローダーと定義クラス・ローダーの区別が認識されないため、この関数は、仮想マシンにロードされたすべてのクラスを返します。配列内のクラスの数は<code>class_count_ptr</code>、配列自体は<code>classes_ptr</code>によって返されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>79</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassLoaderClasses.initiating_loader">initiating_loader</code></td><td><code> <a href="#jobject">jobject</a> </code></td><td>
	      起動クラス・ローダー。
	    <p></p>
  <code>initiating_loader</code>が<code>NULL</code>の場合、ブートストラップ・ローダーによって起動されたクラスが返される。
</td>
</tr>
<tr>
<td><code id="GetClassLoaderClasses.class_count_ptr">class_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、クラスの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetClassLoaderClasses.classes_ptr">classes_ptr</code></td><td><code><a href="#jclass">jclass</a>**</code></td><td>
	      戻ったとき、各クラスへの参照(クラスごとに1つずつ)の配列をポイントする。
	    <p></p>エージェントは<code>jclass*</code>へのポインタを渡す。戻ったとき、<code>jclass*</code>は、サイズ<code>*class_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>classes_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassLoaderClasses.class_count_ptr"><code>class_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassLoaderClasses.classes_ptr"><code>classes_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassSignature">
<h3>クラスのシグニチャの取得</h3>
<blockquote>
<pre>jvmtiError
GetClassSignature(jvmtiEnv* env,
            jclass klass,
            char** signature_ptr,
            char** generic_ptr)</pre>
</blockquote>
        <code>klass</code>で指定されたクラスに、<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html#wp16432">JNI型のシグニチャ</a>とクラスのジェネリック・シグニチャを返します。たとえば、<code>java.util.List</code>が<code>"Ljava/util/List;"</code>で、<code>int[]</code>が<code>"[I"</code>の場合、返されるプリミティブ・クラスの名前は、対応するプリミティブ型の型シグニチャ文字になります。たとえば、<code>java.lang.Integer.TYPE</code>は<code>"I"</code>です。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>48</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassSignature.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetClassSignature.signature_ptr">signature_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、クラスのJNI型シグニチャ(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>signature_ptr</code>が<code>NULL</code>の場合、シグニチャは返されない。
</td>
</tr>
<tr>
<td><code id="GetClassSignature.generic_ptr">generic_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、クラスのジェネリック・シグニチャ(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。クラスのジェネリック・シグニチャ属性が存在しない場合は、戻ったとき<code>NULL</code>をポイントする。 
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>generic_ptr</code>が<code>NULL</code>の場合、ジェネリックス・シグニチャは返されない。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetClassSignature.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassStatus">
<h3>クラスのステータスの取得</h3>
<blockquote>
<pre>jvmtiError
GetClassStatus(jvmtiEnv* env,
            jclass klass,
            jint* status_ptr)</pre>
</blockquote>
	クラスのステータスを取得します。次のビットのうち、0個以上のビットがセットされます。
	<blockquote>
<a name="jvmtiClassStatus"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">クラスのステータス・フラグ</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_VERIFIED">JVMTI_CLASS_STATUS_VERIFIED</code></td><td align="right">1</td><td>
	    クラスのバイト・コードが検証された。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_PREPARED">JVMTI_CLASS_STATUS_PREPARED</code></td><td align="right">2</td><td>
	    クラスの準備が完了した。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_INITIALIZED">JVMTI_CLASS_STATUS_INITIALIZED</code></td><td align="right">4</td><td>
	    クラスの初期化が完了した。静的な初期化子が実行された。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_ERROR">JVMTI_CLASS_STATUS_ERROR</code></td><td align="right">8</td><td>
	    初期化中のエラーによりクラスが使用できない。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_ARRAY">JVMTI_CLASS_STATUS_ARRAY</code></td><td align="right">16</td><td>
	    クラスは配列。設定されている場合、その他のすべてのビットはゼロ。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_CLASS_STATUS_PRIMITIVE">JVMTI_CLASS_STATUS_PRIMITIVE</code></td><td align="right">32</td><td>
	    クラスはプリミティブ・クラス(<code>java.lang.Integer.TYPE</code>など)。設定されている場合、その他のすべてのビットはゼロ。
	  </td>
</tr>
</table>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>49</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassStatus.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetClassStatus.status_ptr">status_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、このクラスの現在の状態として<a href="#jvmtiClassStatus">クラスのステータス・フラグ</a>を1つ以上ポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetClassStatus.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassStatus.status_ptr"><code>status_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetSourceFileName">
<h3>ソース・ファイル名の取得</h3>
<blockquote>
<pre>jvmtiError
GetSourceFileName(jvmtiEnv* env,
            jclass klass,
            char** source_name_ptr)</pre>
</blockquote>
	<code>klass</code>で指定されたクラスについて、<code>source_name_ptr</code>を介してソース・ファイル名を返します。返される文字列は、ファイル名だけで、ディレクトリ名は含まれません。 
	<p></p>
	プリミティブ・クラス(たとえば、<code>java.lang.Integer.TYPE</code>)および配列の場合、この関数は<a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a>を返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>50</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_source_file_name"><code>can_get_source_file_name</code></a></td><td>
	  クラスのソース・ファイルの名前を取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetSourceFileName.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetSourceFileName.source_name_ptr">source_name_ptr</code></td><td><code>char**</code></td><td>
	    戻ったとき、クラスのソース・ファイル名(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_source_file_name"><code>can_get_source_file_name</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a></td><td> 
	  クラス情報に、ソース・ファイル名が含まれていない。これには、クラスが配列クラスまたはプリミティブ・クラスである場合が含まれる。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetSourceFileName.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetSourceFileName.source_name_ptr"><code>source_name_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassModifiers">
<h3>クラスの修飾子の取得</h3>
<blockquote>
<pre>jvmtiError
GetClassModifiers(jvmtiEnv* env,
            jclass klass,
            jint* modifiers_ptr)</pre>
</blockquote>
	<code>klass</code>で指定されたクラスのアクセス・フラグを、<code>modifiers_ptr</code>を介して返します。アクセス・フラグは、<cite>Java(tm)仮想マシン仕様の第4章</cite>に定義されています。
	<p></p>
	クラスが配列クラスの場合、そのpublic、privateおよびprotected修飾子は、そのコンポーネント型の修飾子と同じです。プリミティブ型の配列の場合、このコンポーネント型は、プリミティブ・クラスの1つ(たとえば、<code>java.lang.Integer.TYPE</code>)で表現されます。 
	<p></p>
	クラスがプリミティブ・クラスの場合、そのpublic修飾子は常にtrueになります。また、そのprotected修飾子およびprivate修飾子は常にfalseになります。 
	<p></p>
	クラスが配列クラスまたはプリミティブ・クラスの場合、そのfinal修飾子は常にtrueになり、interface修飾子は常にfalseになります。その他の修飾子の値は、この仕様では判定されません。 

      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>51</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassModifiers.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetClassModifiers.modifiers_ptr">modifiers_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、このクラスの現在のアクセス・フラグをポイントする。

	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetClassModifiers.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassModifiers.modifiers_ptr"><code>modifiers_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassMethods">
<h3>クラスのメソッドの取得</h3>
<blockquote>
<pre>jvmtiError
GetClassMethods(jvmtiEnv* env,
            jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr)</pre>
</blockquote>
	<code>klass</code>で指定されたクラスに含まれるメソッドの数を<code>method_count_ptr</code>を介して返し、メソッドIDのリストを<code>methods_ptr</code>を介して返します。メソッドのリストには、本来のメソッドだけでなく、コンストラクタおよびstatic初期化子も含まれます。直接宣言されたメソッドだけが返されます(継承したメソッドは返されない)。配列クラスおよびプリミティブ・クラス(たとえば、<code>java.lang.Integer.TYPE</code>)の場合、空のメソッド・リストが返されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>52</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
          任意の機能
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_maintain_original_method_order"><code>can_maintain_original_method_order</code></a></td><td>
	  クラス・ファイル内に出現する順序でメソッドを返すことができる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassMethods.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetClassMethods.method_count_ptr">method_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、このクラスで宣言されているメソッドの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetClassMethods.methods_ptr">methods_ptr</code></td><td><code><a href="#jmethodID">jmethodID</a>**</code></td><td>
	      戻ったとき、メソッドIDの配列をポイントする。
	    <p></p>エージェントは<code>jmethodID*</code>へのポインタを渡す。戻ったとき、<code>jmethodID*</code>は、サイズ<code>*method_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_NOT_PREPARED"><code>JVMTI_ERROR_CLASS_NOT_PREPARED</code></a></td><td>
	  <a href="#GetClassMethods.klass"><code>klass</code></a>が準備されていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetClassMethods.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassMethods.method_count_ptr"><code>method_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassMethods.methods_ptr"><code>methods_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassFields">
<h3>クラスのフィールドの取得</h3>
<blockquote>
<pre>jvmtiError
GetClassFields(jvmtiEnv* env,
            jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr)</pre>
</blockquote>
	<code>klass</code>で指定されたクラスに含まれるフィールドの数を<code>field_count_ptr</code>を介して返し、フィールドIDのリストを<code>fields_ptr</code>を介して返します。直接宣言されたフィールドだけが返されます(継承したフィールドは返されない)。フィールドは、クラス・ファイル内に出現する順序で返されます。配列クラスおよびプリミティブ・クラス(たとえば、<code>java.lang.Integer.TYPE</code>)の場合、空のフィールド・リストが返されます。JNIを使って、配列の長さを判別してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>53</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassFields.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetClassFields.field_count_ptr">field_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、このクラスで宣言されているフィールドの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetClassFields.fields_ptr">fields_ptr</code></td><td><code><a href="#jfieldID">jfieldID</a>**</code></td><td>
	      戻ったとき、フィールドIDの配列をポイントする。
	    <p></p>エージェントは<code>jfieldID*</code>へのポインタを渡す。戻ったとき、<code>jfieldID*</code>は、サイズ<code>*field_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_NOT_PREPARED"><code>JVMTI_ERROR_CLASS_NOT_PREPARED</code></a></td><td> 
	  <a href="#GetClassFields.klass"><code>klass</code></a>が準備されていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetClassFields.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassFields.field_count_ptr"><code>field_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassFields.fields_ptr"><code>fields_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetImplementedInterfaces">
<h3>実装されたインタフェースの取得</h3>
<blockquote>
<pre>jvmtiError
GetImplementedInterfaces(jvmtiEnv* env,
            jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr)</pre>
</blockquote>
	このクラスの直接のスーパー・インタフェースを返します。クラスに対しては、この関数は、<code>implements</code>節で宣言されているインタフェースを返します。インタフェースに対しては、この関数は、<code>extends</code>節で宣言されているインタフェースを返します。配列クラスおよびプリミティブ・クラス(たとえば、<code>java.lang.Integer.TYPE</code>)の場合、空のインタフェース・リストが返されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>54</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetImplementedInterfaces.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetImplementedInterfaces.interface_count_ptr">interface_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、インタフェースの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetImplementedInterfaces.interfaces_ptr">interfaces_ptr</code></td><td><code><a href="#jclass">jclass</a>**</code></td><td>
	      戻ったとき、インタフェースの配列をポイントする。
	    <p></p>エージェントは<code>jclass*</code>へのポインタを渡す。戻ったとき、<code>jclass*</code>は、サイズ<code>*interface_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>interfaces_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_NOT_PREPARED"><code>JVMTI_ERROR_CLASS_NOT_PREPARED</code></a></td><td> 
	  <a href="#GetImplementedInterfaces.klass"><code>klass</code></a>が準備されていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetImplementedInterfaces.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetImplementedInterfaces.interface_count_ptr"><code>interface_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetImplementedInterfaces.interfaces_ptr"><code>interfaces_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassVersionNumbers">
<h3>クラス・バージョン番号の取得</h3>
<blockquote>
<pre>jvmtiError
GetClassVersionNumbers(jvmtiEnv* env,
            jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr)</pre>
</blockquote>
        <code>klass</code>に指定されたクラスについては、<cite>Java(tm)仮想マシン仕様の第4章</cite>で定義されているように、マイナー・バージョン番号とメジャー・バージョン番号を返します。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>145</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassVersionNumbers.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetClassVersionNumbers.minor_version_ptr">minor_version_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、クラス・ファイル形式の<code>minor_version</code>項目の値をポイントする。注: クラス・ファイル形式との一貫性を保つために、マイナー・バージョン番号が最初のパラメータになっている。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetClassVersionNumbers.major_version_ptr">major_version_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、クラス・ファイル形式の<code>major_version</code>項目の値をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a></td><td> 
	  クラスがプリミティブまたは配列クラスである。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetClassVersionNumbers.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassVersionNumbers.minor_version_ptr"><code>minor_version_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassVersionNumbers.major_version_ptr"><code>major_version_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetConstantPool">
<h3>定数プールの取得</h3>
<blockquote>
<pre>jvmtiError
GetConstantPool(jvmtiEnv* env,
            jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr)</pre>
</blockquote>
	<code>klass</code>で示されたクラスについては、<cite>Java(tm)仮想マシン仕様の第4章</cite>に記載された<code>constant_pool</code>項目の形式で定数プールのrawバイトを返します。定数プールの形式は、クラス・ファイル形式のバージョンによって異なる可能性があるので、<a href="#GetClassVersionNumbers">クラスのメジャー・バージョン番号、マイナー・バージョン番号</a>に互換性があることを確認するようにしてください。
        <p></p>
        返される定数プールのレイアウトや内容が、定義元のクラス・ファイル内の定数プールと同じでないこともあります。GetConstantPool()から返される定数プールのエントリ数は、定義元の定数プールのエントリ数と異なる場合があります。エントリの順序が異なる場合もあります。GetConstantPool()から返される定数プールは、<a href="#GetBytecodes">GetBytecodes()</a>が使用する定数プールに一致します。つまり、GetBytecodes()から返されるバイト・コードに含まれる定数プール・インデックスは、GetConstantPool()から返される定数プールのエントリを参照します。<a href="#RetransformClasses"><code>RetransformClasses</code></a>および<a href="#RedefineClasses"><code>RedefineClasses</code></a>は定数プールを変更できるため、この関数から返される定数プールは、それに応じて変更される可能性があります。したがって、途中でクラスの再変換または再定義が行われた場合は、GetConstantPool()とGetBytecodes()の間の対応関係が維持されません。ある特定のバイト・コードが使用する定数プール・エントリの値は、定義元クラス・ファイルの対応する値に一致します(インデックスが一致しない場合でも)。バイト・コードが直接的にも間接的にも使用しない定数プール・エントリ(注釈に関連付けられているUTF-8文字列など)は、返された定数プール内に存在していなくてもかまいません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>146</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_constant_pool"><code>can_get_constant_pool</code></a></td><td>
	  あるクラスの定数プールを取得できる - <a href="#GetConstantPool"><code>GetConstantPool</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetConstantPool.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetConstantPool.constant_pool_count_ptr">constant_pool_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、定数プール・テーブル内のエントリの数+1をポイントする。これは、クラス・ファイル形式の<code>constant_pool_count</code>項目に対応している。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetConstantPool.constant_pool_byte_count_ptr">constant_pool_byte_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、返されたraw定数プール内のバイト数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetConstantPool.constant_pool_bytes_ptr">constant_pool_bytes_ptr</code></td><td><code>unsigned char**</code></td><td>
	      戻ったとき、raw定数プールをポイントする。これは、クラス・ファイル形式の<code>constant_pool</code>項目で定義されたバイトになる。
	    <p></p>エージェントは<code>unsigned char*</code>へのポインタを渡す。戻ったとき、<code>unsigned char*</code>は、サイズ<code>*constant_pool_byte_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_constant_pool"><code>can_get_constant_pool</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a></td><td> 
	  クラスがプリミティブまたは配列クラスである。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetConstantPool.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetConstantPool.constant_pool_count_ptr"><code>constant_pool_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetConstantPool.constant_pool_byte_count_ptr"><code>constant_pool_byte_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetConstantPool.constant_pool_bytes_ptr"><code>constant_pool_bytes_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IsInterface">
<h3>インタフェースかどうかの検査</h3>
<blockquote>
<pre>jvmtiError
IsInterface(jvmtiEnv* env,
            jclass klass,
            jboolean* is_interface_ptr)</pre>
</blockquote>
	クラス・オブジェクト参照がインタフェースを表しているかどうかを判定します。クラスが実際にインタフェースである場合、<code>jboolean</code>は<code>JNI_TRUE</code>を返し、インタフェースではない場合には<code>JNI_FALSE</code>を返します。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>55</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IsInterface.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="IsInterface.is_interface_ptr">is_interface_ptr</code></td><td><code><a href="#jboolean">jboolean</a>*</code></td><td>
	    戻ったとき、この関数のboolean型の結果をポイントする。

	  <p></p>エージェントは<code>jboolean</code>へのポインタを渡す。戻ったとき、<code>jboolean</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#IsInterface.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IsInterface.is_interface_ptr"><code>is_interface_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IsArrayClass">
<h3>配列クラスかどうかの検査</h3>
<blockquote>
<pre>jvmtiError
IsArrayClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_array_class_ptr)</pre>
</blockquote>
	クラス・オブジェクト参照が配列を表しているかどうかを判定します。<code>jboolean</code>は、クラスが配列である場合は<code>JNI_TRUE</code>になり、そうでない場合は<code>JNI_FALSE</code>になります。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>56</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IsArrayClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="IsArrayClass.is_array_class_ptr">is_array_class_ptr</code></td><td><code><a href="#jboolean">jboolean</a>*</code></td><td>
	    戻ったとき、この関数のboolean型の結果をポイントする。

	  <p></p>エージェントは<code>jboolean</code>へのポインタを渡す。戻ったとき、<code>jboolean</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#IsArrayClass.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IsArrayClass.is_array_class_ptr"><code>is_array_class_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IsModifiableClass">
<h3>変更可能クラスかどうかの検査</h3>
<blockquote>
<pre>jvmtiError
IsModifiableClass(jvmtiEnv* env,
            jclass klass,
            jboolean* is_modifiable_class_ptr)</pre>
</blockquote>
	クラスが変更可能かどうかを判定します。クラスが変更可能である場合(<a href="#IsModifiableClass.is_modifiable_class_ptr"><code>is_modifiable_class_ptr</code></a>が<code>JNI_TRUE</code>を返した場合)、そのクラスは、<a href="#RedefineClasses"><code>RedefineClasses</code></a>を使って再定義したり(エージェントが<a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a>権限を所有していると仮定)、<a href="#RetransformClasses"><code>RetransformClasses</code></a>を使って再変換したり(エージェントが<a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>権限を所有していると仮定)できます。あるクラスが変更不可能である場合(<a href="#IsModifiableClass.is_modifiable_class_ptr"><code>is_modifiable_class_ptr</code></a>が<code>JNI_FALSE</code>を返した場合)、そのクラスは再定義することも再変換することもできません。
        <p></p>
        プリミティブ・クラス(<code>java.lang.Integer.TYPE</code>など)と配列クラスが変更可能になることはありません。 
        <p></p>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>45</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
          任意の機能
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_any_class"><code>can_redefine_any_class</code></a></td><td>
          これを所有すると、すべてのクラス(プリミティブ・クラスと配列クラスは除く)が変更可能になる。
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a></td><td>
          この関数の結果に何の影響も与えない。ただし、<a href="#RedefineClasses"><code>RedefineClasses</code></a>を使ってクラスを変更するには、これを追加で所有している必要があります。
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a></td><td>
          この関数の結果に何の影響も与えない。ただし、<a href="#RetransformClasses"><code>RetransformClasses</code></a>を使ってクラスを変更するには、これを追加で所有している必要があります。
        </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IsModifiableClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="IsModifiableClass.is_modifiable_class_ptr">is_modifiable_class_ptr</code></td><td><code><a href="#jboolean">jboolean</a>*</code></td><td>
	    戻ったとき、この関数のboolean型の結果をポイントする。
	  <p></p>エージェントは<code>jboolean</code>へのポインタを渡す。戻ったとき、<code>jboolean</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#IsModifiableClass.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IsModifiableClass.is_modifiable_class_ptr"><code>is_modifiable_class_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetClassLoader">
<h3>クラス・ローダーの取得</h3>
<blockquote>
<pre>jvmtiError
GetClassLoader(jvmtiEnv* env,
            jclass klass,
            jobject* classloader_ptr)</pre>
</blockquote>
	<code>klass</code>で指定されたクラスのクラス・ローダーの参照を、<code>classloader_ptr</code>を介して返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>57</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetClassLoader.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetClassLoader.classloader_ptr">classloader_ptr</code></td><td><code><a href="#jobject">jobject</a>*</code></td><td>
	      戻ったとき、このクラスをロードしたクラス・ローダーをポイントする。クラスがクラス・ローダーで作成されていない場合、またはクラス・ローダーがブートストラップ・クラス・ローダーでない場合は、<code>NULL</code>をポイントする。
 	    <p></p>エージェントは<code>jobject</code>へのポインタを渡す。戻ったとき、<code>jobject</code>が設定されている。<code>classloader_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetClassLoader.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetClassLoader.classloader_ptr"><code>classloader_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetSourceDebugExtension">
<h3>ソース・デバッグ拡張機能の取得</h3>
<blockquote>
<pre>jvmtiError
GetSourceDebugExtension(jvmtiEnv* env,
            jclass klass,
            char** source_debug_extension_ptr)</pre>
</blockquote>
	<code>klass</code>で指定されたクラスのデバッグ拡張機能を、<code>source_debug_extension_ptr</code>を介して返します。返される文字列には、<code>klass</code>のクラス・ファイルに存在するデバッグ拡張情報がそのまま含まれます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>90</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_source_debug_extension"><code>can_get_source_debug_extension</code></a></td><td>
	  クラスのソース・デバッグ拡張機能を取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetSourceDebugExtension.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetSourceDebugExtension.source_debug_extension_ptr">source_debug_extension_ptr</code></td><td><code>char**</code></td><td>
	    戻ったとき、クラスのデバッグ拡張機能(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_source_debug_extension"><code>can_get_source_debug_extension</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a></td><td> 
	  クラス情報に、デバッグ拡張が含まれていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetSourceDebugExtension.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetSourceDebugExtension.source_debug_extension_ptr"><code>source_debug_extension_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RetransformClasses">
<h3>クラスの再変換</h3>
<blockquote>
<pre>jvmtiError
RetransformClasses(jvmtiEnv* env,
            jint class_count,
            const jclass* classes)</pre>
</blockquote>
        この関数は、すでにロード済みのクラスの<a href="#bci">バイト・コード・インストゥルメンテーション</a>を容易にします。修正しながらデバッグを続けるためにソースから再コンパイルする場合のように、既存のバイト・コードを参照することなしにクラス定義を置換する場合は、代わりに<a href="#RedefineClasses"><code>RedefineClasses</code></a>関数を使用するようにしてください。
        <p></p>
        クラスがはじめてロードされるときや<a href="#RedefineClasses">再定義</a>されるときに、その初期クラス・ファイル・バイトを<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベント経由で変換することができます。この関数は、以前に変換が行われたかどうかには関係なく、変換処理を再実行します。この再変換は次の手順で行われます。
        <ul type="disc">
          
<li>初期クラス・ファイル・バイトから処理が開始されます。 
          </li>
          
<li>前回のロードまたは再定義時に<code>ClassFileLoadHook</code>イベントを受信した<a href="#jvmtiCapabilities.can_retransform_classes">再変換不可能</a>エージェントごとに、エージェントが(<code>new_class_data</code>パラメータ経由で)返したバイトが変換の出力として再利用されます。これは、<code>ClassFileLoadHook</code>イベントがこれらのエージェントに送信<b>されない</b>点を除けば、前回の変換を変更なしに再適用するのと等価です。
          </li>
          
<li><a href="#jvmtiCapabilities.can_retransform_classes">再変換可能</a>エージェントごとに、<code>ClassFileLoadHook</code>イベントが送信されます。これにより、新しい変換を適用できるようになります。
          </li>
          
<li>変換されたクラス・ファイル・バイトがクラスの新しい定義としてインストールされます。
          </li>
        
</ul>
        詳細は、<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントを参照してください。
        <p></p>
        初期クラス・ファイル・バイトは、<code>ClassLoader.defineClass</code>または<code>RedefineClasses</code>に渡されたバイト(変換適用前)を表しますが、両者が厳密に一致しない可能性もあります。定数プールが、<a href="#GetConstantPool"><code>GetConstantPool</code></a>で説明した点で異なる可能性があります。メソッドのバイトコード内の定数プール・インデックスは対応します。一部の属性が存在しない可能性があります。メソッドの順序など、順序が意味を持たない場合には、順序が維持されないことがあります。
        <p></p>
        再変換を行うと、新しいバージョンのメソッドがインストールされる可能性があります。古いバージョンのメソッドは<a href="#obsoleteMethods">廃止</a>される可能性があります。以降の呼出しでは新しいバージョンのメソッドが使用されます。メソッドがアクティブなスタック・フレームを持つ場合、それらのアクティブなスタック・フレームは元のメソッド・バージョンのバイト・コードを引き続き実行します。 
        <p></p>
        この関数により、一般的なJVMセマンティックスのもとで行われる以外の初期化は起こりません。つまり、クラスを再変換しても、そのクラスの初期化は実行されません。staticフィールドの値は、呼出し前の状態のままです。
        <p></p>
        スレッドを中断する必要はありません。
        <p></p>
        クラス内のブレークポイントは解除されます。
        <p></p>
        属性はすべて更新されます。
        <p></p>
        再変換されたクラスのインスタンスは影響を受けません。各フィールドは以前の値を維持します。インスタンス上の<a href="#GetTag">タグ</a>も影響を受けません。
        <p></p>
        この呼び出しへの応答として、<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>以外のイベントが送信されることはありません。
        <p></p>
        再変換では、メソッド本体、定数プール、属性を変更できます。再変換では、フィールドまたはメソッドの追加、削除、名前変更、メソッドのシグネチャの変更、修飾子の変更、継承の変更を行わないようにする必要があります。これらの制限は将来のバージョンで解除される可能性があります。未サポートの再変換が試みられた場合に返されるエラー・コードについては、後述のエラー戻り値の説明を参照してください。クラス・ファイルのバイトが検証またはインストールされるのは、それらのバイトが<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントのチェーンを通過した後なので、返されるエラー・コードは再変換の結果を反映したものになります。<code>JVMTI_ERROR_NONE</code>以外のエラー・コードが返された場合、再変換対象のどのクラスについても、新しい定義がインストールされることはありません。この関数が(エラー・コード<code>JVMTI_ERROR_NONE</code>で)復帰した場合は、再変換対象のすべてのクラスで新しい定義がインストールされます。        
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>152</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a></td><td>
	  <a href="#RetransformClasses"><code>RetransformClasses</code></a>でクラスを再変換できる。特定の実装によって適用されるこの権限の制限(「<a href="#capability">権限</a>」セクションを参照)に加え、この権限は、この環境で<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントがはじめて有効化される前に設定する必要がある。<code>ClassFileLoadHook</code>がはじめて有効化された時点でこの権限を所有している環境を「<i>再変換可能</i>」と呼ぶ。<code>ClassFileLoadHook</code>がはじめて有効化された時点でこの権限を所有していない環境を「<i>再変換不可能</i>」と呼ぶ。
	</td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
          任意の機能
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_retransform_any_class"><code>can_retransform_any_class</code></a></td><td>
          <a href="#RetransformClasses"><code>RetransformClasses</code></a>を任意のクラスで呼び出せる(<a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>も設定する必要がある)
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RetransformClasses.class_count">class_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
            再変換されるクラスの数。
          </td>
</tr>
<tr>
<td><code id="RetransformClasses.classes">classes</code></td><td><code>const <a href="#jclass">jclass</a>*</code></td><td>
            再変換されるクラスの配列。
          <p></p>エージェントは<code>jclass</code>の<code>class_count</code>要素の配列を渡す。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNMODIFIABLE_CLASS"><code>JVMTI_ERROR_UNMODIFIABLE_CLASS</code></a></td><td>
          変更不可能なクラスが<a href="#RetransformClasses.classes"><code>classes</code></a>に含まれている。<a href="#IsModifiableClass"><code>IsModifiableClass</code></a>を参照。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
          <a href="#RetransformClasses.classes"><code>classes</code></a>のいずれかが有効なクラスでない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_VERSION"><code>JVMTI_ERROR_UNSUPPORTED_VERSION</code></a></td><td>
          再変換されるクラス・ファイルのバージョン番号がこのVMでサポートされていない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS_FORMAT"><code>JVMTI_ERROR_INVALID_CLASS_FORMAT</code></a></td><td>
          再変換されるクラス・ファイルの形式が正しくない(VMは<code>ClassFormatError</code>を返す)。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION"><code>JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION</code></a></td><td>
          再変換されるクラス・ファイルの定義が循環定義になる(VMは<code>ClassCircularityError</code>を返す)。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_FAILS_VERIFICATION"><code>JVMTI_ERROR_FAILS_VERIFICATION</code></a></td><td>
          再変換されるクラス・ファイルのバイトが検証に失敗する。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NAMES_DONT_MATCH"><code>JVMTI_ERROR_NAMES_DONT_MATCH</code></a></td><td>
          再変換されるクラス・ファイル内で定義されたクラス名が、旧クラス・オブジェクト内の名前と異なる。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED</code></a></td><td>
          再変換されるクラス・ファイルでメソッドの追加が必要。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED</code></a></td><td>
          再変換されるクラス・ファイルによってフィールドが変更される。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED</code></a></td><td>
          再変換されるクラス・ファイルの直接スーパー・クラスが異なる、または直接実装されているインタフェースが異なる。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED</code></a></td><td>
          再変換されるクラス・ファイルでは旧クラスのバージョンで宣言したメソッドを宣言しない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED</code></a></td><td>
          再変換されたクラス・ファイルに異なるクラス修飾子が含まれている。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED</code></a></td><td>
          再変換されるクラス・ファイルのメソッドの修飾子が旧クラスのバージョンの修飾子と異なる。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
          <a href="#RetransformClasses.class_count"><code>class_count</code></a>が<code>0</code>より小さい。
          
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
          <a href="#RetransformClasses.classes"><code>classes</code></a>が<code>NULL</code>。
          
        </td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RedefineClasses">
<h3>クラスの再定義</h3>
<blockquote>
<pre>typedef struct {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
} jvmtiClassDefinition;</pre>
<pre>jvmtiError
RedefineClasses(jvmtiEnv* env,
            jint class_count,
            const jvmtiClassDefinition* class_definitions)</pre>
</blockquote>
	指定されたクラスはすべて、提供される定義に従って再定義されます。この関数は、あるクラスの定義を新しい定義で置き換える場合に使用されます(修正継続方式のデバッグで必要になる)。<a href="#bci">バイトコード・インストゥルメンテーション</a>のように、既存のクラス・ファイル・バイトを変換する必要がある場合は、<a href="#RetransformClasses"><code>RetransformClasses</code></a>を使用すべきです。
	<p></p>
	再定義を行うと、新しいバージョンのメソッドがインストールされる可能性があります。古いバージョンのメソッドは<a href="#obsoleteMethods">廃止</a>される可能性があります。以降の呼出しでは新しいバージョンのメソッドが使用されます。メソッドがアクティブなスタック・フレームを持つ場合、それらのアクティブなスタック・フレームは元のメソッド・バージョンのバイト・コードを引き続き実行します。スタック・フレームをリセットする必要がある場合は、廃止されたバージョンのメソッドを含むフレームを、<a href="#PopFrame"><code>PopFrame</code></a>を使用してポップします。
	<p></p>
	この関数により、一般的なJVMセマンティックスのもとで行われる以外の初期化は起こりません。つまり、クラスの再定義では、クラスの初期化子は実行されません。staticフィールドの値は、呼出し前の状態のままです。
	<p></p>
	スレッドを中断する必要はありません。
	<p></p>
	クラス内のブレークポイントは解除されます。
	<p></p>
	属性はすべて更新されます。
	<p></p>
        再定義されたクラスのインスタンスは影響を受けません。各フィールドは以前の値を維持します。インスタンス上の<a href="#GetTag">タグ</a>も影響を受けません。
	<p></p>
	この呼出しにこたえて、JVM<small style="font-size: xx-small">&nbsp;</small>TIイベントとして<a href="#ClassFileLoadHook">クラス・ファイル・ロードフック</a>が送信されます(有効な場合)。しかし、その他のJVM<small style="font-size: xx-small">&nbsp;</small>TIイベントは送信されません。
        <p></p>
        再定義では、メソッド本体、定数プール、属性を変更できます。再定義では、フィールドまたはメソッドの追加、削除、名前変更、メソッドのシグネチャの変更、修飾子の変更、継承の変更を行わないようにする必要があります。これらの制限は将来のバージョンで解除される可能性があります。未サポートの再定義が試みられた場合に返されるエラー・コードについては、後述のエラー戻り値の説明を参照してください。クラス・ファイルのバイトが検証またはインストールされるのは、それらのバイトが<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントのチェーンを通過した後なので、返されるエラー・コードは、<a href="#RedefineClasses.class_definitions"><code>class_definitions</code></a>に渡されたバイトに適用された変換の結果を反映したものになります。<code>JVMTI_ERROR_NONE</code>以外のエラー・コードが返された場合、再定義対象のどのクラスについても、新しい定義がインストールされることはありません。この関数が(エラー・コード<code>JVMTI_ERROR_NONE</code>で)復帰した場合は、再定義対象のすべてのクラスで新しい定義がインストールされます。        
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>87</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a></td><td>
	  <a href="#RedefineClasses"><code>RedefineClasses</code></a>でクラスを再定義できる。
	</td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
          任意の機能
        </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_redefine_any_class"><code>can_redefine_any_class</code></a></td><td>
          プリミティブ・クラスでも配列クラスでもない任意のクラスを変更(再変換または再定義)できる。<a href="#IsModifiableClass"><code>IsModifiableClass</code></a>を参照。
	</td>
</tr>
</table>
<p id="jvmtiClassDefinition"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiClassDefinition</code> - クラスの再定義の説明</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiClassDefinition.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      このクラスのクラス・オブジェクト
	    </td>
</tr>
<tr>
<td><code id="jvmtiClassDefinition.class_byte_count">class_byte_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    定義するクラスのバイト数(下)
	  </td>
</tr>
<tr>
<td><code id="jvmtiClassDefinition.class_bytes">class_bytes</code></td><td><code>const unsigned char*</code></td><td>
            クラスを定義するバイト(<cite>Java(tm)仮想マシン仕様の第4章</cite>を参照)
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RedefineClasses.class_count">class_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    <code>class_definitions</code>で指定されたクラスの数
	  </td>
</tr>
<tr>
<td><code id="RedefineClasses.class_definitions">class_definitions</code></td><td><code>const <a href="#jvmtiClassDefinition">jvmtiClassDefinition</a>*</code></td><td>
	    新しいクラス定義の配列
	  <p></p>エージェントは<code>jvmtiClassDefinition</code>の<code>class_count</code>要素の配列を渡す。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_redefine_classes"><code>can_redefine_classes</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <code>class_bytes</code>のいずれかが<code>NULL</code>の場合。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNMODIFIABLE_CLASS"><code>JVMTI_ERROR_UNMODIFIABLE_CLASS</code></a></td><td>
	  <code>class_definitions</code>の要素は変更できない。<a href="#IsModifiableClass"><code>IsModifiableClass</code></a>を参照。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <code>class_definitions</code>の要素が有効なクラスではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_VERSION"><code>JVMTI_ERROR_UNSUPPORTED_VERSION</code></a></td><td>
	  新しいクラス・ファイルのバージョンがこのVMでサポートされていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS_FORMAT"><code>JVMTI_ERROR_INVALID_CLASS_FORMAT</code></a></td><td>
	  新しいクラス・ファイルの形式が正しくない(VMは<code>ClassFormatError</code>を返す)。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION"><code>JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION</code></a></td><td>
	  新しいクラス・ファイルの定義が循環定義になる(VMは<code>ClassCircularityError</code>を返す)。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_FAILS_VERIFICATION"><code>JVMTI_ERROR_FAILS_VERIFICATION</code></a></td><td>
	  クラス・バイトが検証に失敗する。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NAMES_DONT_MATCH"><code>JVMTI_ERROR_NAMES_DONT_MATCH</code></a></td><td>
	  新しいクラス・ファイル内で定義されたクラス名が、旧クラス・オブジェクト内の名前と異なる。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED</code></a></td><td>
	  新しいクラス・ファイルでメソッドの追加が必要。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED</code></a></td><td>
	  新しいクラスのバージョンによってフィールドが変更される。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED</code></a></td><td>
	  新しいクラスのバージョンの直接スーパー・クラスが異なる、または直接実装されているインタフェースが異なる。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED</code></a></td><td>
	  新しいクラスのバージョンでは旧クラスのバージョンで宣言したメソッドを宣言しない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED</code></a></td><td>
	  新しいクラスのバージョンの修飾子が異なる。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED"><code>JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED</code></a></td><td>
	  新しいクラスのバージョンのメソッドの修飾子が旧クラスのバージョンの修飾子と異なる。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#RedefineClasses.class_count"><code>class_count</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#RedefineClasses.class_definitions"><code>class_definitions</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="object"></p>
<hr noshade size="3">
<h2 align="center">オブジェクト</h2>オブジェクト関数:
  <ul>
<li>
<a href="#GetObjectSize">オブジェクト・サイズの取得</a>
</li>
<li>
<a href="#GetObjectHashCode">オブジェクトのハッシュ・コードの取得</a>
</li>
<li>
<a href="#GetObjectMonitorUsage">オブジェクトのモニターの利用情報を取得</a>
</li>
</ul>オブジェクトの型:
    <ul>
<li>
<a href="#jvmtiMonitorUsage"><code>jvmtiMonitorUsage</code></a> - オブジェクト・モニターの使用情報</li>
</ul>
<p></p>
<hr noshade width="100%" size="1" id="GetObjectSize">
<h3>オブジェクト・サイズの取得</h3>
<blockquote>
<pre>jvmtiError
GetObjectSize(jvmtiEnv* env,
            jobject object,
            jlong* size_ptr)</pre>
</blockquote>
	<code>object</code>で示されたオブジェクトについて、オブジェクトのサイズを<code>size_ptr</code>経由で返します。このサイズは、このオブジェクトにより消費されるストレージの容量の実装固有の近似値です。これは、オブジェクトのオーバーヘッドの一部または全部を含む可能性があるため、実装内での比較には役立ちますが、実装間の比較には役立ちません。この近似値は、JVMの単一呼出しの間に変わる可能性があります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>154</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetObjectSize.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      照会するオブジェクト。
	    </td>
</tr>
<tr>
<td><code id="GetObjectSize.size_ptr">size_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    戻ったとき、オブジェクトのサイズ(バイト単位)をポイントする。
	  <p></p>エージェントは<code>jlong</code>へのポインタを渡す。戻ったとき、<code>jlong</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#GetObjectSize.object"><code>object</code></a>がオブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetObjectSize.size_ptr"><code>size_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetObjectHashCode">
<h3>オブジェクトのハッシュ・コードの取得</h3>
<blockquote>
<pre>jvmtiError
GetObjectHashCode(jvmtiEnv* env,
            jobject object,
            jint* hash_code_ptr)</pre>
</blockquote>
	<code>object</code>で示されたオブジェクトについて、ハッシュ・コードを<code>hash_code_ptr</code>経由で返します。このハッシュ・コードを使えばオブジェクト参照のハッシュ・テーブルを保守できますが、その場合、一部の実装でパフォーマンスが大幅に低下する可能性があります。ほとんどの場合、オブジェクトに情報を関連付けるための手段としては、<a href="#Heap">タグ</a>のほうが効率的です。この関数は、特定のオブジェクトに対し、その存続期間を通じて同じハッシュ・コード値を保証します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>58</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetObjectHashCode.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      照会するオブジェクト。
	    </td>
</tr>
<tr>
<td><code id="GetObjectHashCode.hash_code_ptr">hash_code_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、オブジェクトのハッシュ・コードをポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#GetObjectHashCode.object"><code>object</code></a>がオブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetObjectHashCode.hash_code_ptr"><code>hash_code_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetObjectMonitorUsage">
<h3>オブジェクトのモニターの利用情報を取得</h3>
<blockquote>
<pre>typedef struct {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
} jvmtiMonitorUsage;</pre>
<pre>jvmtiError
GetObjectMonitorUsage(jvmtiEnv* env,
            jobject object,
            jvmtiMonitorUsage* info_ptr)</pre>
</blockquote>
	オブジェクトのモニターに関する情報を取得します。<a href="#jvmtiMonitorUsage"><code>jvmtiMonitorUsage</code></a>構造体のフィールドに、モニターの使用に関する情報が入ります。
	  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>59</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_monitor_info"><code>can_get_monitor_info</code></a></td><td>
        <a href="#GetObjectMonitorUsage"><code>GetObjectMonitorUsage</code></a>が可能
      </td>
</tr>
</table>
<p id="jvmtiMonitorUsage"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiMonitorUsage</code> - オブジェクト・モニターの使用情報</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.owner">owner</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      このモニターを所有しているスレッド。このモニターが使用されていない場合は<code>NULL</code>
	    </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.entry_count">entry_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    このモニターを所有するスレッドがモニターを使用した回数
	  </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.waiter_count">waiter_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    このモニターを所有する順番を待っているスレッドの数
	  </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.waiters">waiters</code></td><td><code><a href="#jthread">jthread</a>*</code></td><td>
	      <code>waiter_count</code>待機スレッド
	    </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.notify_waiter_count">notify_waiter_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    このモニターから通知を受ける待機スレッドの数
	  </td>
</tr>
<tr>
<td><code id="jvmtiMonitorUsage.notify_waiters">notify_waiters</code></td><td><code><a href="#jthread">jthread</a>*</code></td><td>
	      通知を待っている<code>notify_waiter_count</code>スレッド
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetObjectMonitorUsage.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	      照会するオブジェクト。
	    </td>
</tr>
<tr>
<td><code id="GetObjectMonitorUsage.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiMonitorUsage">jvmtiMonitorUsage</a>*</code></td><td>
	    戻ったとき、指定されたオブジェクトのモニター情報が入っている。
	  <p></p>エージェントは<code>jvmtiMonitorUsage</code>へのポインタを渡す。戻ったとき、<code>jvmtiMonitorUsage</code>が設定されている。<code>jvmtiMonitorUsage</code>のフィールド<code>owner</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。<code>jvmtiMonitorUsage</code>の<code>waiters</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiMonitorUsage</code>のフィールド<code>waiters</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。<code>jvmtiMonitorUsage</code>の<code>notify_waiters</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiMonitorUsage</code>のフィールド<code>notify_waiters</code>で返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_monitor_info"><code>can_get_monitor_info</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_OBJECT"><code>JVMTI_ERROR_INVALID_OBJECT</code></a></td><td>
	  <a href="#GetObjectMonitorUsage.object"><code>object</code></a>がオブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetObjectMonitorUsage.info_ptr"><code>info_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="fieldCategory"></p>
<hr noshade size="3">
<h2 align="center">フィールド</h2>フィールド関数:
  <ul>
<li>
<a href="#GetFieldName">フィールドの名前とシグニチャの取得</a>
</li>
<li>
<a href="#GetFieldDeclaringClass">フィールドの宣言クラスの取得</a>
</li>
<li>
<a href="#GetFieldModifiers">フィールドの修飾子の取得</a>
</li>
<li>
<a href="#IsFieldSynthetic">合成フィールドかどうかの検査</a>
</li>
</ul>
    
<p></p>
<hr noshade width="100%" size="1" id="GetFieldName">
<h3>フィールドの名前とシグニチャの取得</h3>
<blockquote>
<pre>jvmtiError
GetFieldName(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)</pre>
</blockquote>
	<a href="#GetFieldName.klass"><code>klass</code></a>と<a href="#GetFieldName.field"><code>field</code></a>で指定されたフィールドについて、名前を<a href="#GetFieldName.name_ptr"><code>name_ptr</code></a>で返し、シグニチャを<a href="#GetFieldName.signature_ptr"><code>signature_ptr</code></a>で返します。
	<p></p>
        フィールドのシグニチャはJNI仕様で定義されており、<cite>Java(tm)仮想マシン仕様のセクション4.3.2</cite>では<code>field descriptors</code>と呼ばれています。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>60</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetFieldName.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するフィールドのクラス。
	    </td>
</tr>
<tr>
<td><code id="GetFieldName.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      照会するフィールド。
	    </td>
</tr>
<tr>
<td><code id="GetFieldName.name_ptr">name_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、フィールド名(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>name_ptr</code>が<code>NULL</code>の場合、名前は返されない。
</td>
</tr>
<tr>
<td><code id="GetFieldName.signature_ptr">signature_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、フィールドのシグニチャ(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>signature_ptr</code>が<code>NULL</code>の場合、シグニチャは返されない。
</td>
</tr>
<tr>
<td><code id="GetFieldName.generic_ptr">generic_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、フィールドのジェネリック・シグニチャ(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。フィールドのジェネリック・シグニチャ属性が存在しない場合は、戻ったとき<code>NULL</code>をポイントする。 
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>generic_ptr</code>が<code>NULL</code>の場合、ジェネリックス・シグニチャは返されない。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetFieldName.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#GetFieldName.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetFieldDeclaringClass">
<h3>フィールドの宣言クラスの取得</h3>
<blockquote>
<pre>jvmtiError
GetFieldDeclaringClass(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr)</pre>
</blockquote>
	<code>klass</code>と<code>field</code>で指定されたフィールドについて、そのフィールドを定義しているクラスを<code>declaring_class_ptr</code>を介して返します。宣言しているクラスは、<code>klass</code>、スーパー・クラス、または実装されたインタフェースのいずれかです。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>61</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetFieldDeclaringClass.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetFieldDeclaringClass.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      照会するフィールド。
	    </td>
</tr>
<tr>
<td><code id="GetFieldDeclaringClass.declaring_class_ptr">declaring_class_ptr</code></td><td><code><a href="#jclass">jclass</a>*</code></td><td>
	      戻ったとき、宣言するクラスをポイントする。
	    <p></p>エージェントは<code>jclass</code>へのポインタを渡す。戻ったとき、<code>jclass</code>が設定されている。<code>declaring_class_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetFieldDeclaringClass.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#GetFieldDeclaringClass.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetFieldDeclaringClass.declaring_class_ptr"><code>declaring_class_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetFieldModifiers">
<h3>フィールドの修飾子の取得</h3>
<blockquote>
<pre>jvmtiError
GetFieldModifiers(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jint* modifiers_ptr)</pre>
</blockquote>
	<code>klass</code>と<code>field</code>で指定されたフィールドのアクセス・フラグを、<code>modifiers_ptr</code>を介して返します。アクセス・フラグは、<cite>Java(tm)仮想マシン仕様の第4章</cite>に定義されています。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>62</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetFieldModifiers.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するクラス。
	    </td>
</tr>
<tr>
<td><code id="GetFieldModifiers.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      照会するフィールド。
	    </td>
</tr>
<tr>
<td><code id="GetFieldModifiers.modifiers_ptr">modifiers_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、アクセス・フラグをポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#GetFieldModifiers.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#GetFieldModifiers.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetFieldModifiers.modifiers_ptr"><code>modifiers_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IsFieldSynthetic">
<h3>合成フィールドかどうかの検査</h3>
<blockquote>
<pre>jvmtiError
IsFieldSynthetic(jvmtiEnv* env,
            jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr)</pre>
</blockquote>
	<code>klass</code>および<code>field</code>で指定されたフィールドに対し、<code>is_synthetic_ptr</code>を介してそのフィールドが合成であるかどうかを示す値を返します。合成フィールドはコンパイラによって生成されますが、元のソース・コード内には存在しません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>63</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a></td><td>
	  フィールドまたはメソッドが合成であるかどうかをテストできます - <a href="#IsFieldSynthetic"><code>IsFieldSynthetic</code></a>と<a href="#IsMethodSynthetic"><code>IsMethodSynthetic</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IsFieldSynthetic.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	      照会するフィールドのクラス。
	    </td>
</tr>
<tr>
<td><code id="IsFieldSynthetic.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	      照会するフィールド。
	    </td>
</tr>
<tr>
<td><code id="IsFieldSynthetic.is_synthetic_ptr">is_synthetic_ptr</code></td><td><code><a href="#jboolean">jboolean</a>*</code></td><td>
	    戻ったとき、この関数のboolean型の結果をポイントする。
	  <p></p>エージェントは<code>jboolean</code>へのポインタを渡す。戻ったとき、<code>jboolean</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_CLASS"><code>JVMTI_ERROR_INVALID_CLASS</code></a></td><td>
	  <a href="#IsFieldSynthetic.klass"><code>klass</code></a>がクラス・オブジェクトでないか、クラスがアンロードされている。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_FIELDID"><code>JVMTI_ERROR_INVALID_FIELDID</code></a></td><td>
	  <a href="#IsFieldSynthetic.field"><code>field</code></a>がjfieldIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IsFieldSynthetic.is_synthetic_ptr"><code>is_synthetic_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="method"></p>
<hr noshade size="3">
<h2 align="center">メソッド</h2>メソッド関数:
  <ul>
<li>
<a href="#GetMethodName">メソッドの名前とシグニチャの取得</a>
</li>
<li>
<a href="#GetMethodDeclaringClass">メソッドの宣言クラスの取得</a>
</li>
<li>
<a href="#GetMethodModifiers">メソッドの修飾子の取得</a>
</li>
<li>
<a href="#GetMaxLocals">局所変数の取得</a>
</li>
<li>
<a href="#GetArgumentsSize">引数のサイズの取得</a>
</li>
<li>
<a href="#GetLineNumberTable">行番号テーブルの取得</a>
</li>
<li>
<a href="#GetMethodLocation">メソッドの配置位置の取得</a>
</li>
<li>
<a href="#GetLocalVariableTable">局所変数テーブルの取得</a>
</li>
<li>
<a href="#GetBytecodes">バイト・コードの取得</a>
</li>
<li>
<a href="#IsMethodNative">ネイティブ・メソッドかどうかの検査</a>
</li>
<li>
<a href="#IsMethodSynthetic">合成メソッドかどうかの検査</a>
</li>
<li>
<a href="#IsMethodObsolete">廃棄されたメソッドかどうかの検査</a>
</li>
<li>
<a href="#SetNativeMethodPrefix">ネイティブ・メソッド接頭辞の設定</a>
</li>
<li>
<a href="#SetNativeMethodPrefixes">複数のネイティブ・メソッド接頭辞の設定</a>
</li>
</ul>メソッドの型:
    <ul>
<li>
<a href="#jvmtiLineNumberEntry"><code>jvmtiLineNumberEntry</code></a> - 行番号テーブルのエントリ</li>
<li>
<a href="#jvmtiLocalVariableEntry"><code>jvmtiLocalVariableEntry</code></a> - 局所変数テーブルのエントリ</li>
</ul>
      これらの関数は、あるメソッド(<a href="#jmethodID"><code>jmethodID</code></a>として表現)に関する情報を提供したり、メソッドの処理方法を設定したりします。
    <h4 id="obsoleteMethods">廃止メソッド</h4>
      関数<a href="#RetransformClasses"><code>RetransformClasses</code></a>および<a href="#RedefineClasses"><code>RedefineClasses</code></a>を呼び出すと、新しいバージョンのメソッドがインストールされます。元のメソッド・バージョンと新しいメソッド・バージョンが同等と見なされるのは、次のような場合です。
      <ul type="disc">
        
<li>双方のメソッドのバイト・コードが同じ(定数プールのインデックスを除く) </li>
        
<li>参照定数が等しい。</li>
      
</ul>
      新しいメソッド・バージョンと等価でない元のメソッド・バージョンは「廃止」と呼ばれ、新しいメソッドIDが割り当てられます。そして、元のメソッドIDは新しいメソッド・バージョンを指すようになります。廃止されたメソッドIDかどうかをテストするには、<a href="#IsMethodObsolete"><code>IsMethodObsolete</code></a>を使用します。
    <p></p>
<hr noshade width="100%" size="1" id="GetMethodName">
<h3>メソッドの名前とシグニチャの取得</h3>
<blockquote>
<pre>jvmtiError
GetMethodName(jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドの名前を<code>name_ptr</code>を介して返し、メソッドのシグニチャを<code>signature_ptr</code>を介して返します。
        <p></p>
        メソッドのシグニチャはJNI仕様で定義されており、<cite>Java(tm)仮想マシン仕様のセクション4.3.3</cite>では<code>method descriptors</code>と呼ばれています。<i>Java言語仕様</i>に定義されたメソッドのシグニチャとは異なる点に注意してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>64</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetMethodName.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetMethodName.name_ptr">name_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、メソッド名(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>name_ptr</code>が<code>NULL</code>の場合、名前は返されない。
</td>
</tr>
<tr>
<td><code id="GetMethodName.signature_ptr">signature_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、メソッド・シグニチャ(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>signature_ptr</code>が<code>NULL</code>の場合、シグニチャは返されない。
</td>
</tr>
<tr>
<td><code id="GetMethodName.generic_ptr">generic_ptr</code></td><td><code> char **</code></td><td>
	    戻ったとき、メソッドのジェネリック・シグニチャ(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。メソッドのジェネリック・シグニチャ属性が存在しない場合は、戻ったとき<code>NULL</code>をポイントする。 
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>generic_ptr</code>が<code>NULL</code>の場合、ジェネリックス・シグニチャは返されない。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetMethodName.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetMethodDeclaringClass">
<h3>メソッドの宣言クラスの取得</h3>
<blockquote>
<pre>jvmtiError
GetMethodDeclaringClass(jvmtiEnv* env,
            jmethodID method,
            jclass* declaring_class_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドを定義するクラスを、<code>declaring_class_ptr</code>を介して返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>65</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetMethodDeclaringClass.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetMethodDeclaringClass.declaring_class_ptr">declaring_class_ptr</code></td><td><code><a href="#jclass">jclass</a>*</code></td><td>
	      戻ったとき、宣言するクラスをポイントする。
	    <p></p>エージェントは<code>jclass</code>へのポインタを渡す。戻ったとき、<code>jclass</code>が設定されている。<code>declaring_class_ptr</code>から返されるオブジェクトはJNIローカル参照であり、<a href="#refs">管理</a>する必要がある。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetMethodDeclaringClass.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetMethodDeclaringClass.declaring_class_ptr"><code>declaring_class_ptr</code></a>が<code>NULL</code>。
	    
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetMethodModifiers">
<h3>メソッドの修飾子の取得</h3>
<blockquote>
<pre>jvmtiError
GetMethodModifiers(jvmtiEnv* env,
            jmethodID method,
            jint* modifiers_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドのアクセス・フラグを、<code>modifiers_ptr</code>を介して返します。アクセス・フラグは、<cite>Java(tm)仮想マシン仕様の第4章</cite>に定義されています。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>66</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetMethodModifiers.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetMethodModifiers.modifiers_ptr">modifiers_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、アクセス・フラグをポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetMethodModifiers.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetMethodModifiers.modifiers_ptr"><code>modifiers_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetMaxLocals">
<h3>局所変数の取得</h3>
<blockquote>
<pre>jvmtiError
GetMaxLocals(jvmtiEnv* env,
            jmethodID method,
            jint* max_ptr)</pre>
</blockquote>
	  <code>method</code>で指定されたメソッドによって使用される局所変数(呼出し時にメソッドにパラメータを渡すために使用される局所変数を含む)のスロット数を返します。 
	  <p></p>
	  <cite>Java(tm)仮想マシン仕様のセクション4.7.3</cite>の<code>max_locals</code>の説明を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>68</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetMaxLocals.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetMaxLocals.max_ptr">max_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、局所変数のスロットの最大数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetMaxLocals.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a></td><td>
	  <a href="#GetMaxLocals.method"><code>method</code></a>はネイティブ・メソッド。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetMaxLocals.max_ptr"><code>max_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetArgumentsSize">
<h3>引数のサイズの取得</h3>
<blockquote>
<pre>jvmtiError
GetArgumentsSize(jvmtiEnv* env,
            jmethodID method,
            jint* size_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドの引数によって使用される局所変数のスロット数を、<code>max_ptr</code>を介して返します。なお、2ワードの引数は、スロットを2つ使用します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>69</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetArgumentsSize.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetArgumentsSize.size_ptr">size_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、引数のスロットの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetArgumentsSize.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a></td><td>
	  <a href="#GetArgumentsSize.method"><code>method</code></a>はネイティブ・メソッド。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetArgumentsSize.size_ptr"><code>size_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetLineNumberTable">
<h3>行番号テーブルの取得</h3>
<blockquote>
<pre>typedef struct {
    jlocation start_location;
    jint line_number;
} jvmtiLineNumberEntry;</pre>
<pre>jvmtiError
GetLineNumberTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドについて、ソース行番号のエントリから成るテーブルを返します。テーブルのサイズは<code>entry_count_ptr</code>、テーブル自体は<code>table_ptr</code>を介して返されます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>70</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_line_numbers"><code>can_get_line_numbers</code></a></td><td>
	  メソッドの行番号テーブルを取得できる
	</td>
</tr>
</table>
<p id="jvmtiLineNumberEntry"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiLineNumberEntry</code> - 行番号テーブルのエントリ</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiLineNumberEntry.start_location">start_location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	    行を開始する<a href="#jlocation"><code>jlocation</code></a>
	  </td>
</tr>
<tr>
<td><code id="jvmtiLineNumberEntry.line_number">line_number</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    行番号
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLineNumberTable.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetLineNumberTable.entry_count_ptr">entry_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、テーブル内のエントリの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetLineNumberTable.table_ptr">table_ptr</code></td><td><code><a href="#jvmtiLineNumberEntry">jvmtiLineNumberEntry</a>**</code></td><td>
	    戻ったとき、行番号テーブルのポインタをポイントする。
	  <p></p>エージェントは<code>jvmtiLineNumberEntry*</code>へのポインタを渡す。戻ったとき、<code>jvmtiLineNumberEntry*</code>は、サイズ<code>*entry_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_line_numbers"><code>can_get_line_numbers</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a></td><td> 
	  クラスの情報に行番号が含まれていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetLineNumberTable.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a></td><td>
	  <a href="#GetLineNumberTable.method"><code>method</code></a>はネイティブ・メソッド。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLineNumberTable.entry_count_ptr"><code>entry_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLineNumberTable.table_ptr"><code>table_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetMethodLocation">
<h3>メソッドの配置位置の取得</h3>
<blockquote>
<pre>jvmtiError
GetMethodLocation(jvmtiEnv* env,
            jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドについて、その開始アドレスと終了アドレスを<code>start_location_ptr</code>と<code>end_location_ptr</code>を介して返します。従来のバイト・コード・インデックス・スキーマでは、<code>start_location_ptr</code>は常にゼロを、<code>end_location_ptr</code>は常にバイト・コードから1を引いた値をポイントします。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>71</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetMethodLocation.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetMethodLocation.start_location_ptr">start_location_ptr</code></td><td><code><a href="#jlocation">jlocation</a>*</code></td><td>
	    戻ったとき、最初の位置をポイントする。位置情報が得られない場合は<code>-1</code>をポイントする。情報が使用可能で、<a href="#GetJLocationFormat"><code>GetJLocationFormat</code></a>から<a href="#JVMTI_JLOCATION_JVMBCI"><code>JVMTI_JLOCATION_JVMBCI</code></a>が返される場合、これは常にゼロになる。
	  <p></p>エージェントは<code>jlocation</code>へのポインタを渡す。戻ったとき、<code>jlocation</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetMethodLocation.end_location_ptr">end_location_ptr</code></td><td><code><a href="#jlocation">jlocation</a>*</code></td><td>
	    戻ったとき、最後の位置をポイントする。位置情報が得られない場合は<code>-1</code>をポイントする。
	  <p></p>エージェントは<code>jlocation</code>へのポインタを渡す。戻ったとき、<code>jlocation</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a></td><td> 
	  クラス情報にメソッドのサイズが含まれていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetMethodLocation.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a></td><td>
	  <a href="#GetMethodLocation.method"><code>method</code></a>はネイティブ・メソッド。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetMethodLocation.start_location_ptr"><code>start_location_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetMethodLocation.end_location_ptr"><code>end_location_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetLocalVariableTable">
<h3>局所変数テーブルの取得</h3>
<blockquote>
<pre>typedef struct {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
} jvmtiLocalVariableEntry;</pre>
<pre>jvmtiError
GetLocalVariableTable(jvmtiEnv* env,
            jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)</pre>
</blockquote>
	局所変数の情報を返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>72</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a></td><td>
	  局所変数を設定し、取得できる
	</td>
</tr>
</table>
<p id="jvmtiLocalVariableEntry"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiLocalVariableEntry</code> - 局所変数テーブルのエントリ</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.start_location">start_location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	    この局所変数がはじめて有効になるコード配列インデックス(つまり、この局所変数はそこで値を持っていなければならない)。
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.length">length</code></td><td><code><a href="#jint">jint</a></code></td><td>
            この局所変数の有効部分の長さ。この局所変数が有効である最後のコード配列インデックスは、<code>start_location+length</code>になる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.name">name</code></td><td><code>char*</code></td><td>
	    局所変数名。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.signature">signature</code></td><td><code>char*</code></td><td>
	    局所変数の型のシグネチャ。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。このシグネチャの形式は、<cite>Java™仮想マシン仕様の4.3.2章</cite>で定義された形式と同じになる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.generic_signature">generic_signature</code></td><td><code>char*</code></td><td>
	    局所変数のジェネリック・シグネチャ。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。ジェネリック型でないすべての局所変数について、このフィールドの値は<code>NULL</code>になる。
	  </td>
</tr>
<tr>
<td><code id="jvmtiLocalVariableEntry.slot">slot</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    局所変数のスロット。「<a href="#local">局所変数</a>」を参照。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetLocalVariableTable.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetLocalVariableTable.entry_count_ptr">entry_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、テーブル内のエントリの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetLocalVariableTable.table_ptr">table_ptr</code></td><td><code><a href="#jvmtiLocalVariableEntry">jvmtiLocalVariableEntry</a>**</code></td><td>
	    戻ったとき、局所変数テーブルのエントリの配列をポイントする。
	  <p></p>エージェントは<code>jvmtiLocalVariableEntry*</code>へのポインタを渡す。戻ったとき、<code>jvmtiLocalVariableEntry*</code>は、サイズ<code>*entry_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiLocalVariableEntry</code>の<code>name</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiLocalVariableEntry</code>の<code>signature</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiLocalVariableEntry</code>の<code>generic_signature</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_access_local_variables"><code>can_access_local_variables</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ABSENT_INFORMATION"><code>JVMTI_ERROR_ABSENT_INFORMATION</code></a></td><td>
	  クラス情報に局所変数の情報が含まれていない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetLocalVariableTable.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a></td><td>
	  <a href="#GetLocalVariableTable.method"><code>method</code></a>はネイティブ・メソッド。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalVariableTable.entry_count_ptr"><code>entry_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetLocalVariableTable.table_ptr"><code>table_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetBytecodes">
<h3>バイト・コードの取得</h3>
<blockquote>
<pre>jvmtiError
GetBytecodes(jvmtiEnv* env,
            jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドを実装するバイト・コードを返します。バイト・コードの数は、<code>bytecode_count_ptr</code>を介して返されます。バイト・コード自体は、<code>bytecodes_ptr</code>を介して返されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>75</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_bytecodes"><code>can_get_bytecodes</code></a></td><td>
	  メソッド<a href="#GetBytecodes"><code>GetBytecodes</code></a>のバイト・コードを取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetBytecodes.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="GetBytecodes.bytecode_count_ptr">bytecode_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、バイト・コードの配列の長さをポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetBytecodes.bytecodes_ptr">bytecodes_ptr</code></td><td><code>unsigned char**</code></td><td>
	    戻ったとき、バイト・コード配列へのポインタをポイントする。
	  <p></p>エージェントは<code>unsigned char*</code>へのポインタを渡す。戻ったとき、<code>unsigned char*</code>は、サイズ<code>*bytecode_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_bytecodes"><code>can_get_bytecodes</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#GetBytecodes.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NATIVE_METHOD"><code>JVMTI_ERROR_NATIVE_METHOD</code></a></td><td>
	  <a href="#GetBytecodes.method"><code>method</code></a>はネイティブ・メソッド。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetBytecodes.bytecode_count_ptr"><code>bytecode_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetBytecodes.bytecodes_ptr"><code>bytecodes_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IsMethodNative">
<h3>ネイティブ・メソッドかどうかの検査</h3>
<blockquote>
<pre>jvmtiError
IsMethodNative(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_native_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドがネイティブ・メソッドかどうかを表す値を、<code>is_native_ptr</code>を介して返します。
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>76</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IsMethodNative.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="IsMethodNative.is_native_ptr">is_native_ptr</code></td><td><code><a href="#jboolean">jboolean</a>*</code></td><td>
	    戻ったとき、この関数のboolean型の結果をポイントする。
	  <p></p>エージェントは<code>jboolean</code>へのポインタを渡す。戻ったとき、<code>jboolean</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#IsMethodNative.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IsMethodNative.is_native_ptr"><code>is_native_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IsMethodSynthetic">
<h3>合成メソッドかどうかの検査</h3>
<blockquote>
<pre>jvmtiError
IsMethodSynthetic(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_synthetic_ptr)</pre>
</blockquote>
	<code>method</code>で指定されたメソッドが合成メソッドかどうかを表す値を、<code>is_synthetic_ptr</code>を介して返します。合成メソッドは、コンパイラによって生成されますが、元のソース・コード内には存在しません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>77</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a></td><td>
	  フィールドまたはメソッドが合成であるかどうかをテストできます - <a href="#IsFieldSynthetic"><code>IsFieldSynthetic</code></a>と<a href="#IsMethodSynthetic"><code>IsMethodSynthetic</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IsMethodSynthetic.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッド。
	    </td>
</tr>
<tr>
<td><code id="IsMethodSynthetic.is_synthetic_ptr">is_synthetic_ptr</code></td><td><code><a href="#jboolean">jboolean</a>*</code></td><td>
	    戻ったとき、この関数のboolean型の結果をポイントする。
	  <p></p>エージェントは<code>jboolean</code>へのポインタを渡す。戻ったとき、<code>jboolean</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_synthetic_attribute"><code>can_get_synthetic_attribute</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#IsMethodSynthetic.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IsMethodSynthetic.is_synthetic_ptr"><code>is_synthetic_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="IsMethodObsolete">
<h3>廃棄されたメソッドかどうかの検査</h3>
<blockquote>
<pre>jvmtiError
IsMethodObsolete(jvmtiEnv* env,
            jmethodID method,
            jboolean* is_obsolete_ptr)</pre>
</blockquote>
        メソッドIDが<a href="#obsoleteMethods">廃止</a>メソッド・バージョンを参照しているかどうかを判定します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>91</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="IsMethodObsolete.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	      照会するメソッドID。
	    </td>
</tr>
<tr>
<td><code id="IsMethodObsolete.is_obsolete_ptr">is_obsolete_ptr</code></td><td><code><a href="#jboolean">jboolean</a>*</code></td><td>
	    戻ったとき、この関数のboolean型の結果をポイントする。
	  <p></p>エージェントは<code>jboolean</code>へのポインタを渡す。戻ったとき、<code>jboolean</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_METHODID"><code>JVMTI_ERROR_INVALID_METHODID</code></a></td><td>
	  <a href="#IsMethodObsolete.method"><code>method</code></a>がjmethodIDではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#IsMethodObsolete.is_obsolete_ptr"><code>is_obsolete_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetNativeMethodPrefix">
<h3>ネイティブ・メソッド接頭辞の設定</h3>
<blockquote>
<pre>jvmtiError
SetNativeMethodPrefix(jvmtiEnv* env,
            const char* prefix)</pre>
</blockquote>
	この関数は、名前に接頭辞を適用して再試行できるようにすることにより、ネイティブ・メソッド解決のエラー処理を変更します。これを<a href="#ClassFileLoadHook">ClassFileLoadHookイベント</a>と組み合わせて使用すれば、ネイティブ・メソッドの<a href="#bci">計測</a>が可能になります。
        <p></p>
        ネイティブ・メソッドはバイト・コードを持たないので、直接計測できません。したがって、計測可能なネイティブでないメソッドでネイティブ・メソッドをラップする必要があります。たとえば次を考えます。
        <blockquote>
<pre>
native boolean foo(int x);</pre>
</blockquote>
        
<p></p>
        これが次のようになるように、(ClassFileLoadHookイベントを使って)クラス・ファイルを変換できます。
        <blockquote>
<pre>
boolean foo(int x) {
  <i>... record entry to foo ...</i>
  return wrapped_foo(x);
}

native boolean wrapped_foo(int x);</pre>
</blockquote>
        
<p></p>
        ここでfooは、接頭辞「wrapped_」が付加された実際のネイティブ・メソッドのラッパーになっています。ただし、「wrapped_」は既存のメソッドの名前の一部として使用されている可能性があるため、接頭辞としてはよい選択肢ではありません。「$$$MyAgentWrapped$$$_」のような接頭辞の方が適切ですが、そうするとこの例が読みにくくなってしまいます。
        <p></p>
        ラッパーによってネイティブ・メソッド呼出しのデータ収集が可能になりますが、次に問題となるのは、ラップされたメソッドとネイティブ実装との関連付けです。つまり、メソッド<code>wrapped_foo</code>を次のようなネイティブ実装<code>foo</code>に解決する必要があります。
        <blockquote>
<pre>
Java_somePackage_someClass_foo(JNIEnv* env, jint x)</pre>
</blockquote>
        
<p></p>
        この関数を使えば、接頭辞を指定し、適切な解決が行われるようにできます。具体的には、標準の解決が失敗した場合に、接頭辞を考慮して再び解決が試みられます。解決方法は2つあります。JNI関数<code>RegisterNatives</code>による明示的な解決と、通常の自動解決です。<code>RegisterNatives</code>の場合、VMは次の関連付けを試みます。
        <blockquote>
<pre>
method(foo) -&gt; nativeImplementation(foo)</pre>
</blockquote>
        
<p></p>
        これに失敗すると、指定された接頭辞をメソッド名の先頭に追加して解決が再試行され、次のような正しい解決が得られます。
        <blockquote>
<pre>
method(wrapped_foo) -&gt; nativeImplementation(foo)</pre>
</blockquote>
        
<p></p>
        自動解決の場合、VMは次を試みます。
        <blockquote>
<pre>
method(wrapped_foo) -&gt; nativeImplementation(wrapped_foo)</pre>
</blockquote>
        
<p></p>
        これに失敗すると、指定された接頭辞を実装名から削除して解決が再試行され、次の正しい解決が得られます。
        <blockquote>
<pre>
method(wrapped_foo) -&gt; nativeImplementation(foo)</pre>
</blockquote>
        
<p></p>
        接頭辞が使用されるのは標準の解決が失敗した場合だけなので、ネイティブ・メソッドのラップは選択的に行えます。
        <p></p>
        各JVM<small style="font-size: xx-small">&nbsp;</small>TI環境は独立しており、それぞれが独自のバイト・コード変換を行えるため、複数の層のラッパーが適用される可能性があります。したがって、環境ごとに異なる接頭辞が必要になります。変換は順番に適用されるため、接頭辞を適用する場合、接頭辞は変換と同じ順番で適用されます。変換の適用順については、<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントを参照してください。つまり、3つの環境がラッパーを適用した場合、<code>foo</code>は<code>$env3_$env2_$env1_foo</code>のようになります。しかし、たとえば2番目の環境が<code>foo</code>にラッパーを適用しなかった場合は、単に<code>$env3_$env1_foo</code>となります。接頭辞のシーケンスを効率的に決定できるようにするため、途中の接頭辞は、そのネイティブでないラッパーが存在する場合にのみ適用されます。つまりこの例では、<code>$env1_foo</code>がネイティブ・メソッドでなくても、<code>$env1_foo</code>が存在するため<code>$env1_</code>接頭辞が適用されます。
        <p></p>
        接頭辞は解決時に使用されますが、その解決はいつでも遅延される可能性があります。したがって、ネイティブ・メソッドの接頭辞は、対応する接頭辞付きのネイティブ・メソッドが存在しているかぎり、設定されたままにしておく必要があります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>73</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a></td><td>
	  ネイティブ・メソッドを解決できない場合に適用すべき接頭辞を設定できる - <a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>および<a href="#SetNativeMethodPrefixes"><code>SetNativeMethodPrefixes</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetNativeMethodPrefix.prefix">prefix</code></td><td><code>const char *</code></td><td>
	    適用する接頭辞。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  <p></p>エージェントは、<code>char</code>の配列を渡す。<code>prefix</code>が<code>NULL</code>の場合、この環境の既存の接頭辞が取り消される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetNativeMethodPrefixes">
<h3>複数のネイティブ・メソッド接頭辞の設定</h3>
<blockquote>
<pre>jvmtiError
SetNativeMethodPrefixes(jvmtiEnv* env,
            jint prefix_count,
            char** prefixes)</pre>
</blockquote>
	 通常のエージェントの場合、<a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>が、ネイティブ・メソッドの接頭辞設定に必要とされるすべての機能を提供します。複数の独立したクラス・ファイル変換を実行するメタエージェント(別の層のエージェントのプロキシとしてのエージェントなど)の場合、この関数を使うと、各変換に独自の接頭辞を割り当てることができます。接頭辞は、指定された順番で適用され、<a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>で説明した、複数のJVM<small style="font-size: xx-small">&nbsp;</small>TI環境からの接頭辞の適用方法と同じ方法で処理されます。
         <p></p>
         以前の接頭辞はすべて置換されます。したがって、<a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>に<code>0</code>を指定してこの関数を呼び出すと、この環境の接頭辞機能が無効になります。
         <p></p>
         
<a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>とこの関数が、接頭辞を設定するための2つの方法です。1つの接頭辞を指定して<code>SetNativeMethodPrefix</code>を呼び出すのは、<a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>に<code>1</code>を指定してこの関数を呼び出すのと同じです。<code>NULL</code>を指定して<code>SetNativeMethodPrefix</code>を呼び出すのは、<a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>に<code>0</code>を指定してこの関数を呼び出すのと同じです。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>74</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a></td><td>
	  ネイティブ・メソッドを解決できない場合に適用すべき接頭辞を設定できる - <a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>および<a href="#SetNativeMethodPrefixes"><code>SetNativeMethodPrefixes</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetNativeMethodPrefixes.prefix_count">prefix_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
	      適用する接頭辞の数。
	    </td>
</tr>
<tr>
<td><code id="SetNativeMethodPrefixes.prefixes">prefixes</code></td><td><code> char **</code></td><td>
	    この環境で適用する接頭辞。それぞれ<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  <p></p>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_set_native_method_prefix"><code>can_set_native_method_prefix</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetNativeMethodPrefixes.prefix_count"><code>prefix_count</code></a>が<code>0</code>より小さい。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#SetNativeMethodPrefixes.prefixes"><code>prefixes</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="RawMonitors"></p>
<hr noshade size="3">
<h2 align="center">rawモニター</h2>rawモニター関数:
  <ul>
<li>
<a href="#CreateRawMonitor">rawモニターの作成</a>
</li>
<li>
<a href="#DestroyRawMonitor">rawモニターの破棄</a>
</li>
<li>
<a href="#RawMonitorEnter">rawモニターの開始</a>
</li>
<li>
<a href="#RawMonitorExit">rawモニターの終了</a>
</li>
<li>
<a href="#RawMonitorWait">rawモニターの待機</a>
</li>
<li>
<a href="#RawMonitorNotify">rawモニターの通知</a>
</li>
<li>
<a href="#RawMonitorNotifyAll">rawモニターの通知(すべて)</a>
</li>
</ul>
<p></p>
<hr noshade width="100%" size="1" id="CreateRawMonitor">
<h3>rawモニターの作成</h3>
<blockquote>
<pre>jvmtiError
CreateRawMonitor(jvmtiEnv* env,
            const char* name,
            jrawMonitorID* monitor_ptr)</pre>
</blockquote>
	rawモニターを作成します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>31</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="CreateRawMonitor.name">name</code></td><td><code>const char*</code></td><td>
	    モニターを識別する名前。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  <p></p>エージェントは、<code>char</code>の配列を渡す。 </td>
</tr>
<tr>
<td><code id="CreateRawMonitor.monitor_ptr">monitor_ptr</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a>*</code></td><td>
	    戻ったとき、作成されたモニターをポイントする。
	  <p></p>エージェントは<code>jrawMonitorID</code>へのポインタを渡す。戻ったとき、<code>jrawMonitorID</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#CreateRawMonitor.name"><code>name</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#CreateRawMonitor.monitor_ptr"><code>monitor_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="DestroyRawMonitor">
<h3>rawモニターの破棄</h3>
<blockquote>
<pre>jvmtiError
DestroyRawMonitor(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	rawモニターを破棄します。破棄されるモニターがこのスレッドによって入力された場合、破棄される前に終了します。破棄されるモニターが別のスレッドによって入力された場合、エラーが返され、モニターの破棄は行われません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>32</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="DestroyRawMonitor.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a></code></td><td>
	    モニター
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a></td><td> 
	  モニターの所有者ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a></td><td>
	  <a href="#DestroyRawMonitor.monitor"><code>monitor</code></a>がjrawMonitorIDではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RawMonitorEnter">
<h3>rawモニターの開始</h3>
<blockquote>
<pre>jvmtiError
RawMonitorEnter(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	rawモニターの排他的所有権を取得します。同じスレッドで複数回モニターを入力することができます。スレッドは、モニターを入力回数分だけ<a href="#RawMonitorExit">終了</a>する必要があります。モニターが<code>OnLoad</code> (接続されたスレッドが生成される前)の段階で入力され、接続されたスレッドが生成された時点で終了していない場合、入力はメイン・スレッドで行われたと認識されます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>33</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RawMonitorEnter.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a></code></td><td>
	    モニター
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a></td><td>
	  <a href="#RawMonitorEnter.monitor"><code>monitor</code></a>がjrawMonitorIDではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RawMonitorExit">
<h3>rawモニターの終了</h3>
<blockquote>
<pre>jvmtiError
RawMonitorExit(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	rawモニターの排他的所有権を解放します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>34</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RawMonitorExit.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a></code></td><td>
	    モニター
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a></td><td> 
	  モニターの所有者ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a></td><td>
	  <a href="#RawMonitorExit.monitor"><code>monitor</code></a>がjrawMonitorIDではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RawMonitorWait">
<h3>rawモニターの待機</h3>
<blockquote>
<pre>jvmtiError
RawMonitorWait(jvmtiEnv* env,
            jrawMonitorID monitor,
            jlong millis)</pre>
</blockquote>
        rawモニターの通知を待ちます。
        <p></p>
        別のスレッドが指定されたrawモニターの<a href="#RawMonitorNotify"><code>RawMonitorNotify</code></a>または<a href="#RawMonitorNotifyAll"><code>RawMonitorNotifyAll</code></a>を呼び出すか、指定された<a href="#RawMonitorWait.millis">timeout</a>が経過するまで、現在のスレッドを待機させます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>35</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RawMonitorWait.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a></code></td><td>
	    モニター
	  </td>
</tr>
<tr>
<td><code id="RawMonitorWait.millis">millis</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    タイム・アウト(ミリ秒単位)。タイム・アウトがゼロの場合、実際の時間は考慮されず、スレッドは単に通知されるまで待機する。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a></td><td> 
	  モニターの所有者ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INTERRUPT"><code>JVMTI_ERROR_INTERRUPT</code></a></td><td> 
	  待機中に割込みが発生したため、再試行の必要あり。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a></td><td>
	  <a href="#RawMonitorWait.monitor"><code>monitor</code></a>がjrawMonitorIDではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RawMonitorNotify">
<h3>rawモニターの通知</h3>
<blockquote>
<pre>jvmtiError
RawMonitorNotify(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	rawモニターを待機中の1つのスレッドに通知します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>36</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RawMonitorNotify.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a></code></td><td>
	    モニター
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a></td><td>
	  モニターの所有者ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a></td><td>
	  <a href="#RawMonitorNotify.monitor"><code>monitor</code></a>がjrawMonitorIDではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RawMonitorNotifyAll">
<h3>rawモニターの通知(すべて)</h3>
<blockquote>
<pre>jvmtiError
RawMonitorNotifyAll(jvmtiEnv* env,
            jrawMonitorID monitor)</pre>
</blockquote>
	rawモニターを待機中のすべてのスレッドに通知します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>37</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RawMonitorNotifyAll.monitor">monitor</code></td><td><code><a href="#jrawMonitorID">jrawMonitorID</a></code></td><td>
	    モニター
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_MONITOR_OWNER"><code>JVMTI_ERROR_NOT_MONITOR_OWNER</code></a></td><td> 
	  モニターの所有者ではない。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_MONITOR"><code>JVMTI_ERROR_INVALID_MONITOR</code></a></td><td>
	  <a href="#RawMonitorNotifyAll.monitor"><code>monitor</code></a>がjrawMonitorIDではない。
	  
	</td>
</tr>
</table>
<p id="jniIntercept"></p>
<hr noshade size="3">
<h2 align="center">JNI関数の遮断</h2>JNI関数の遮断関数:
  <ul>
<li>
<a href="#SetJNIFunctionTable">JNI関数テーブルの設定</a>
</li>
<li>
<a href="#GetJNIFunctionTable">JNI関数テーブルの取得</a>
</li>
</ul>
      Java Native Interface (JNI)関数テーブルの操作により、JNI関数呼出しの遮断および再送信の機能を提供します。『<i>Java Native Interface仕様</i>』の「<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">JNI関数</a>」の説明を参照してください。
      <p></p>
      次に、カウント参照の作成順にJNI呼び出し<code>NewGlobalRef</code>を遮断する例を示します。
      <blockquote>
<pre>
JNIEnv original_jni_Functions;
JNIEnv redirected_jni_Functions;
int my_global_ref_count = 0;

jobject
MyNewGlobalRef(JNIEnv *jni_env, jobject lobj) {
   ++my_global_ref_count;
   return originalJNIFunctions-&gt;NewGlobalRef(env, lobj);
}

void
myInit() {
   jvmtiError err;

   err = (*jvmti_env)-&gt;GetJNIFunctionTable(jvmti_env, &amp;original_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   err = (*jvmti_env)-&gt;GetJNIFunctionTable(jvmti_env, &amp;redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
   redirectedJNIFunctions-&gt;NewGlobalRef = MyNewGlobalRef;
      err = (*jvmti_env)-&gt;SetJNIFunctionTable(jvmti_env, redirected_jni_Functions);
   if (err != JVMTI_ERROR_NONE) {
      die();
   }
}
      </pre>
</blockquote>
      <code>myInit</code>を呼び出したあと、ユーザーのJNIコードが実行され、新しいグローバル参照を作成する呼出しが行われることがあります。この呼出しは、通常のJNI実装ではなく、<code>myNewGlobalRef</code>に渡されます。データの収集後も通常のJNI関数を呼び出せるように、元の関数テーブルのコピーは保持されます。また、上書きされないJNI関数の動作は、通常どおりです。
      
    <p></p>
<hr noshade width="100%" size="1" id="SetJNIFunctionTable">
<h3>JNI関数テーブルの設定</h3>
<blockquote>
<pre>jvmtiError
SetJNIFunctionTable(jvmtiEnv* env,
            const jniNativeInterface* function_table)</pre>
</blockquote>
        現在および将来のすべてのJNI環境のJNI関数テーブルを設定します。このため、将来のJNI呼出しはすべて、指定された関数に渡されます。この関数に渡す関数テーブルを取得するには、<a href="#GetJNIFunctionTable"><code>GetJNIFunctionTable</code></a>を使用します。この関数が有効になるためには、更新されたテーブル・エントリがJNIクライアントで使用される必要があります。このテーブルは<code>const</code>として定義されるため、コンパイラによっては最適化によってテーブルへのアクセス機能が除去され、その結果、この関数が無効になる可能性があります。テーブルはコピーされます。テーブルのローカル・コピーを変更しても、何の効果もありません。この関数の影響を受けるのは関数テーブルのみであり、環境の他の側面はすべて何の影響も受けません。<a href="#jniIntercept">前述</a>の例を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>120</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetJNIFunctionTable.function_table">function_table</code></td><td><code>const <a href="#jniNativeInterface">jniNativeInterface</a> *</code></td><td>
	    新しいJNI関数テーブルをポイントする。
	  <p></p>エージェントは<code>jniNativeInterface</code>へのポインタを渡す。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#SetJNIFunctionTable.function_table"><code>function_table</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetJNIFunctionTable">
<h3>JNI関数テーブルの取得</h3>
<blockquote>
<pre>jvmtiError
GetJNIFunctionTable(jvmtiEnv* env,
            jniNativeInterface** function_table)</pre>
</blockquote>
        JNI関数テーブルを取得します。JNI関数テーブルは、割り当てられたメモリーにコピーされます。<a href="#SetJNIFunctionTable"><code>SetJNIFunctionTable</code></a>が呼び出されていた場合、(元の関数テーブルではなく)変更後の関数テーブルが返されます。コピーされるのは関数テーブルのみであり、環境の他の側面はコピーされません。<a href="#jniIntercept">前述</a>の例を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>121</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetJNIFunctionTable.function_table">function_table</code></td><td><code> <a href="#jniNativeInterface">jniNativeInterface</a> **</code></td><td>
	    戻ったとき、<code>*function_table</code>は新しく割り当てられたJNI関数テーブルのコピーをポイントする。
	  <p></p>エージェントは<code>jniNativeInterface*</code>へのポインタを渡す。戻り時に、<code>jniNativeInterface*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetJNIFunctionTable.function_table"><code>function_table</code></a>が<code>NULL</code>。
          
	</td>
</tr>
</table>
<p id="eventManagement"></p>
<hr noshade size="3">
<h2 align="center">イベント管理</h2>イベント管理関数:
  <ul>
<li>
<a href="#SetEventCallbacks">イベント・コールバックの設定</a>
</li>
<li>
<a href="#SetEventNotificationMode">イベント通知モードの設定</a>
</li>
<li>
<a href="#GenerateEvents">イベントの生成</a>
</li>
</ul>イベント管理の型:
    <ul>
<li>
<a href="#jvmtiEventMode"><code>jvmtiEventMode</code></a> - イベントの有効化と無効化</li>
</ul>
<p></p>
<hr noshade width="100%" size="1" id="SetEventCallbacks">
<h3>イベント・コールバックの設定</h3>
<blockquote>
<pre>jvmtiError
SetEventCallbacks(jvmtiEnv* env,
            const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks)</pre>
</blockquote>
        イベントごとに呼び出される関数を設定します。コールバックを指定するには、置換用の関数テーブルを提供します。関数テーブルはコピーされます。テーブルのローカル・コピーを変更しても、何の効果もありません。これはアトミックなアクションであり、一度にすべてのコールバックが設定されます。この関数を呼び出すまで、イベントは送信されません。エントリが<code>NULL</code>の場合またはイベントが<a href="#SetEventCallbacks.size_of_callbacks"><code>size_of_callbacks</code></a>を超えている場合、イベントは送信されません。イベントの詳細は、このドキュメントの<a href="#EventSection">後のほう</a>で説明します。イベントが送信されるためには、イベントを有効化し、そのコールバックを登録する必要があります。この関数と<a href="#SetEventNotificationMode"><code>SetEventNotificationMode</code></a>の呼出し順序は、結果に影響を与えません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>122</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetEventCallbacks.callbacks">callbacks</code></td><td><code>const <a href="#jvmtiEventCallbacks">jvmtiEventCallbacks</a> *</code></td><td>
	    新しいイベント・コールバック。
	  <p></p>エージェントは<code>jvmtiEventCallbacks</code>へのポインタを渡す。<code>callbacks</code>が<code>NULL</code>の場合、既存のコールバックは削除される。
</td>
</tr>
<tr>
<td><code id="SetEventCallbacks.size_of_callbacks">size_of_callbacks</code></td><td><code><a href="#jint">jint</a></code></td><td>
	    <code>sizeof(jvmtiEventCallbacks)</code>-- バージョン間の互換性を実現。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetEventCallbacks.size_of_callbacks"><code>size_of_callbacks</code></a>が<code>0</code>より小さい。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetEventNotificationMode">
<h3>イベント通知モードの設定</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;</pre>
<pre>jvmtiError
SetEventNotificationMode(jvmtiEnv* env,
            jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...)</pre>
</blockquote>
	イベントの生成を制御します。 
	<blockquote>
<a name="jvmtiEventMode"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">イベントの有効化と無効化(<code>jvmtiEventMode</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_ENABLE">JVMTI_ENABLE</code></td><td align="right">1</td><td>
	    <a href="#SetEventNotificationMode.mode"><code>mode</code></a>が<code>JVMTI_ENABLE</code>の場合、イベント<a href="#SetEventNotificationMode.event_type"><code>event_type</code></a>が有効化される
	  </td>
</tr>
<tr>
<td><code id="JVMTI_DISABLE">JVMTI_DISABLE</code></td><td align="right">0</td><td>
	    <a href="#SetEventNotificationMode.mode"><code>mode</code></a>が<code>JVMTI_DISABLE</code>の場合、イベント<a href="#SetEventNotificationMode.event_type"><code>event_type</code></a>が無効化される
	  </td>
</tr>
</table>
</blockquote>
	<code>thread</code>が<code>NULL</code>の場合、イベントの有効化または無効化はグローバルに行われます。それ以外の場合、その有効化または無効化は特定のスレッドに対して行われます。あるイベントが特定のスレッドで生成されるのは、そのイベントがスレッド・レベル、グローバル・レベルのいずれかで有効化された場合です。 
	<p></p>
	個々のイベントについての情報は、<a href="#EventIndex">後述</a>する説明を参照してください。
	<p></p>
	次のイベントは、この関数を使ってスレッド・レベルでは制御できません。 
	<ul type="disc">
	  
<li>
<a href="#VMInit"><code>VMInit</code></a>
</li>
	  
<li>
<a href="#VMStart"><code>VMStart</code></a>
</li>
	  
<li>
<a href="#VMDeath"><code>VMDeath</code></a>
</li>
	  
<li>
<a href="#ThreadStart"><code>ThreadStart</code></a>
</li>
	  
<li>
<a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a>
</li>
	  
<li>
<a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a>
</li>
	  
<li>
<a href="#DynamicCodeGenerated"><code>DynamicCodeGenerated</code></a>
</li>
	  
<li>
<a href="#DataDumpRequest"><code>DataDumpRequest</code></a>
</li>
	
</ul>
	
<p></p>
	最初は、スレッド・レベルで有効にされているイベントも、グローバル・レベルで有効にされているイベントもありません。
	<p></p>
        この関数を呼び出す前に、必要な権限(後述の「イベントを有効化する権限」を参照)を所有している必要があります。
        <p></p>
	イベントの詳細については、<a href="#EventSection">後述</a>します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>2</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
        イベントを有効化する権限
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        権限
      </td><td>
        イベント
      </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a></td><td><a href="#FieldModification"><code>FieldModification</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a></td><td><a href="#FieldAccess"><code>FieldAccess</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_single_step_events"><code>can_generate_single_step_events</code></a></td><td><a href="#SingleStep"><code>SingleStep</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_exception_events"><code>can_generate_exception_events</code></a></td><td><a href="#Exception"><code>Exception</code></a> <br> <a href="#ExceptionCatch"><code>ExceptionCatch</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a></td><td><a href="#FramePop"><code>FramePop</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a></td><td><a href="#Breakpoint"><code>Breakpoint</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_entry_events"><code>can_generate_method_entry_events</code></a></td><td><a href="#MethodEntry"><code>MethodEntry</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_exit_events"><code>can_generate_method_exit_events</code></a></td><td><a href="#MethodExit"><code>MethodExit</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a></td><td><a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a> <br> <a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a></td><td><a href="#MonitorContendedEnter"><code>MonitorContendedEnter</code></a> <br> <a href="#MonitorContendedEntered"><code>MonitorContendedEntered</code></a> <br> <a href="#MonitorWait"><code>MonitorWait</code></a> <br> <a href="#MonitorWaited"><code>MonitorWaited</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_vm_object_alloc_events"><code>can_generate_vm_object_alloc_events</code></a></td><td><a href="#VMObjectAlloc"><code>VMObjectAlloc</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_native_method_bind_events"><code>can_generate_native_method_bind_events</code></a></td><td><a href="#NativeMethodBind"><code>NativeMethodBind</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_garbage_collection_events"><code>can_generate_garbage_collection_events</code></a></td><td><a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a> <br> <a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a> <br>
</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_object_free_events"><code>can_generate_object_free_events</code></a></td><td><a href="#ObjectFree"><code>ObjectFree</code></a> <br>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetEventNotificationMode.mode">mode</code></td><td><code><a href="#jvmtiEventMode">jvmtiEventMode</a></code></td><td>
	    <code>JVMTI_ENABLE</code>または<code>JVMTI_DISABLE</code>
	  </td>
</tr>
<tr>
<td><code id="SetEventNotificationMode.event_type">event_type</code></td><td><code><a href="#jvmtiEvent">jvmtiEvent</a></code></td><td>
	    制御するイベント
	  </td>
</tr>
<tr>
<td><code id="SetEventNotificationMode.event_thread">event_thread</code></td><td><code> <a href="#jthread">jthread</a> </code></td><td>
	      制御するスレッド
	    <p></p>
  <code>event_thread</code>が<code>NULL</code>の場合、イベントはグローバル・レベルで制御される。
</td>
</tr>
<tr>
<td><code id="SetEventNotificationMode....">...</code></td><td><code>...</code></td><td>
              将来の拡張用
            </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
          <a href="#SetEventNotificationMode.event_thread"><code>event_thread</code></a>が<code>NULL</code>以外で、有効なスレッドでない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
          <a href="#SetEventNotificationMode.event_thread"><code>event_thread</code></a>が<code>NULL</code>以外で、ライブ・スレッドではない(まだ起動していないか、すでに終了している)。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  スレッド・レベルの制御が許可されていないイベントで、スレッド・レベルの制御が試行された。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a></td><td> 
          必要なイベントを有効化する権限を持っていない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetEventNotificationMode.mode"><code>mode</code></a>がjvmtiEventModeではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_EVENT_TYPE"><code>JVMTI_ERROR_INVALID_EVENT_TYPE</code></a></td><td>
	  <a href="#SetEventNotificationMode.event_type"><code>event_type</code></a>がjvmtiEventではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GenerateEvents">
<h3>イベントの生成</h3>
<blockquote>
<pre>jvmtiError
GenerateEvents(jvmtiEnv* env,
            jvmtiEvent event_type)</pre>
</blockquote>
        VMの現在の状態を表すイベントを生成します。たとえば、<a href="#GenerateEvents.event_type"><code>event_type</code></a>が<code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code>の場合、現在コンパイル済のメソッドごとに<a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a>イベントが送信されます。過去にロードされたが現在はアンロード済であるようなメソッドは、送信されません。以前に送信されたイベントの履歴は、この関数で送信されるイベントに影響を与えません。たとえば、この関数を呼び出すたびに、現在コンパイル済のすべてのメソッドが送信されます。
        <p></p>
	エージェントがプログラムの実行開始後に接続されたことにより、イベントが失われた場合は、この関数を使って失われたイベントを生成できます。
	<p></p>
	Javaプログラミング言語コードまたはJNI関数の実行の試みは、この関数が復帰するまで一時停止される可能性があるので、どちらもイベント送信スレッドから呼び出すべきではありません。不足するイベントが送信されて処理され、復帰するまで、この関数は復帰しません。イベントは、発生元のスレッドとは別のスレッド上で送信される場合があります。<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>でイベントのコールバックを設定し、<a href="#SetEventNotificationMode"><code>SetEventNotificationMode</code></a>でイベントを有効化しないと、イベントは発生しません。要求されたイベントの一部または全部を生成するための情報がVMにもう残っていない場合、単にイベントが送信されず、エラーも返されません。
	<p></p>
	サポートされるイベントは次のとおりです。
	<ul type="disc">
	  
<li>
<a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a>
</li>
	  
<li>
<a href="#DynamicCodeGenerated"><code>DynamicCodeGenerated</code></a>
</li>
	
</ul>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>123</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
          任意の機能
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a></td><td>
	  メソッドのコンパイル時またはアンロード時にイベントを生成できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GenerateEvents.event_type">event_type</code></td><td><code><a href="#jvmtiEvent">jvmtiEvent</a></code></td><td>
	    生成するイベントのタイプ。次のいずれかとする。
	    <ul type="disc">
	      
<li>
<a href="#CompiledMethodLoad"><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></a>
</li>
	      
<li>
<a href="#DynamicCodeGenerated"><code>JVMTI_EVENT_DYNAMIC_CODE_GENERATED</code></a>
</li>
	    
</ul>
	  
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code>JVMTI_ERROR_MUST_POSSESS_CAPABILITY</code></a></td><td> 
          <a href="#GenerateEvents.event_type"><code>event_type</code></a>が<a href="#CompiledMethodLoad"><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></a>で、<a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a>が<code>false</code>。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td> 
          <a href="#GenerateEvents.event_type"><code>event_type</code></a>が<a href="#CompiledMethodLoad"><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></a>でも<a href="#DynamicCodeGenerated"><code>JVMTI_EVENT_DYNAMIC_CODE_GENERATED</code></a>でもない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_EVENT_TYPE"><code>JVMTI_ERROR_INVALID_EVENT_TYPE</code></a></td><td>
	  <a href="#GenerateEvents.event_type"><code>event_type</code></a>がjvmtiEventではない。
	  
	</td>
</tr>
</table>
<p id="extension"></p>
<hr noshade size="3">
<h2 align="center">拡張機能メカニズム</h2>拡張機能メカニズム関数:
  <ul>
<li>
<a href="#GetExtensionFunctions">拡張関数の取得</a>
</li>
<li>
<a href="#GetExtensionEvents">拡張イベントの取得</a>
</li>
<li>
<a href="#SetExtensionEventCallback">拡張イベント・コールバックの設定</a>
</li>
</ul>拡張機能メカニズムの関数型:
    <ul>
<li>
<a href="#jvmtiExtensionFunction">拡張関数</a>
</li>
<li>
<a href="#jvmtiExtensionEvent">拡張イベント</a>
</li>
</ul>拡張機能メカニズムの型:
    <ul>
<li>
<a href="#jvmtiParamTypes"><code>jvmtiParamTypes</code></a> - 拡張関数/イベント・パラメータの型</li>
<li>
<a href="#jvmtiParamKind"><code>jvmtiParamKind</code></a> - 拡張関数/イベント・パラメータの種類</li>
<li>
<a href="#jvmtiParamInfo"><code>jvmtiParamInfo</code></a> - 拡張関数/イベント・パラメータ情報</li>
<li>
<a href="#jvmtiExtensionFunctionInfo"><code>jvmtiExtensionFunctionInfo</code></a> - 拡張関数情報</li>
<li>
<a href="#jvmtiExtensionEventInfo"><code>jvmtiExtensionEventInfo</code></a> - 拡張イベント情報</li>
</ul>
	JVM<small style="font-size: xx-small">&nbsp;</small>TI実装は、これらの関数を使って、この仕様に定義されていない関数およびイベントを提供します。
	<p></p>
	拡張関数と拡張イベントのパラメータは、それぞれ次の表に示す「型」と「種類」を持ちます。

	<blockquote>
<a name="jvmtiParamTypes"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">拡張関数/イベント・パラメータの型(<code>jvmtiParamTypes</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JBYTE">JVMTI_TYPE_JBYTE</code></td><td align="right">101</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>byte</code>。JNI型<code>jbyte</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JCHAR">JVMTI_TYPE_JCHAR</code></td><td align="right">102</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>char</code>。JNI型<code>jchar</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JSHORT">JVMTI_TYPE_JSHORT</code></td><td align="right">103</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>short</code>。JNI型<code>jshort</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JINT">JVMTI_TYPE_JINT</code></td><td align="right">104</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>int</code>。JNI型<a href="#jint"><code>jint</code></a>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JLONG">JVMTI_TYPE_JLONG</code></td><td align="right">105</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>long</code>。JNI型<a href="#jlong"><code>jlong</code></a>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JFLOAT">JVMTI_TYPE_JFLOAT</code></td><td align="right">106</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>float</code>。JNI型<a href="#jfloat"><code>jfloat</code></a>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JDOUBLE">JVMTI_TYPE_JDOUBLE</code></td><td align="right">107</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>double</code>。JNI型<a href="#jdouble"><code>jdouble</code></a>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JBOOLEAN">JVMTI_TYPE_JBOOLEAN</code></td><td align="right">108</td><td>
	    Javaプログラミング言語プリミティブ型 - <code>boolean</code>。JNI型<a href="#jboolean"><code>jboolean</code></a>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JOBJECT">JVMTI_TYPE_JOBJECT</code></td><td align="right">109</td><td>
	    Javaプログラミング言語オブジェクト型 - <code>java.lang.Object</code>。JNI型<a href="#jobject"><code>jobject</code></a>。戻り値はJNIローカル参照で、管理対象。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JTHREAD">JVMTI_TYPE_JTHREAD</code></td><td align="right">110</td><td>
	    Javaプログラミング言語オブジェクト型 - <code>java.lang.Thread</code>。JVM<small style="font-size: xx-small">&nbsp;</small>TI型<a href="#jthread"><code>jthread</code></a>。戻り値はJNIローカル参照で、管理対象。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JCLASS">JVMTI_TYPE_JCLASS</code></td><td align="right">111</td><td>
	    Javaプログラミング言語オブジェクト型 - <code>java.lang.Class</code>。JNI型<a href="#jclass"><code>jclass</code></a>。戻り値はJNIローカル参照で、管理対象。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JVALUE">JVMTI_TYPE_JVALUE</code></td><td align="right">112</td><td>
	    すべてのJavaプログラミング言語プリミティブ型およびオブジェクト型の和集合 - JNI型<a href="#jvalue"><code>jvalue</code></a>。戻り値は、オブジェクト型がJNIローカル参照であることを表しており、管理対象。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JFIELDID">JVMTI_TYPE_JFIELDID</code></td><td align="right">113</td><td>
	    Javaプログラミング言語フィールド識別子 - JNI型<a href="#jfieldID"><code>jfieldID</code></a>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JMETHODID">JVMTI_TYPE_JMETHODID</code></td><td align="right">114</td><td>
	    Javaプログラミング言語メソッド識別子 - JNI型<a href="#jmethodID"><code>jmethodID</code></a>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_CCHAR">JVMTI_TYPE_CCHAR</code></td><td align="right">115</td><td>
	    Cプログラミング言語型 - <code>char</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_CVOID">JVMTI_TYPE_CVOID</code></td><td align="right">116</td><td>
	    Cプログラミング言語型 - <code>void</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_TYPE_JNIENV">JVMTI_TYPE_JNIENV</code></td><td align="right">117</td><td>
	    JNI環境 - <code>JNIEnv</code>。ポインタ型にするには、適切な<a href="#jvmtiParamKind"><code>jvmtiParamKind</code></a>とともに使用する必要がある。
	  </td>
</tr>
</table>
</blockquote>

	
<blockquote>
<a name="jvmtiParamKind"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">拡張関数/イベント・パラメータの種類(<code>jvmtiParamKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_IN">JVMTI_KIND_IN</code></td><td align="right">91</td><td>
	    入力引数 - <code>foo</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_IN_PTR">JVMTI_KIND_IN_PTR</code></td><td align="right">92</td><td>
	    入力ポインタ引数 - <code>const foo*</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_IN_BUF">JVMTI_KIND_IN_BUF</code></td><td align="right">93</td><td>
	    入力配列引数 - <code>const foo*</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_ALLOC_BUF">JVMTI_KIND_ALLOC_BUF</code></td><td align="right">94</td><td>
	    割当て済み出力配列引数 - <code>foo**</code>。<code>Deallocate</code>で解放。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_ALLOC_ALLOC_BUF">JVMTI_KIND_ALLOC_ALLOC_BUF</code></td><td align="right">95</td><td>
	    割当て済み配列引数の割当て済み出力配列 - <code>foo***</code>。<code>Deallocate</code>で解放。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_OUT">JVMTI_KIND_OUT</code></td><td align="right">96</td><td>
	    出力引数 - <code>foo*</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_KIND_OUT_BUF">JVMTI_KIND_OUT_BUF</code></td><td align="right">97</td><td>
	    出力配列引数(エージェントにより事前に割当て済み) - <code>foo*</code>。<code>Deallocate</code>は不可。
	  </td>
</tr>
</table>
</blockquote>

      
<h4 id="jvmtiParamInfo">拡張関数/イベント・パラメータ情報</h4>
<blockquote>
<pre>typedef struct {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
} jvmtiParamInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiParamInfo</code> - 拡張関数/イベント・パラメータ情報</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.name">name</code></td><td><code>char*</code></td><td>
	      パラメータ名。<a href="#mUTF">修正UTF-8</a>文字列でエンコードされる
	    </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.kind">kind</code></td><td><code><a href="#jvmtiParamKind">jvmtiParamKind</a></code></td><td>
	    パラメータの種類 - 型修飾子
	  </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.base_type">base_type</code></td><td><code><a href="#jvmtiParamTypes">jvmtiParamTypes</a></code></td><td>
	    パラメータの基底型 - <code>kind</code>により変更済み
	  </td>
</tr>
<tr>
<td><code id="jvmtiParamInfo.null_ok">null_ok</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	      <code>NULL</code>引数を許可するか。ポインタ型とオブジェクト型のみに適用。
	    </td>
</tr>
</table>
</blockquote>
<p></p>
<hr noshade width="100%" size="1" id="jvmtiExtensionFunction">
<h3>拡張関数</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env, 
      ...);</pre>
</blockquote>
	  実装固有の拡張関数です。
	<p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunction.jvmti_env">jvmti_env</code></td><td><code> <a href="#jvmtiEnv">jvmtiEnv</a> *</code></td><td>
	      JVM<small style="font-size: xx-small">&nbsp;</small>TI環境は、拡張関数の唯一の固定パラメータ。
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunction....">...</code></td><td><code>...</code></td><td>
		拡張関数固有のパラメータ。
	      </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetExtensionFunctions">
<h3>拡張関数の取得</h3>
<blockquote>
<pre>typedef struct {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
} jvmtiExtensionFunctionInfo;</pre>
<pre>jvmtiError
GetExtensionFunctions(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions)</pre>
</blockquote>
	  拡張関数のセットを返します。
	<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>124</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p id="jvmtiExtensionFunctionInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiExtensionFunctionInfo</code> - 拡張関数情報</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.func">func</code></td><td><code> <a href="#jvmtiExtensionFunction">jvmtiExtensionFunction</a> </code></td><td>
	      呼び出される実際の関数
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.id">id</code></td><td><code>char*</code></td><td>
		拡張関数の識別子。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。パッケージの命名規則を使用する。例: <code>com.sun.hotspot.bar</code>
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.short_description">short_description</code></td><td><code>char*</code></td><td>
		関数を1文で説明。<a href="#mUTF">修正UTF-8</a>文字列でエンコードされる。
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.param_count">param_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
		<code>jvmtiEnv *jvmti_env</code>を除くパラメータ数
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.params">params</code></td><td><code> <a href="#jvmtiParamInfo">jvmtiParamInfo</a> *</code></td><td>
	      <a href="#jvmtiExtensionFunctionInfo.param_count"><code>param_count</code></a>パラメータの配列(<code>jvmtiEnv *jvmti_env</code>は除外)
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.error_count">error_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
		エラー戻り値の数(汎用エラーを除く)
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionFunctionInfo.errors">errors</code></td><td><code> <a href="#jvmtiError">jvmtiError</a> *</code></td><td>
	      <a href="#jvmtiExtensionFunctionInfo.error_count"><code>error_count</code></a>のエラーの配列
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetExtensionFunctions.extension_count_ptr">extension_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
		戻ったとき、拡張関数の数をポイントする。
	      <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetExtensionFunctions.extensions">extensions</code></td><td><code><a href="#jvmtiExtensionFunctionInfo">jvmtiExtensionFunctionInfo</a>**</code></td><td>
	      拡張関数情報の配列を、関数ごとに1つずつ返す。
	    <p></p>エージェントは<code>jvmtiExtensionFunctionInfo*</code>へのポインタを渡す。戻ったとき、<code>jvmtiExtensionFunctionInfo*</code>は、サイズ<code>*extension_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiExtensionFunctionInfo</code>の<code>id</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiExtensionFunctionInfo</code>の<code>short_description</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiExtensionFunctionInfo</code>の<code>params</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiParamInfo</code>の<code>name</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiExtensionFunctionInfo</code>の<code>errors</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	    <a href="#GetExtensionFunctions.extension_count_ptr"><code>extension_count_ptr</code></a>が<code>NULL</code>。
	      
	  </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	    <a href="#GetExtensionFunctions.extensions"><code>extensions</code></a>が<code>NULL</code>。
	    
	  </td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetExtensionEvents">
<h3>拡張イベントの取得</h3>
<blockquote>
<pre>typedef struct {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
} jvmtiExtensionEventInfo;</pre>
<pre>jvmtiError
GetExtensionEvents(jvmtiEnv* env,
            jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions)</pre>
</blockquote>
	  拡張イベントのセットを返します。
	<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>125</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p id="jvmtiExtensionEventInfo"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiExtensionEventInfo</code> - 拡張イベント情報</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.extension_event_index">extension_event_index</code></td><td><code><a href="#jint">jint</a></code></td><td>
	      イベントを識別するインデックス
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.id">id</code></td><td><code>char*</code></td><td>
		拡張イベントの識別子。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。パッケージの命名規則を使用する。例: <code>com.sun.hotspot.bar</code>
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.short_description">short_description</code></td><td><code>char*</code></td><td>
		イベントを1文で説明。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.param_count">param_count</code></td><td><code><a href="#jint">jint</a></code></td><td>
		<code>jvmtiEnv *jvmti_env</code>を除くパラメータ数
	      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEventInfo.params">params</code></td><td><code> <a href="#jvmtiParamInfo">jvmtiParamInfo</a> *</code></td><td>
	      <a href="#jvmtiExtensionEventInfo.param_count"><code>param_count</code></a>パラメータの配列(<code>jvmtiEnv *jvmti_env</code>は除外)
	    </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetExtensionEvents.extension_count_ptr">extension_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
		戻ったとき、拡張イベントの数をポイントする。
	      <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetExtensionEvents.extensions">extensions</code></td><td><code><a href="#jvmtiExtensionEventInfo">jvmtiExtensionEventInfo</a>**</code></td><td>
	      拡張イベント情報の配列を、イベントごとに1つずつ返す。
	    <p></p>エージェントは<code>jvmtiExtensionEventInfo*</code>へのポインタを渡す。戻ったとき、<code>jvmtiExtensionEventInfo*</code>は、サイズ<code>*extension_count_ptr</code>の新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiExtensionEventInfo</code>の<code>id</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiExtensionEventInfo</code>の<code>short_description</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiExtensionEventInfo</code>の<code>params</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。<code>jvmtiParamInfo</code>の<code>name</code>フィールドに返されるポインタは、新しく割り当てられた配列。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	    <a href="#GetExtensionEvents.extension_count_ptr"><code>extension_count_ptr</code></a>が<code>NULL</code>。
	      
	  </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	    <a href="#GetExtensionEvents.extensions"><code>extensions</code></a>が<code>NULL</code>。
	    
	  </td>
</tr>
</table>
<hr noshade width="100%" size="1" id="jvmtiExtensionEvent">
<h3>拡張イベント</h3>
<table cellpadding="0" cellspacing="0" border="0" width="90%" align="center">
<tr>
<td>
<blockquote>
<pre>typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env, 
      ...);</pre>
</blockquote>
	  実装固有のイベントです。イベント・ハンドラの設定には、<a href="#SetExtensionEventCallback"><code>SetExtensionEventCallback</code></a>を使用します。
          <p></p>
          拡張イベントのイベント・ハンドラは、この定義に一致するような宣言型の可変引数でなければなりません。宣言型の可変引数でない場合、一部のプラットフォームで、呼出し規則の不一致や未定義の動作が発生する可能性があります。
          <p></p>
          たとえば、<a href="#GetExtensionEvents"><code>GetExtensionEvents</code></a>から返された<code>jvmtiParamInfo</code>に、<code>jint</code>パラメータの存在が示されている場合、イベント・ハンドラを次のように宣言する必要があります。
<blockquote>
<pre>
    void JNICALL myHandler(jvmtiEnv* jvmti_env, jint myInt, ...)
</pre>
</blockquote>
          最後の「<code>...</code>」は可変引数を表します。
	<p></p>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEvent.jvmti_env">jvmti_env</code></td><td><code> <a href="#jvmtiEnv">jvmtiEnv</a> *</code></td><td>
	      JVM<small style="font-size: xx-small">&nbsp;</small>TI環境は、拡張イベントの唯一の固定パラメータ。
	    </td>
</tr>
<tr>
<td><code id="jvmtiExtensionEvent....">...</code></td><td><code>...</code></td><td>
		拡張イベント固有のパラメータ
	      </td>
</tr>
</table>
</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetExtensionEventCallback">
<h3>拡張イベント・コールバックの設定</h3>
<blockquote>
<pre>jvmtiError
SetExtensionEventCallback(jvmtiEnv* env,
            jint extension_event_index,
            jvmtiExtensionEvent callback)</pre>
</blockquote>
	  拡張イベントにコールバック関数を設定し、イベントを有効にします。コールバックが<code>NULL</code>の場合、イベントを無効にします。標準イベントとは異なり、コールバックを設定してイベントを有効にする処理は単一の操作です。
	<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>126</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetExtensionEventCallback.extension_event_index">extension_event_index</code></td><td><code><a href="#jint">jint</a></code></td><td>
		設定するコールバックを識別する。このインデックスは、<a href="#jvmtiExtensionEventInfo"><code>jvmtiExtensionEventInfo</code></a>の<a href="#jvmtiExtensionEventInfo.extension_event_index"><code>extension_event_index</code></a>フィールド。
	      </td>
</tr>
<tr>
<td><code id="SetExtensionEventCallback.callback">callback</code></td><td><code> <a href="#jvmtiExtensionEvent">jvmtiExtensionEvent</a> </code></td><td>
	      <code>callback</code>が<code>NULL</code>以外の場合、<code>callback</code>をイベント・コールバック関数に設定し、イベントを有効にする。
	    <p></p>
  <code>callback</code>が<code>NULL</code>の場合、イベントを無効にする。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td> 
            <a href="#SetExtensionEventCallback.extension_event_index"><code>extension_event_index</code></a>が<a href="#GetExtensionEvents"><code>GetExtensionEvents</code></a>から返された<a href="#jvmtiExtensionEventInfo.extension_event_index"><code>extension_event_index</code></a>でない。
        </td>
</tr>
</table>
<p id="capability"></p>
<hr noshade size="3">
<h2 align="center">権限</h2>権限関数:
  <ul>
<li>
<a href="#GetPotentialCapabilities">潜在的な権限の取得</a>
</li>
<li>
<a href="#AddCapabilities">権限の追加</a>
</li>
<li>
<a href="#RelinquishCapabilities">権限の放棄</a>
</li>
<li>
<a href="#GetCapabilities">権限の取得</a>
</li>
</ul>権限の型:
    <ul>
<li>
<a href="#jvmtiCapabilities"><code>jvmtiCapabilities</code></a> - 権限の構造体</li>
</ul>
      権限関数では、JVM<small style="font-size: xx-small">&nbsp;</small>TIが使用できる機能(どのJVM<small style="font-size: xx-small">&nbsp;</small>TI関数を呼び出せるか、どんなイベントを生成できるか、これらのイベントや関数がどんな機能を提供できるかなど)を変更できます。
      <p></p>
        各関数およびイベントの「権限」のセクションには、関連付けられている権限の説明が記載されています(存在する場合)。「必要な機能」は、使用可能であり、権限を追加しなくても使用できることを表しています。「任意の機能」は、使用するためにはエージェントに権限が必要であることを表しています。権限を持つためには、エージェントは<a href="#AddCapabilities">権限を追加する</a>必要があります。「任意の機能」には、機能セットを拡張する権限の説明が記載されています。
        <p></p>
        各JVM<small style="font-size: xx-small">&nbsp;</small>TI実装が潜在的に使用できる権限は異なります。実装によって、次のようなことが言えます。
        <ul type="disc">
          
<li>決して追加してはならない権限がある</li>
          
<li>すべての環境で、ある権限を<code>OnLoad</code>またはライブ段階で追加できる</li>
          
<li>ある権限を<code>OnLoad</code>段階でしか追加できない</li>
          
<li>ある権限を複数の環境で同時に所有することはできない</li>
          
<li>ある権限を複数の環境で同時に所有することはできない。また、<code>OnLoad</code>段階でしか所有できない</li>
          
<li>その他。</li>
        
</ul>
      しばしば、権限を追加することによって、実行速度、起動時間、メモリー・フットプリントなどに影響が出ることがあります。権限を使用するオーバーヘッドは、権限を所有するオーバーヘッドとはまったく異なる点に注意してください。例として、ステップ実行について考えてみましょう。ステップ実行が有効な場合は(イベントが有効で、アクティブにイベントを送信している状態)、どの実装でも、各命令でイベントを送信し、処理するオーバーヘッドが大きくなります。一方、権限を所有するオーバーヘッドは、実装によって大きかったり小さかったりします。また、権限を使用できるかどうか、および追加できるタイミングは、実装によって異なります。使用例を次に示します。
      <ul type="disc">
	
<li>あるVMは、バイト・コードをネイティブ・コードにコンパイルすることによってすべてを実行し、ステップ実行命令を生成できなくなっている。この実装では、権限は追加できない。</li>
	
<li>別のVMは、実行をステップ実行インタプリタにいつでも切り替えられる。この実装では、権限を所有することでオーバーヘッドは生じず、権限はいつでも追加できる。</li>
	
<li>さらに別のVMは、バイトコード・コンパイル、シングル・ステップ実行可能な解釈実行エンジンのどちらかを起動時に選択できるが、両者間の切替えは行えない。この実装では、<code>OnLoad</code>段階(バイトコード実行の開始前)に権限を追加する必要があるほか、シングル・ステップ実行がまったく使用されなくても、権限が実行速度に大きな影響を与える。</li>
	
<li>さらに別のVMは、コンパイル済みバイト・コードまたは生成済みインタプリタに「is single stepping on」チェックを追加できる。この実装でも、<code>OnLoad</code>段階で権限を追加する必要があるが、オーバーヘッド(各命令のテストとブランチ)はかなり低くなる。</li>
      
</ul>
      
<p></p>
      各JVM<small style="font-size: xx-small">&nbsp;</small>TI<a href="#environments">環境</a>は独自の権限セットを持ちます。最初、そのセットは空です。必要な権限をすべて追加する必要があります。権限の追加は、可能であれば<code>OnLoad</code>段階で行うべきです。ほとんどの仮想マシンでは、特定の権限には仮想マシンの特別な設定が必要であり、その設定は、仮想マシンの実行が開始される前に<code>OnLoad</code>段階で行う必要があります。いったん追加された権限を削除できるのは、環境によって明示的に放棄された場合のみです。
      <p></p>
      エージェントは、<a href="#GetPotentialCapabilities">このVMが潜在的に提供できる権限を特定し</a>、<a href="#AddCapabilities">使用する権限を追加し</a>、<a href="#RelinquishCapabilities">不要になった権限を解放し</a>、<a href="#GetCapabilities">現在使用可能な権限を調べる</a>ことができます。
    <h4 id="capabilityExamples">権限の例</h4>
      たとえば、<code>OnLoad</code>関数で新規に起動したエージェントで、使用可能なすべての権限を有効にする場合があります。使用していない機能によってエージェントのパフォーマンスが低減する可能性があるため、一般にこの設定はお勧めしません。次に、Cで記述したコード例を示します。
      <blockquote>
<pre>
	jvmtiCapabilities capa;
	jvmtiError err;

	err = (*jvmti)-&gt;GetPotentialCapabilities(jvmti, &amp;capa);
	if (err == JVMTI_ERROR_NONE) {
	   err = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capa);
      </pre>
</blockquote>
      たとえば、エージェントで、メソッドのバイト・コードを取得できるかどうかチェックする場合(以前にこの権限を追加して、まだ放棄していないかどうかをチェックする場合)、Cで記述したコードは次のようになります。
      <blockquote>
<pre>
	jvmtiCapabilities capa;
	jvmtiError err;

	err = (*jvmti)-&gt;GetCapabilities(jvmti, &amp;capa);
	if (err == JVMTI_ERROR_NONE) {
   	   if (capa.can_get_bytecodes) { ... } } 
      </pre>
</blockquote>
    
<h4 id="jvmtiCapabilities">権限の構造体</h4>
        このカテゴリに含まれる関数は、次の権限構造体を使用します。この構造体には、各権限に対応するブール型フラグが含まれています。
      <p></p>
<blockquote>
<blockquote>
<pre>typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int : 7;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;</pre>
</blockquote>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiCapabilities</code> - 権限の構造体</td>
</tr>
<tr bgcolor="#EEEEFF">
<td colspan="3">
          すべての型は<code>unsigned int : 1</code></td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          説明
        </td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td><code>can_tag_objects</code></td><td><a name="jvmtiCapabilities.can_tag_objects"></a><a href="#Heap">ヒープのカテゴリ</a>に説明されているように、タグを設定し、タグを取得できる。
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_field_modification_events</code></td><td><a name="jvmtiCapabilities.can_generate_field_modification_events"></a>フィールドの変更にウォッチポイントを設定できる - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_field_access_events</code></td><td><a name="jvmtiCapabilities.can_generate_field_access_events"></a>フィールド・アクセスにウォッチポイントを設定できる - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_bytecodes</code></td><td><a name="jvmtiCapabilities.can_get_bytecodes"></a>メソッド<a href="#GetBytecodes"><code>GetBytecodes</code></a>のバイト・コードを取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_synthetic_attribute</code></td><td><a name="jvmtiCapabilities.can_get_synthetic_attribute"></a>フィールドまたはメソッドが合成であるかどうかをテストできる - <a href="#IsFieldSynthetic"><code>IsFieldSynthetic</code></a>と<a href="#IsMethodSynthetic"><code>IsMethodSynthetic</code></a>
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_owned_monitor_info</code></td><td><a name="jvmtiCapabilities.can_get_owned_monitor_info"></a>モニターの所有に関する情報を取得できる - <a href="#GetOwnedMonitorInfo"><code>GetOwnedMonitorInfo</code></a>
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_current_contended_monitor</code></td><td><a name="jvmtiCapabilities.can_get_current_contended_monitor"></a> <a href="#GetCurrentContendedMonitor"><code>GetCurrentContendedMonitor</code></a>が可能
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_monitor_info</code></td><td><a name="jvmtiCapabilities.can_get_monitor_info"></a> <a href="#GetObjectMonitorUsage"><code>GetObjectMonitorUsage</code></a>が可能
      </td><td>1.0</td>
</tr>
<tr>
<td><code>can_pop_frame</code></td><td><a name="jvmtiCapabilities.can_pop_frame"></a>スタックからフレームをポップできる - <a href="#PopFrame"><code>PopFrame</code></a>
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_redefine_classes</code></td><td><a name="jvmtiCapabilities.can_redefine_classes"></a><a href="#RedefineClasses"><code>RedefineClasses</code></a>でクラスを再定義できる。
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_signal_thread</code></td><td><a name="jvmtiCapabilities.can_signal_thread"></a>スレッドに停止または割込み信号を送信できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_source_file_name</code></td><td><a name="jvmtiCapabilities.can_get_source_file_name"></a>クラスのソース・ファイルの名前を取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_line_numbers</code></td><td><a name="jvmtiCapabilities.can_get_line_numbers"></a>メソッドの行番号テーブルを取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_source_debug_extension</code></td><td><a name="jvmtiCapabilities.can_get_source_debug_extension"></a>クラスのソース・デバッグ拡張機能を取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_access_local_variables</code></td><td><a name="jvmtiCapabilities.can_access_local_variables"></a>局所変数を設定し、取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_maintain_original_method_order</code></td><td><a name="jvmtiCapabilities.can_maintain_original_method_order"></a>クラス・ファイル内に出現する順序でメソッドを返すことができる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_single_step_events</code></td><td><a name="jvmtiCapabilities.can_generate_single_step_events"></a><a href="#SingleStep">ステップ実行</a>イベントを取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_exception_events</code></td><td><a name="jvmtiCapabilities.can_generate_exception_events"></a><a href="#Exception">スローされた例外</a>イベントおよび<a href="#ExceptionCatch">例外キャッチ</a>イベントを取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_frame_pop_events</code></td><td><a name="jvmtiCapabilities.can_generate_frame_pop_events"></a><a href="#FramePop"><code>FramePop</code></a>イベントを<a href="#NotifyFramePop">設定</a>し、取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate_breakpoint_events</code></td><td><a name="jvmtiCapabilities.can_generate_breakpoint_events"></a><a href="#Breakpoint"><code>Breakpoint</code></a>イベントを<a href="#SetBreakpoint">設定</a>し、取得できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_suspend</code></td><td><a name="jvmtiCapabilities.can_suspend"></a>スレッドを中断し、再開できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_redefine_any_class</code></td><td><a name="jvmtiCapabilities.can_redefine_any_class"></a>プリミティブ・クラスでも配列クラスでもない任意のクラスを変更(再変換または再定義)できる。<a href="#IsModifiableClass"><code>IsModifiableClass</code></a>を参照。
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_current_thread_cpu_time</code></td><td><a name="jvmtiCapabilities.can_get_current_thread_cpu_time"></a>現在のスレッドCPU時間を<a href="#GetCurrentThreadCpuTime">取得</a>できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_get_thread_cpu_time</code></td><td><a name="jvmtiCapabilities.can_get_thread_cpu_time"></a>スレッドCPU時間を<a href="#GetThreadCpuTime">取得</a>できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_method_entry_events</code></td><td><a name="jvmtiCapabilities.can_generate_method_entry_events"></a>メソッドに入るときにメソッド・エントリ・イベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_method_exit_events</code></td><td><a name="jvmtiCapabilities.can_generate_method_exit_events"></a>メソッドの終了時にメソッド終了イベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_all_class_hook_events</code></td><td><a name="jvmtiCapabilities.can_generate_all_class_hook_events"></a>ロードされたすべてのクラスに対して、ClassFileLoadHookイベントを生成できる。
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_compiled_method_load_events</code></td><td><a name="jvmtiCapabilities.can_generate_compiled_method_load_events"></a>メソッドのコンパイル時またはアンロード時にイベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_monitor_events</code></td><td><a name="jvmtiCapabilities.can_generate_monitor_events"></a>モニターの使用率に関するイベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_vm_object_alloc_events</code></td><td><a name="jvmtiCapabilities.can_generate_vm_object_alloc_events"></a>オブジェクトのVM割当てに関するイベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_native_method_bind_events</code></td><td><a name="jvmtiCapabilities.can_generate_native_method_bind_events"></a>ネイティブ・メソッドが実装にバインドされているときにイベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_garbage_collection_events</code></td><td><a name="jvmtiCapabilities.can_generate_garbage_collection_events"></a>ガベージ・コレクションの開始時または終了時にイベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_generate<br>_object_free_events</code></td><td><a name="jvmtiCapabilities.can_generate_object_free_events"></a>ガベージ・コレクタがオブジェクトを解放するときにイベントを生成できる
	</td><td>1.0</td>
</tr>
<tr>
<td><code>can_force_early_return</code></td><td><a name="jvmtiCapabilities.can_force_early_return"></a><a href="#ForceEarlyReturn">早期復帰の強制のカテゴリ</a>で説明しているように、メソッドから早期復帰できる。
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_get_owned_monitor_stack_depth_info</code></td><td><a name="jvmtiCapabilities.can_get_owned_monitor_stack_depth_info"></a>所有されているモニターに関する情報とスタックの深さを取得できる - <a href="#GetOwnedMonitorStackDepthInfo"><code>GetOwnedMonitorStackDepthInfo</code></a>
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_get_constant_pool</code></td><td><a name="jvmtiCapabilities.can_get_constant_pool"></a>あるクラスの定数プールを取得できる - <a href="#GetConstantPool"><code>GetConstantPool</code></a>
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_set_native_method_prefix</code></td><td><a name="jvmtiCapabilities.can_set_native_method_prefix"></a>ネイティブ・メソッドを解決できない場合に適用すべき接頭辞を設定できる - <a href="#SetNativeMethodPrefix"><code>SetNativeMethodPrefix</code></a>および<a href="#SetNativeMethodPrefixes"><code>SetNativeMethodPrefixes</code></a>
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_retransform_classes</code></td><td><a name="jvmtiCapabilities.can_retransform_classes"></a><a href="#RetransformClasses"><code>RetransformClasses</code></a>でクラスを再変換できる。特定の実装によって適用されるこの権限の制限(「<a href="#capability">権限</a>」セクションを参照)に加え、この権限は、この環境で<a href="#ClassFileLoadHook"><code>ClassFileLoadHook</code></a>イベントがはじめて有効化される前に設定する必要がある。<code>ClassFileLoadHook</code>がはじめて有効化された時点でこの権限を所有している環境を「<i>再変換可能</i>」と呼ぶ。<code>ClassFileLoadHook</code>がはじめて有効化された時点でこの権限を所有していない環境を「<i>再変換不可能</i>」と呼ぶ。
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_retransform_any_class</code></td><td><a name="jvmtiCapabilities.can_retransform_any_class"></a> <a href="#RetransformClasses"><code>RetransformClasses</code></a>を任意のクラスで呼び出せる(<a href="#jvmtiCapabilities.can_retransform_classes"><code>can_retransform_classes</code></a>も設定する必要がある)
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_generate_resource_exhaustion_heap_events</code></td><td><a name="jvmtiCapabilities.can_generate_resource_exhaustion_heap_events"></a>VMがJava<sup style="font-size: xx-small">TM</sup>プラットフォーム・ヒープからメモリーの割り当てを行えない場合に、イベントを生成できる。<a href="#ResourceExhausted"><code>ResourceExhausted</code></a>を参照。
	</td><td>1.1</td>
</tr>
<tr>
<td><code>can_generate_resource_exhaustion_threads_events</code></td><td><a name="jvmtiCapabilities.can_generate_resource_exhaustion_threads_events"></a>VMがスレッドを作成できない場合にイベントを生成できる。<a href="#ResourceExhausted"><code>ResourceExhausted</code></a>を参照。
	</td><td>1.1</td>
</tr>
</table>
</blockquote>
<p></p>
<hr noshade width="100%" size="1" id="GetPotentialCapabilities">
<h3>潜在的な権限の取得</h3>
<blockquote>
<pre>jvmtiError
GetPotentialCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
        この時点でこの環境が所有できる可能性のあるJVM<small style="font-size: xx-small">&nbsp;</small>TI機能を、<a href="#GetPotentialCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>経由で返します。返される権限が、VMに実装された完全な権限セットと異なる場合が2つあります。1つの環境しか所有できない権限を別の環境が所有している場合と、現在の<a href="#GetPhase">段階</a>がライブであり、<code>OnLoad</code>段階でしか追加できない権限が存在している場合です。<a href="#AddCapabilities"><code>AddCapabilities</code></a>関数を使えば、これらの権限のいずれかまたはすべてを設定できます。現在所有されている権限が含まれます。
        <p></p>
        通常、この関数は、<code>OnLoad</code>関数で使用されます。一部の仮想マシンでは、ライブ段階で追加できる権限のセットが制限されています。この場合、潜在的に使用可能な権限のセットが、<code>OnLoad</code>段階のセットとは異なります。
        <p></p>
        <a href="#capabilityExamples">権限の例</a>を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>140</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetPotentialCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code><a href="#jvmtiCapabilities">jvmtiCapabilities</a>*</code></td><td>
	    戻ったとき、追加可能なJVM<small style="font-size: xx-small">&nbsp;</small>TIの権限をポイントする。
	  <p></p>エージェントは<code>jvmtiCapabilities</code>へのポインタを渡す。戻ったとき、<code>jvmtiCapabilities</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetPotentialCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="AddCapabilities">
<h3>権限の追加</h3>
<blockquote>
<pre>jvmtiError
AddCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
        <code>*</code><a href="#AddCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>内で値が<code>1</code>に設定されている権限を追加することで、新しい権限を設定します。以前の権限はすべて保持されます。通常、この関数は、<code>OnLoad</code>関数で使用されます。一部の仮想マシンでは、ライブ段階で追加できる権限のセットが制限されています。
        <p></p>
        <a href="#capabilityExamples">権限の例</a>を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>142</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="AddCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code>const <a href="#jvmtiCapabilities">jvmtiCapabilities</a>*</code></td><td>
	    追加するJVM<small style="font-size: xx-small">&nbsp;</small>TI権限をポイントする。
	  <p></p>エージェントは<code>jvmtiCapabilities</code>へのポインタを渡す。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a></td><td> 
          必要な権限が潜在的に使用可能な権限でない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#AddCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="RelinquishCapabilities">
<h3>権限の放棄</h3>
<blockquote>
<pre>jvmtiError
RelinquishCapabilities(jvmtiEnv* env,
            const jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
        <code>*</code><a href="#RelinquishCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>内で値が<code>1</code>に設定されている権限を放棄します。実装によっては、単一の環境にしか権限の所有が許可されない場合があります(<a href="#capability">権限の概要</a>を参照)。この関数は、その他のエージェントが使用できるように、権限を解放します。その他のすべての権限は保持されます。権限は、<a href="#GetCapabilities"><code>GetCapabilities</code></a>からは失われます。エージェントが所有していない権限を放棄しようとしても、エラーは発生しません。
          
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>143</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="RelinquishCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code>const <a href="#jvmtiCapabilities">jvmtiCapabilities</a>*</code></td><td>
	    放棄するJVM<small style="font-size: xx-small">&nbsp;</small>TI権限をポイントする。
	  <p></p>エージェントは<code>jvmtiCapabilities</code>へのポインタを渡す。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#RelinquishCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetCapabilities">
<h3>権限の取得</h3>
<blockquote>
<pre>jvmtiError
GetCapabilities(jvmtiEnv* env,
            jvmtiCapabilities* capabilities_ptr)</pre>
</blockquote>
          <a href="#GetCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>を介して、この環境が現在所有している任意のJVM<small style="font-size: xx-small">&nbsp;</small>TI機能を返します。所有している各権限は、<a href="#jvmtiCapabilities">権限構造体</a>の対応するフィールドの<code>1</code>によって示されます。環境は、<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使って追加に成功するまで、権限を所有しません。環境は、<a href="#RelinquishCapabilities"><code>RelinquishCapabilities</code></a>を使って放棄しないかぎり、権限を失いません。したがって、この関数は、<code>AddCapabilities</code>呼び出しと<code>RelinquishCapabilities</code>呼出しの最終結果を返します。
          <p></p>
          <a href="#capabilityExamples">権限の例</a>を参照してください。
        <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>89</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetCapabilities.capabilities_ptr">capabilities_ptr</code></td><td><code><a href="#jvmtiCapabilities">jvmtiCapabilities</a>*</code></td><td>
	    戻ったとき、JVM<small style="font-size: xx-small">&nbsp;</small>TIの権限をポイントする。
	  <p></p>エージェントは<code>jvmtiCapabilities</code>へのポインタを渡す。戻ったとき、<code>jvmtiCapabilities</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetCapabilities.capabilities_ptr"><code>capabilities_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="timers"></p>
<hr noshade size="3">
<h2 align="center">タイマー</h2>タイマー関数:
  <ul>
<li>
<a href="#GetCurrentThreadCpuTimerInfo">現在のスレッドのCPUタイマー情報を取得</a>
</li>
<li>
<a href="#GetCurrentThreadCpuTime">現在のスレッドのCPU時間を取得</a>
</li>
<li>
<a href="#GetThreadCpuTimerInfo">スレッドのCPUタイマー情報を取得</a>
</li>
<li>
<a href="#GetThreadCpuTime">スレッドのCPU時間を取得</a>
</li>
<li>
<a href="#GetTimerInfo">タイマー情報の取得</a>
</li>
<li>
<a href="#GetTime">時間の取得</a>
</li>
<li>
<a href="#GetAvailableProcessors">使用可能なプロセッサの取得</a>
</li>
</ul>タイマーの型:
    <ul>
<li>
<a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a> - タイマー情報</li>
<li>
<a href="#jvmtiTimerKind"><code>jvmtiTimerKind</code></a> - タイマーの種類</li>
</ul>
	これらの関数は、タイミング情報を提供します。時間が更新される精度は指定されていません。ナノ秒単位の精度が提供されますが、必ずしもナノ秒単位の精密度が得られるとはかぎりません。最大値など、タイマーの詳細情報には、タイマー情報関数を使ってアクセスできます。  
      <h4 id="jvmtiTimerInfo">タイマー情報</h4>
          各タイマーの情報関数は、このデータ構造体を返します。
        <p></p>
<blockquote>
<pre>typedef struct {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
} jvmtiTimerInfo;</pre>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiTimerInfo</code> - タイマー情報</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.max_value">max_value</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	      タイマーが到達できる最大値。この値に到達すると、タイマーの値はゼロに戻る。これは符号なしの値である。jlong (符号付きの値)としてテストまたは出力した場合、負の数値として表示される場合がある。
	    </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.may_skip_forward">may_skip_forward</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	    trueの場合、タイマーは外部で調整され、結果として前へスキップする。falseの場合、タイマーの値が実際の時間より速く増加することはない。
	  </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.may_skip_backward">may_skip_backward</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	    trueの場合、タイマーは外部で調整され、結果として後ろへスキップする。falseの場合、タイマーの値は一定して増加する。
	  </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.kind">kind</code></td><td><code><a href="#jvmtiTimerKind">jvmtiTimerKind</a></code></td><td>
	    タイマーの種類。ユーザー・タイムとシステム・タイムを区別しないプラットフォームでは、<a href="#JVMTI_TIMER_TOTAL_CPU"><code>JVMTI_TIMER_TOTAL_CPU</code></a>が返される。
	  </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.reserved1">reserved1</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	      将来の使用のために予約済み。
	    </td>
</tr>
<tr>
<td><code id="jvmtiTimerInfo.reserved2">reserved2</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	      将来の使用のために予約済み。
	    </td>
</tr>
</table>
</blockquote>
	タイマーの種類は次のとおりです。

        <blockquote>
<a name="jvmtiTimerKind"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">タイマーの種類(<code>jvmtiTimerKind</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_TIMER_USER_CPU">JVMTI_TIMER_USER_CPU</code></td><td align="right">30</td><td>
            スレッドがユーザー・モードであるCPU時間。
          </td>
</tr>
<tr>
<td><code id="JVMTI_TIMER_TOTAL_CPU">JVMTI_TIMER_TOTAL_CPU</code></td><td align="right">31</td><td>
            スレッドがユーザー・モードまたはシステム・モードであるCPU時間。
          </td>
</tr>
<tr>
<td><code id="JVMTI_TIMER_ELAPSED">JVMTI_TIMER_ELAPSED</code></td><td align="right">32</td><td>
            経過時間。
          </td>
</tr>
</table>
</blockquote>
      
<p></p>
<hr noshade width="100%" size="1" id="GetCurrentThreadCpuTimerInfo">
<h3>現在のスレッドのCPUタイマー情報を取得</h3>
<blockquote>
<pre>jvmtiError
GetCurrentThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)</pre>
</blockquote>
	<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>タイマーの情報を取得します。<a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a>構造体のフィールドに、タイマーの詳細が入ります。この情報は、プラットフォームと<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>の実装に固有なので、スレッドごとに変化したり、VMの呼出し中に変化することはありません。
        <p></p>
        <a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>と<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>の実装は異なることがあり、そのために<code>GetCurrentThreadCpuTimerInfo</code>と<a href="#GetThreadCpuTimerInfo"><code>GetThreadCpuTimerInfo</code></a>によって返される値が異なることがあります。詳細については、<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>134</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a></td><td>
	    現在のスレッドCPU時間を取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetCurrentThreadCpuTimerInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiTimerInfo">jvmtiTimerInfo</a>*</code></td><td>
	    戻ったとき、<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>によって返される時間を説明する情報が入っている。
	  <p></p>エージェントは<code>jvmtiTimerInfo</code>へのポインタを渡す。戻ったとき、<code>jvmtiTimerInfo</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetCurrentThreadCpuTimerInfo.info_ptr"><code>info_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetCurrentThreadCpuTime">
<h3>現在のスレッドのCPU時間を取得</h3>
<blockquote>
<pre>jvmtiError
GetCurrentThreadCpuTime(jvmtiEnv* env,
            jlong* nanos_ptr)</pre>
</blockquote>
            現在のスレッドによって使用されているCPU時間を返します。  
            <p></p>
            <a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>関数は、現在のスレッドを含むあらゆるスレッドのCPU時間を提供します。<code>GetCurrentThreadCpuTime</code>は、現在のスレッドまたは現在のスレッドよりも精密な情報を持つスレッド以外のスレッドのCPU時間を提供できないプラットフォームをサポートします(<a href="#GetCurrentThreadCpuTimerInfo"><code>GetCurrentThreadCpuTimerInfo</code></a>と<a href="#GetThreadCpuTimerInfo"><code>GetThreadCpuTimerInfo</code></a>を参照)。多くのプラットフォームでは、この呼出しは次のコードと同等です。
<blockquote>
<pre>
  GetThreadCpuTime(env, NULL, nanos_ptr)
</pre>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始またはライブ段階でしか呼び出せない
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>135</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a></td><td>
	    現在のスレッドCPU時間を取得できる。
            <p></p>
	    この権限がスレッドの開始後に有効になった場合、実装は、権限が有効になった時間以降の任意の時間を、CPU時間の収集を開始するポイントとして選択できる。
            <p></p>
            この権限は、<a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a>を潜在的に使用できるあらゆるプラットフォームで潜在的に使用可能。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetCurrentThreadCpuTime.nanos_ptr">nanos_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    戻ったとき、このスレッドによって使用されるCPU時間(ナノ秒単位)をポイントする。これは符号なしの値である。jlong (符号付きの値)としてテストまたは出力した場合、負の数値として表示される場合がある。
	  <p></p>エージェントは<code>jlong</code>へのポインタを渡す。戻ったとき、<code>jlong</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_current_thread_cpu_time"><code>can_get_current_thread_cpu_time</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetCurrentThreadCpuTime.nanos_ptr"><code>nanos_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetThreadCpuTimerInfo">
<h3>スレッドのCPUタイマー情報を取得</h3>
<blockquote>
<pre>jvmtiError
GetThreadCpuTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)</pre>
</blockquote>
	<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>タイマーの情報を取得します。<a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a>構造体のフィールドに、タイマーの詳細が入ります。この情報は、プラットフォームと<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>の実装に固有なので、スレッドごとに変化したり、VMの呼出し中に変化することはありません。
        <p></p>
        <a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>と<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>の実装は異なることがあり、そのために<a href="#GetCurrentThreadCpuTimerInfo"><code>GetCurrentThreadCpuTimerInfo</code></a>と<code>GetThreadCpuTimerInfo</code>によって返される値が異なることがあります。詳細については、<a href="#GetCurrentThreadCpuTime"><code>GetCurrentThreadCpuTime</code></a>を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>136</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a></td><td>
	    スレッドCPU時間を取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadCpuTimerInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiTimerInfo">jvmtiTimerInfo</a>*</code></td><td>
	    戻ったとき、<a href="#GetThreadCpuTime"><code>GetThreadCpuTime</code></a>によって返される時間を説明する情報が入っている。
	  <p></p>エージェントは<code>jvmtiTimerInfo</code>へのポインタを渡す。戻ったとき、<code>jvmtiTimerInfo</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadCpuTimerInfo.info_ptr"><code>info_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetThreadCpuTime">
<h3>スレッドのCPU時間を取得</h3>
<blockquote>
<pre>jvmtiError
GetThreadCpuTime(jvmtiEnv* env,
            jthread thread,
            jlong* nanos_ptr)</pre>
</blockquote>
          指定のスレッドによって使用されているCPU時間を返します。 
          <p></p>
	  <a href="#GetThreadCpuTimerInfo"><code>GetThreadCpuTimerInfo</code></a>により、このタイマーの情報を取得します。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>137</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。この関数を使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a></td><td>
	    スレッドCPU時間を取得できる。
            <p></p>
	    この権限がスレッドの開始後に有効になった場合、実装は、権限が有効になった時間以降の任意の時間を、CPU時間の収集を開始するポイントとして選択できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetThreadCpuTime.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	      照会するスレッド。<code>thread</code>が<code>NULL</code>の場合、現在のスレッドが使用される。
  </td>
</tr>
<tr>
<td><code id="GetThreadCpuTime.nanos_ptr">nanos_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    戻ったとき、指定されたスレッドによって使用されるCPU時間(ナノ秒単位)をポイントする。これは符号なしの値である。jlong (符号付きの値)としてテストまたは出力した場合、負の数値として表示される場合がある。
	  <p></p>エージェントは<code>jlong</code>へのポインタを渡す。戻ったとき、<code>jlong</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_MUST_POSSESS_CAPABILITY"><code> JVMTI_ERROR_MUST_POSSESS_CAPABILITY </code></a></td><td>
      環境は権限<a href="#jvmtiCapabilities.can_get_thread_cpu_time"><code>can_get_thread_cpu_time</code></a>を持たない。<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使用する。
    </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_INVALID_THREAD"><code>JVMTI_ERROR_INVALID_THREAD</code></a></td><td>
	  <a href="#GetThreadCpuTime.thread"><code>thread</code></a>はスレッド・オブジェクトではない。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_THREAD_NOT_ALIVE"><code>JVMTI_ERROR_THREAD_NOT_ALIVE</code></a></td><td>
	  <a href="#GetThreadCpuTime.thread"><code>thread</code></a>がライブ・スレッドではない(まだ起動していないか、すでに終了している)。
	    
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetThreadCpuTime.nanos_ptr"><code>nanos_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetTimerInfo">
<h3>タイマー情報の取得</h3>
<blockquote>
<pre>jvmtiError
GetTimerInfo(jvmtiEnv* env,
            jvmtiTimerInfo* info_ptr)</pre>
</blockquote>
	<a href="#GetTime"><code>GetTime</code></a>タイマーの情報を取得します。<a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a>構造体のフィールドに、タイマーの詳細が入ります。この情報は、VMの呼出し中に変更されません。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>138</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetTimerInfo.info_ptr">info_ptr</code></td><td><code><a href="#jvmtiTimerInfo">jvmtiTimerInfo</a>*</code></td><td>
	    戻ったとき、<a href="#GetTime"><code>GetTime</code></a>によって返される時間を説明する情報が入っている。
	  <p></p>エージェントは<code>jvmtiTimerInfo</code>へのポインタを渡す。戻ったとき、<code>jvmtiTimerInfo</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetTimerInfo.info_ptr"><code>info_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetTime">
<h3>時間の取得</h3>
<blockquote>
<pre>jvmtiError
GetTime(jvmtiEnv* env,
            jlong* nanos_ptr)</pre>
</blockquote>
          システム・タイマーの現在の値(ナノ秒単位)を返します。 
          <p></p>
          返される値は、固定された任意の時間からのナノ秒を表します(固定された任意の時間が将来の時間である場合は負の値になる)。この関数では、ナノ秒単位の精度が提供されますが、必ずしもナノ秒単位の精密度が得られるとはかぎりません。値の変更頻度は保証されません。
          <p></p>
	  <a href="#GetTimerInfo"><code>GetTimerInfo</code></a>により、このタイマーの情報を取得します。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>139</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetTime.nanos_ptr">nanos_ptr</code></td><td><code><a href="#jlong">jlong</a>*</code></td><td>
	    戻ったとき、ナノ秒単位で時間をポイントする。これは符号なしの値である。jlong (符号付きの値)としてテストまたは出力した場合、負の数値として表示される場合がある。
	  <p></p>エージェントは<code>jlong</code>へのポインタを渡す。戻ったとき、<code>jlong</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetTime.nanos_ptr"><code>nanos_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetAvailableProcessors">
<h3>使用可能なプロセッサの取得</h3>
<blockquote>
<pre>jvmtiError
GetAvailableProcessors(jvmtiEnv* env,
            jint* processor_count_ptr)</pre>
</blockquote>
          Java仮想マシンが使用できるプロセッサの数を返します。
          <p></p>
          この値は、仮想マシンの呼出し中に変更される可能性があります。このため、使用可能なプロセッサの数に影響を受けるアプリケーションは、ときどきこのプロパティをポーリングする必要があります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>144</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetAvailableProcessors.processor_count_ptr">processor_count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、仮想マシンが使用できる最大プロセッサ数をポイントする(必ず1以上)。  
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetAvailableProcessors.processor_count_ptr"><code>processor_count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="classLoaderSearch"></p>
<hr noshade size="3">
<h2 align="center">クラス・ローダー検索</h2>クラス・ローダー検索の関数:
  <ul>
<li>
<a href="#AddToBootstrapClassLoaderSearch">ブートストラップ・クラス・ローダー検索の追加</a>
</li>
<li>
<a href="#AddToSystemClassLoaderSearch">システム・クラス・ローダー検索の追加</a>
</li>
</ul>
      これらの関数を使えば、エージェントは、クラス・ローダーがクラスを検索する際の場所を追加できます。これは、正しいクラス・ローダーでインストゥルメンテーションをインストールする際に便利です。
    <p></p>
<hr noshade width="100%" size="1" id="AddToBootstrapClassLoaderSearch">
<h3>ブートストラップ・クラス・ローダー検索の追加</h3>
<blockquote>
<pre>jvmtiError
AddToBootstrapClassLoaderSearch(jvmtiEnv* env,
            const char* segment)</pre>
</blockquote>
          この関数では、ブートストラップ・クラス・ローダーを使用してインストゥルメンテーション・クラスを定義できます。<cite>Java(tm)仮想マシン仕様のセクション5.3.1</cite>を参照してください。ブートストラップ・クラス・ローダーによるクラスの検索が失敗すると、指定されたプラットフォーム依存の検索パス<a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>も検索されます。<a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>に指定できるセグメントは1つのみです。この関数を複数回呼び出せば、複数のセグメントを追加できます。セグメントの検索は、この関数が呼び出された順番で行われます。
	  <p></p>
	  <code>OnLoad</code>段階でこの関数を使うと、ブートストラップ・クラス・ローダーがクラスの検索に失敗した際に、追加で検索する任意のプラットフォーム依存の検索パス・セグメントを指定できます。このセグメントは通常、ディレクトリとJARファイルのいずれかになります。
	  <p></p>	  
	  ライブ段階で<a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>を使うと、任意のプラットフォーム依存の<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html">JARファイル</a>へのパスを指定できます。ブートストラップ・クラス・ローダーがインストゥルメンテーション目的で定義するクラスやリソース以外のものがJARファイルに含まれないように、エージェントで確認するようにしてください。
          <p></p>
          
<cite>Java(tm)仮想マシン仕様</cite>には、Java仮想マシンが以前にシンボリック参照を解決しようとして失敗した場合、その後このシンボリック参照を解決しようとしても、最初に解決しようとした結果としてスローされたエラーと同じエラーで必ず失敗すると記述されています。したがって、Java仮想マシンが参照を解決できなかったクラスに対応するエントリがJARファイルに含まれる場合、その参照を解決しようとしても最初のエラーと同じエラーで失敗します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>149</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="AddToBootstrapClassLoaderSearch.segment">segment</code></td><td><code>const char*</code></td><td>
	    プラットフォーム依存の検索パス・セグメント、<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  <p></p>エージェントは、<code>char</code>の配列を渡す。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>   
          <a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>が無効なパス。ライブ段階では、既存のJARファイル以外はすべて無効なパスとなる。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#AddToBootstrapClassLoaderSearch.segment"><code>segment</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="AddToSystemClassLoaderSearch">
<h3>システム・クラス・ローダー検索の追加</h3>
<blockquote>
<pre>jvmtiError
AddToSystemClassLoaderSearch(jvmtiEnv* env,
            const char* segment)</pre>
</blockquote>
	  この関数では、システム・クラス・ローダーを使用してインストゥルメンテーション・クラスを定義できます。<cite>Java(tm)仮想マシン仕様のセクション5.3.2</cite>を参照してください。クラス・ローダーによるクラスの検索が失敗すると、指定されたプラットフォーム依存の検索パス<a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>も検索されます。<a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>に指定できるセグメントは1つのみです。この関数を複数回呼び出せば、複数のセグメントを追加できます。セグメントの検索は、この関数が呼び出された順番で行われます。
	  <p></p>
	  <code>OnLoad</code>段階でこの関数を使うと、システム・クラス・ローダーがクラスの検索に失敗した際に、追加で検索する任意のプラットフォーム依存の検索パス・セグメントを指定できます。このセグメントは通常、ディレクトリとJARファイルのいずれかになります。
	  <p></p>	  
	  ライブ段階では、<a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>は、システム・クラス・ローダーがクラスの検索に失敗した際に、追加で検索するプラットフォーム依存の<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html">JARファイル</a>へのパスになります。システム・クラス・ローダーがインストゥルメンテーション目的で定義するクラスやリソース以外のものがJARファイルに含まれないように、エージェントで確認するようにしてください。
          <p></p>
	  ライブ段階でシステム・クラス・ローダーが検索対象JARファイルの追加をサポートするのは、<code>java.lang.String</code>型の単一パラメータを取る<code>appendToClassPathForInstrumentation</code>という名前のメソッドをシステム・クラス・ローダーが実装している場合です。このメソッドは、<code>public</code>アクセスを備えていなくてもかまいません。 
	  <p></p>
          
<cite>Java(tm)仮想マシン仕様</cite>には、Java仮想マシンが以前にシンボリック参照を解決しようとして失敗した場合、その後このシンボリック参照を解決しようとしても、最初に解決しようとした結果としてスローされたエラーと同じエラーで必ず失敗すると記述されています。したがって、Java仮想マシンが参照を解決できなかったクラスに対応するエントリがJARファイルに含まれる場合、その参照を解決しようとしても最初のエラーと同じエラーで失敗します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>151</td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="AddToSystemClassLoaderSearch.segment">segment</code></td><td><code>const char*</code></td><td>
            プラットフォーム依存の検索パス・セグメント、<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
          <p></p>エージェントは、<code>char</code>の配列を渡す。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
          <a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>が無効なパス。ライブ段階では、既存のJARファイル以外はすべて無効なパスとなる。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED"><code>JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED</code></a></td><td>
	  システム・クラス・ローダーがサポートしない操作。
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
          <a href="#AddToSystemClassLoaderSearch.segment"><code>segment</code></a>が<code>NULL</code>。
          
        </td>
</tr>
</table>
<p id="props"></p>
<hr noshade size="3">
<h2 align="center">システム・プロパティ</h2>システム・プロパティ関数:
  <ul>
<li>
<a href="#GetSystemProperties">システム・プロパティの取得</a>
</li>
<li>
<a href="#GetSystemProperty">システム・プロパティの取得</a>
</li>
<li>
<a href="#SetSystemProperty">システム・プロパティの設定</a>
</li>
</ul>
      これらの関数は、システム・プロパティを取得および設定します。
    <p></p>
<hr noshade width="100%" size="1" id="GetSystemProperties">
<h3>システム・プロパティの取得</h3>
<blockquote>
<pre>jvmtiError
GetSystemProperties(jvmtiEnv* env,
            jint* count_ptr,
            char*** property_ptr)</pre>
</blockquote>
        <a href="#GetSystemProperty"><code>GetSystemProperty</code></a>で使用可能なVMシステム・プロパティ・キーのリストが返されます。仮想マシンが次のプロパティ・キーを提供するようにすることを強くお勧めします。
        <ul type="disc">
          
<li>
<code>java.vm.vendor</code>
</li>
          
<li>
<code>java.vm.version</code>
</li>
          
<li>
<code>java.vm.name</code>
</li>
          
<li>
<code>java.vm.info</code>
</li>
          
<li>
<code>java.library.path</code>
</li>
          
<li>
<code>java.class.path</code>
</li>
        
</ul>
        VMによって定義され、使用されるシステム・プロパティへのアクセスを提供します。コマンド行で設定されたプロパティも含まれます。これにより、これらのプロパティを、VMがバイト・コードの実行を開始する前に取得、設定できます。これはシステム・プロパティのVMビューなので、使用可能なプロパティのセットは、通常、<code>java.lang.System.getProperties</code>内のプロパティ・セットとは異なります。<code>java.lang.System.getProperties</code>のアクセスには、JNIメソッド呼出しを使用できます。
        <p></p>
        プロパティのセットは、実行中に増えることがあります。	  
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>130</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetSystemProperties.count_ptr">count_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、返されるプロパティ・キーの数をポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
<tr>
<td><code id="GetSystemProperties.property_ptr">property_ptr</code></td><td><code>char***</code></td><td>
	    戻ったとき、プロパティ・キーの配列(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char**</code>へのポインタを渡す。<code>char**</code>は復帰時に、新しく割り当てられたサイズ<code>*count_ptr</code>の配列(各要素も新しく割り当てられる)をポイントしている。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。各要素は<a href="#Deallocate"><code>Deallocate</code></a>で解放すべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetSystemProperties.count_ptr"><code>count_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetSystemProperties.property_ptr"><code>property_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetSystemProperty">
<h3>システム・プロパティの取得</h3>
<blockquote>
<pre>jvmtiError
GetSystemProperty(jvmtiEnv* env,
            const char* property,
            char** value_ptr)</pre>
</blockquote>
        プロパティ・キーによって指定されたVMシステム・プロパティの値を返します。  
        <p></p>
	関数<a href="#GetSystemProperties"><code>GetSystemProperties</code></a>は、使用可能なプロパティ・キーのセットを返します。取得可能なプロパティは、実行中に増えることがあります。
        <p></p>
	これはシステム・プロパティのVMビューなので、プロパティの値は、<code>java.lang.System.getProperty(String)</code>によって返されるプロパティの値とは異なります。通常のVMは、クラスの初期化中に、VMシステム・プロパティの値を<code>java.lang.System</code>に格納されている<code>Properties</code>にコピーできます。その後、<a href="#SetSystemProperty"><code>SetSystemProperty</code></a>を使用してVMシステム・プロパティを変更したり、<code>java.lang.System.setProperty(String,String)</code>を使用して<code>java.lang.System</code>システム・プロパティを変更したりすると、値が変更されます。<code>java.lang.System.getProperty(String)</code>のアクセスには、JNIメソッド呼出しを使用できます。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  OnLoadまたはライブ段階でしか呼び出せない
</td><td>
      いいえ
    </td><td>131</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetSystemProperty.property">property</code></td><td><code>const char*</code></td><td>
	    取得されるプロパティのキー。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  <p></p>エージェントは、<code>char</code>の配列を渡す。 </td>
</tr>
<tr>
<td><code id="GetSystemProperty.value_ptr">value_ptr</code></td><td><code>char**</code></td><td>
	    戻ったとき、プロパティの値(<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる)をポイントする。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a></td><td> 
          このプロパティを使用できない。<a href="#GetSystemProperties"><code>GetSystemProperties</code></a>を使って、使用可能なプロパティを検索する。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetSystemProperty.property"><code>property</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetSystemProperty.value_ptr"><code>value_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetSystemProperty">
<h3>システム・プロパティの設定</h3>
<blockquote>
<pre>jvmtiError
SetSystemProperty(jvmtiEnv* env,
            const char* property,
            const char* value_ptr)</pre>
</blockquote>
        VMシステム・プロパティの値を設定します。  
        <p></p>
	関数<a href="#GetSystemProperties"><code>GetSystemProperties</code></a>は、プロパティ・キーのセットを返します。そのうちのいくつかは設定可能です。<a href="#GetSystemProperty"><code>GetSystemProperty</code></a>を参照してください。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  できるOnLoad段階でしか呼び出せない段階
</td><td>
      いいえ
    </td><td>132</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetSystemProperty.property">property</code></td><td><code>const char*</code></td><td>
	    プロパティのキー。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  <p></p>エージェントは、<code>char</code>の配列を渡す。 </td>
</tr>
<tr>
<td><code id="SetSystemProperty.value_ptr">value_ptr</code></td><td><code>const char *</code></td><td>
	    設定するプロパティ値。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	  <p></p>エージェントは、<code>char</code>の配列を渡す。<code>value_ptr</code>が<code>NULL</code>の場合は値が設定されないが、プロパティが書込み可能でない場合は<a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a>が返される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NOT_AVAILABLE"><code>JVMTI_ERROR_NOT_AVAILABLE</code></a></td><td> 
          このプロパティを使用できない、またはこのプロパティは書込み可能でない。
        </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#SetSystemProperty.property"><code>property</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="general"></p>
<hr noshade size="3">
<h2 align="center">全般</h2>全般関数:
  <ul>
<li>
<a href="#GetPhase">段階の取得</a>
</li>
<li>
<a href="#DisposeEnvironment">環境の破棄</a>
</li>
<li>
<a href="#SetEnvironmentLocalStorage">環境ローカル記憶領域の設定</a>
</li>
<li>
<a href="#GetEnvironmentLocalStorage">環境ローカル記憶領域の取得</a>
</li>
<li>
<a href="#GetVersionNumber">バージョン番号の取得</a>
</li>
<li>
<a href="#GetErrorName">エラー名の取得</a>
</li>
<li>
<a href="#SetVerboseFlag">冗長フラグの設定</a>
</li>
<li>
<a href="#GetJLocationFormat">JLocation形式の取得</a>
</li>
</ul>全般の型:
    <ul>
<li>
<a href="#jvmtiPhase"><code>jvmtiPhase</code></a> - 実行の段階</li>
<li>
<a href="#jvmtiVerboseFlag"><code>jvmtiVerboseFlag</code></a> - 冗長フラグの列挙</li>
<li>
<a href="#jvmtiJlocationFormat"><code>jvmtiJlocationFormat</code></a> - JLocationの形式の列挙</li>
</ul>全般のフラグおよび定数:
    <ul>
<li>
<a href="#jvmtiVersionInterfaceTypes">バージョンのインタフェースの型</a>
</li>
<li>
<a href="#jvmtiVersionMasks">バージョン・マスク</a>
</li>
<li>
<a href="#jvmtiVersionShifts">バージョン・シフト</a>
</li>
</ul>
    
<p></p>
<hr noshade width="100%" size="1" id="GetPhase">
<h3>段階の取得</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;</pre>
<pre>jvmtiError
GetPhase(jvmtiEnv* env,
            jvmtiPhase* phase_ptr)</pre>
</blockquote>
          VM実行の現在の段階を返します。段階は次の順で進行します。
          <blockquote>
<a name="jvmtiPhase"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">実行の段階(<code>jvmtiPhase</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_ONLOAD">JVMTI_PHASE_ONLOAD</code></td><td align="right">1</td><td>
              <code>OnLoad</code>段階: <a href="#onload"><code>Agent_OnLoad</code></a>関数内(静的リンク・エージェントの場合は<a href="#onload"><code>Agent_OnLoad_&lt;agent-lib-name></code></a>関数内)の期間。
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_PRIMORDIAL">JVMTI_PHASE_PRIMORDIAL</code></td><td align="right">2</td><td>
              初期段階: <code>Agent_OnLoad</code>または<code>Agent_OnLoad_&lt;agent-lib-name></code>から復帰してから、<code>VMStart</code>イベントが開始されるまでの間。
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_START">JVMTI_PHASE_START</code></td><td align="right">6</td><td>
              開始段階: <a href="#VMStart"><code>VMStart</code></a>イベントが送信されてから<code>VMInit</code>イベントが送信されるまで。
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_LIVE">JVMTI_PHASE_LIVE</code></td><td align="right">4</td><td>
              ライブ段階: <a href="#VMInit"><code>VMInit</code></a>イベントが送信されてから<a href="#VMDeath"><code>VMDeath</code></a>イベントが返されるまで。
            </td>
</tr>
<tr>
<td><code id="JVMTI_PHASE_DEAD">JVMTI_PHASE_DEAD</code></td><td align="right">8</td><td>
              デッド段階: <a href="#VMDeath"><code>VMDeath</code></a>イベントが返されてから、または起動に失敗してから。
            </td>
</tr>
</table>
</blockquote>
          起動に失敗した場合、VMは中間の段階を省略して直接デッド段階に進みます。この場合、<code>VMInit</code>イベントも<code>VMDeath</code>イベントも送信されません。
          <p></p>
          ほとんどのJVM<small style="font-size: xx-small">&nbsp;</small>TI関数は、ライブ段階でしか動作しません。次の関数は、<code>OnLoad</code>段階でもライブ段階でも動作します。
          <ul>
<li>
<a href="#CreateRawMonitor"><b>CreateRawMonitor</b></a>
</li>
<li>
<a href="#DestroyRawMonitor"><b>DestroyRawMonitor</b></a>
</li>
<li>
<a href="#SetEventCallbacks"><b>SetEventCallbacks</b></a>
</li>
<li>
<a href="#SetEventNotificationMode"><b>SetEventNotificationMode</b></a>
</li>
<li>
<a href="#GetExtensionFunctions"><b>GetExtensionFunctions</b></a>
</li>
<li>
<a href="#GetExtensionEvents"><b>GetExtensionEvents</b></a>
</li>
<li>
<a href="#SetExtensionEventCallback"><b>SetExtensionEventCallback</b></a>
</li>
<li>
<a href="#GetPotentialCapabilities"><b>GetPotentialCapabilities</b></a>
</li>
<li>
<a href="#AddCapabilities"><b>AddCapabilities</b></a>
</li>
<li>
<a href="#RelinquishCapabilities"><b>RelinquishCapabilities</b></a>
</li>
<li>
<a href="#AddToBootstrapClassLoaderSearch"><b>AddToBootstrapClassLoaderSearch</b></a>
</li>
<li>
<a href="#AddToSystemClassLoaderSearch"><b>AddToSystemClassLoaderSearch</b></a>
</li>
<li>
<a href="#GetSystemProperties"><b>GetSystemProperties</b></a>
</li>
<li>
<a href="#GetSystemProperty"><b>GetSystemProperty</b></a>
</li>
</ul>
          次の関数は、<code>OnLoad</code>段階でのみ動作します。
          <ul>
<li>
<a href="#SetSystemProperty"><b>SetSystemProperty</b></a>
</li>
</ul>
          次の関数は、開始段階でもライブ段階でも動作します。
          <ul>
<li>
<a href="#GetCurrentThread"><b>GetCurrentThread</b></a>
</li>
<li>
<a href="#SetThreadLocalStorage"><b>SetThreadLocalStorage</b></a>
</li>
<li>
<a href="#GetThreadLocalStorage"><b>GetThreadLocalStorage</b></a>
</li>
<li>
<a href="#GetTag"><b>GetTag</b></a>
</li>
<li>
<a href="#SetTag"><b>SetTag</b></a>
</li>
<li>
<a href="#GetClassSignature"><b>GetClassSignature</b></a>
</li>
<li>
<a href="#GetClassStatus"><b>GetClassStatus</b></a>
</li>
<li>
<a href="#GetSourceFileName"><b>GetSourceFileName</b></a>
</li>
<li>
<a href="#GetClassModifiers"><b>GetClassModifiers</b></a>
</li>
<li>
<a href="#GetClassMethods"><b>GetClassMethods</b></a>
</li>
<li>
<a href="#GetClassFields"><b>GetClassFields</b></a>
</li>
<li>
<a href="#GetImplementedInterfaces"><b>GetImplementedInterfaces</b></a>
</li>
<li>
<a href="#GetClassVersionNumbers"><b>GetClassVersionNumbers</b></a>
</li>
<li>
<a href="#GetConstantPool"><b>GetConstantPool</b></a>
</li>
<li>
<a href="#IsInterface"><b>IsInterface</b></a>
</li>
<li>
<a href="#IsArrayClass"><b>IsArrayClass</b></a>
</li>
<li>
<a href="#IsModifiableClass"><b>IsModifiableClass</b></a>
</li>
<li>
<a href="#GetClassLoader"><b>GetClassLoader</b></a>
</li>
<li>
<a href="#GetSourceDebugExtension"><b>GetSourceDebugExtension</b></a>
</li>
<li>
<a href="#GetObjectSize"><b>GetObjectSize</b></a>
</li>
<li>
<a href="#GetObjectHashCode"><b>GetObjectHashCode</b></a>
</li>
<li>
<a href="#GetFieldName"><b>GetFieldName</b></a>
</li>
<li>
<a href="#GetFieldDeclaringClass"><b>GetFieldDeclaringClass</b></a>
</li>
<li>
<a href="#GetFieldModifiers"><b>GetFieldModifiers</b></a>
</li>
<li>
<a href="#IsFieldSynthetic"><b>IsFieldSynthetic</b></a>
</li>
<li>
<a href="#GetMethodName"><b>GetMethodName</b></a>
</li>
<li>
<a href="#GetMethodDeclaringClass"><b>GetMethodDeclaringClass</b></a>
</li>
<li>
<a href="#GetMethodModifiers"><b>GetMethodModifiers</b></a>
</li>
<li>
<a href="#GetMaxLocals"><b>GetMaxLocals</b></a>
</li>
<li>
<a href="#GetArgumentsSize"><b>GetArgumentsSize</b></a>
</li>
<li>
<a href="#GetLineNumberTable"><b>GetLineNumberTable</b></a>
</li>
<li>
<a href="#GetMethodLocation"><b>GetMethodLocation</b></a>
</li>
<li>
<a href="#GetBytecodes"><b>GetBytecodes</b></a>
</li>
<li>
<a href="#IsMethodNative"><b>IsMethodNative</b></a>
</li>
<li>
<a href="#IsMethodSynthetic"><b>IsMethodSynthetic</b></a>
</li>
<li>
<a href="#IsMethodObsolete"><b>IsMethodObsolete</b></a>
</li>
<li>
<a href="#SetJNIFunctionTable"><b>SetJNIFunctionTable</b></a>
</li>
<li>
<a href="#GetJNIFunctionTable"><b>GetJNIFunctionTable</b></a>
</li>
<li>
<a href="#GetCurrentThreadCpuTimerInfo"><b>GetCurrentThreadCpuTimerInfo</b></a>
</li>
<li>
<a href="#GetCurrentThreadCpuTime"><b>GetCurrentThreadCpuTime</b></a>
</li>
</ul>
          次の関数は、どの段階でも動作します。
          <ul>
<li>
<a href="#Allocate"><b>Allocate</b></a>
</li>
<li>
<a href="#Deallocate"><b>Deallocate</b></a>
</li>
<li>
<a href="#SetNativeMethodPrefix"><b>SetNativeMethodPrefix</b></a>
</li>
<li>
<a href="#SetNativeMethodPrefixes"><b>SetNativeMethodPrefixes</b></a>
</li>
<li>
<a href="#RawMonitorEnter"><b>RawMonitorEnter</b></a>
</li>
<li>
<a href="#RawMonitorExit"><b>RawMonitorExit</b></a>
</li>
<li>
<a href="#RawMonitorWait"><b>RawMonitorWait</b></a>
</li>
<li>
<a href="#RawMonitorNotify"><b>RawMonitorNotify</b></a>
</li>
<li>
<a href="#RawMonitorNotifyAll"><b>RawMonitorNotifyAll</b></a>
</li>
<li>
<a href="#GetCapabilities"><b>GetCapabilities</b></a>
</li>
<li>
<a href="#GetTimerInfo"><b>GetTimerInfo</b></a>
</li>
<li>
<a href="#GetTime"><b>GetTime</b></a>
</li>
<li>
<a href="#GetAvailableProcessors"><b>GetAvailableProcessors</b></a>
</li>
<li>
<a href="#GetPhase"><b>GetPhase</b></a>
</li>
<li>
<a href="#DisposeEnvironment"><b>DisposeEnvironment</b></a>
</li>
<li>
<a href="#SetEnvironmentLocalStorage"><b>SetEnvironmentLocalStorage</b></a>
</li>
<li>
<a href="#GetEnvironmentLocalStorage"><b>GetEnvironmentLocalStorage</b></a>
</li>
<li>
<a href="#GetVersionNumber"><b>GetVersionNumber</b></a>
</li>
<li>
<a href="#GetErrorName"><b>GetErrorName</b></a>
</li>
<li>
<a href="#SetVerboseFlag"><b>SetVerboseFlag</b></a>
</li>
<li>
<a href="#GetJLocationFormat"><b>GetJLocationFormat</b></a>
</li>
</ul>
          JNI関数(呼び出しAPIを除く)は、開始段階またはライブ段階で使用する必要があります。
          <p></p>
          ほとんどのJVM<small style="font-size: xx-small">&nbsp;</small>TIイベントは、ライブ段階でしか送信されません。次のイベントは、その他の段階で扱われます。
          <ul>
<li>
<a href="#ThreadStart"><b>ThreadStart</b></a>
</li>
<li>
<a href="#ThreadEnd"><b>ThreadEnd</b></a>
</li>
<li>
<a href="#ClassLoad"><b>ClassLoad</b></a>
</li>
<li>
<a href="#ClassPrepare"><b>ClassPrepare</b></a>
</li>
<li>
<a href="#VMStart"><b>VMStart</b></a>
</li>
</ul>          
          
<ul>
<li>
<a href="#NativeMethodBind"><b>NativeMethodBind</b></a>
</li>
<li>
<a href="#ClassFileLoadHook"><b>ClassFileLoadHook</b></a>
</li>
<li>
<a href="#DynamicCodeGenerated"><b>DynamicCodeGenerated</b></a>
</li>
</ul>          
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>133</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetPhase.phase_ptr">phase_ptr</code></td><td><code><a href="#jvmtiPhase">jvmtiPhase</a>*</code></td><td>
	    戻ったとき、段階をポイントする。
	  <p></p>エージェントは<code>jvmtiPhase</code>へのポインタを渡す。戻ったとき、<code>jvmtiPhase</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetPhase.phase_ptr"><code>phase_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="DisposeEnvironment">
<h3>環境の破棄</h3>
<blockquote>
<pre>jvmtiError
DisposeEnvironment(jvmtiEnv* env)</pre>
</blockquote>
        JNI <code>GetEnv</code>で作成されたJVM<small style="font-size: xx-small">&nbsp;</small>TI接続をシャットダウンします(「<a href="#environments">JVM<small style="font-size: xx-small">&nbsp;</small>TI環境</a>」を参照)。環境が保持していたリソースをすべて破棄します。この環境によって中断されたスレッドは、この呼出しによって再開されません。これはエージェントが明示的に行う必要があります。この環境によってJVM<small style="font-size: xx-small">&nbsp;</small>TI関数呼出し経由で割り当てられたメモリーは、解放されません。これをエージェントから明示的に行うには、<a href="#Deallocate"><code>Deallocate</code></a>を呼び出します。この環境によって作成されたrawモニターは破棄されません。これをエージェントから明示的に行うには、<a href="#DestroyRawMonitor"><code>DestroyRawMonitor</code></a>を呼び出します。この環境によって作成されたrawモニター上で待機しているスレッドの状態は、何の影響も受けません。
        <p></p>
        この環境の<a href="#SetNativeMethodPrefix">ネイティブ・メソッド接頭辞</a>はすべて設定解除されます。エージェントは、破棄を呼び出す前に接頭辞付きネイティブ・メソッドをすべて削除しなければなりません。
        <p></p>
        この環境で保持されている<a href="#capability">権限</a>はすべて放棄されます。
        <p></p>
        この環境で有効化されたイベントは送信されなくなりますが、現在実行中のイベント・ハンドラは引き続き実行されます。環境が破棄されたために実行中に無効になる可能性のあるイベント・ハンドラを設計する際には、十分に注意を払う必要があります。
        <p></p>
        この環境は、この呼出しのあとは使用できません。この呼出しは呼出し元に戻ります。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>127</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>を返します</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetEnvironmentLocalStorage">
<h3>環境ローカル記憶領域の設定</h3>
<blockquote>
<pre>jvmtiError
SetEnvironmentLocalStorage(jvmtiEnv* env,
            const void* data)</pre>
</blockquote>
	VMは、個々の環境に関連付けられているポインタ値を格納します。このポインタ値を<i>環境ローカルな記憶領域</i>と呼びます。この関数で設定されない場合、値は<code>NULL</code>になります。エージェントは、環境固有の情報を格納するため、メモリーを割り当てることができます。環境ローカルな記憶領域を設定することにより、<a href="#GetEnvironmentLocalStorage"><code>GetEnvironmentLocalStorage</code></a>を使ってアクセスできるようになります。
	<p></p>
        JVM<small style="font-size: xx-small">&nbsp;</small>TIの環境ローカルな記憶領域の値を設定するため、エージェントによって呼び出されます。JVM<small style="font-size: xx-small">&nbsp;</small>TIは、エージェントに対して、環境ごとの情報を記録するために利用できる、ポインタ・サイズの環境ローカルな記憶領域を提供します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>148</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetEnvironmentLocalStorage.data">data</code></td><td><code>const void *</code></td><td>
	    環境ローカルな記憶領域に入力する値。
	  <p></p>エージェントがポインタを渡す。<code>data</code>が<code>NULL</code>の場合、値は<code>NULL</code>に設定される。
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>を返します</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetEnvironmentLocalStorage">
<h3>環境ローカル記憶領域の取得</h3>
<blockquote>
<pre>jvmtiError
GetEnvironmentLocalStorage(jvmtiEnv* env,
            void** data_ptr)</pre>
</blockquote>
        JVM<small style="font-size: xx-small">&nbsp;</small>TIの環境ローカルな記憶領域の値を取得するため、エージェントによって呼び出されます。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
    この関数は<a href="#Heap">Heap</a>反復関数のコールバックから、または<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>イベント、<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>イベント、<a href="#ObjectFree"><code>ObjectFree</code></a>イベントから呼び出せます。
    </td><td>147</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetEnvironmentLocalStorage.data_ptr">data_ptr</code></td><td><code>void**</code></td><td>
	    環境ローカルな記憶領域の値を返すポインタ。環境ローカルな記憶領域が<a href="#SetEnvironmentLocalStorage"><code>SetEnvironmentLocalStorage</code></a>で設定されていない場合、返されるポインタは<code>NULL</code>。
	  <p></p>
</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetEnvironmentLocalStorage.data_ptr"><code>data_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetVersionNumber">
<h3>バージョン番号の取得</h3>
<blockquote>
<pre>jvmtiError
GetVersionNumber(jvmtiEnv* env,
            jint* version_ptr)</pre>
</blockquote>
        JVM<small style="font-size: xx-small">&nbsp;</small>TIのバージョンが<code>version_ptr</code>によって返されます。戻り値はバージョン識別子です。バージョン識別子には、インタフェースの型と、メジャー・バージョン番号、マイナー・バージョン番号、マイクロ・バージョン番号が含まれます。
	<blockquote>
<a name="jvmtiVersionInterfaceTypes"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">バージョンのインタフェースの型</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_INTERFACE_JNI">JVMTI_VERSION_INTERFACE_JNI</code></td><td align="right">0x00000000</td><td>
	    JNIの<code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code>の値。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_INTERFACE_JVMTI">JVMTI_VERSION_INTERFACE_JVMTI</code></td><td align="right">0x30000000</td><td>
	    JVM<small style="font-size: xx-small">&nbsp;</small>TIの<code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code>の値。
	  </td>
</tr>
</table>
</blockquote>
	
<blockquote>
<a name="jvmtiVersionMasks"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">バージョン・マスク</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_INTERFACE_TYPE">JVMTI_VERSION_MASK_INTERFACE_TYPE</code></td><td align="right">0x70000000</td><td>
	    マスクにより、インタフェースの型を抽出する。これはJVM<small style="font-size: xx-small">&nbsp;</small>TI関数なので、<code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code>でマスクされた、この関数によって返されるバージョンの値は、常に<code>JVMTI_VERSION_INTERFACE_JVMTI</code>。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_MAJOR">JVMTI_VERSION_MASK_MAJOR</code></td><td align="right">0x0FFF0000</td><td>
	    マスクにより、メジャー・バージョン番号を抽出する。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_MINOR">JVMTI_VERSION_MASK_MINOR</code></td><td align="right">0x0000FF00</td><td>
	    マスクにより、マイナー・バージョン番号を抽出する。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_MASK_MICRO">JVMTI_VERSION_MASK_MICRO</code></td><td align="right">0x000000FF</td><td>
	    マスクにより、マイクロ・バージョン番号を抽出する。
	  </td>
</tr>
</table>
</blockquote>
	
<blockquote>
<a name="jvmtiVersionShifts"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">バージョン・シフト</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_SHIFT_MAJOR">JVMTI_VERSION_SHIFT_MAJOR</code></td><td align="right">16</td><td>
	    シフトにより、メジャー・バージョン番号を抽出する。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_SHIFT_MINOR">JVMTI_VERSION_SHIFT_MINOR</code></td><td align="right">8</td><td>
	    シフトにより、マイナー・バージョン番号を抽出する。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERSION_SHIFT_MICRO">JVMTI_VERSION_SHIFT_MICRO</code></td><td align="right">0</td><td>
	    シフトにより、マイクロ・バージョン番号を抽出する。
	  </td>
</tr>
</table>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>88</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetVersionNumber.version_ptr">version_ptr</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	    戻ったとき、JVM<small style="font-size: xx-small">&nbsp;</small>TIのバージョンをポイントする。
	  <p></p>エージェントは<code>jint</code>へのポインタを渡す。戻ったとき、<code>jint</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetVersionNumber.version_ptr"><code>version_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetErrorName">
<h3>エラー名の取得</h3>
<blockquote>
<pre>jvmtiError
GetErrorName(jvmtiEnv* env,
            jvmtiError error,
            char** name_ptr)</pre>
</blockquote>
        <a href="#ErrorSection">エラー・コード</a>のシンボリック名を返します。  
        <p></p>
	たとえば、<code>GetErrorName(env, JVMTI_ERROR_NONE,&amp;err_name)</code>は、<code>err_name</code>に文字列<code>"JVMTI_ERROR_NONE"</code>を返します。
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>128</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetErrorName.error">error</code></td><td><code><a href="#jvmtiError">jvmtiError</a></code></td><td>
	    エラー・コード。
	  </td>
</tr>
<tr>
<td><code id="GetErrorName.name_ptr">name_ptr</code></td><td><code>char**</code></td><td>
	    戻ったとき、エラー名をポイントする。名前は、<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされるが、ASCIIサブセットに制限される。
	  <p></p>エージェントは<code>char*</code>へのポインタを渡す。戻り時に、<code>char*</code>は、新しく割り当てられた配列をポイントする。この配列は、<a href="#Deallocate"><code>Deallocate</code></a>を使って解放するべき。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#GetErrorName.error"><code>error</code></a>がjvmtiErrorではない。
	  
	</td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetErrorName.name_ptr"><code>name_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="SetVerboseFlag">
<h3>冗長フラグの設定</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;</pre>
<pre>jvmtiError
SetVerboseFlag(jvmtiEnv* env,
            jvmtiVerboseFlag flag,
            jboolean value)</pre>
</blockquote>
	
<blockquote>
<a name="jvmtiVerboseFlag"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">冗長フラグの列挙(<code>jvmtiVerboseFlag</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_OTHER">JVMTI_VERBOSE_OTHER</code></td><td align="right">0</td><td>
	    冗長出力(以下を除く)。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_GC">JVMTI_VERBOSE_GC</code></td><td align="right">1</td><td>
	    冗長ガベージ・コレクタ出力(<code>-verbose:gc</code>で指定されたものと同様)。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_CLASS">JVMTI_VERBOSE_CLASS</code></td><td align="right">2</td><td>
	    冗長クラス・ロード出力(<code>-verbose:class</code>で指定されたものと同様)。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_VERBOSE_JNI">JVMTI_VERBOSE_JNI</code></td><td align="right">4</td><td>
	    冗長JNI出力(<code>-verbose:jni</code>で指定されたものと同様)。
	  </td>
</tr>
</table>
</blockquote>
	冗長出力を制御します。これは、通常<code>stderr</code>に送信される出力です。 
      <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>150</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SetVerboseFlag.flag">flag</code></td><td><code><a href="#jvmtiVerboseFlag">jvmtiVerboseFlag</a></code></td><td>
	    どの冗長フラグを設定するか。
	  </td>
</tr>
<tr>
<td><code id="SetVerboseFlag.value">value</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	    フラグの新しい値。
	  </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_ILLEGAL_ARGUMENT"><code>JVMTI_ERROR_ILLEGAL_ARGUMENT</code></a></td><td>
	  <a href="#SetVerboseFlag.flag"><code>flag</code></a>はjvmtiVerboseFlagではない。
	  
	</td>
</tr>
</table>
<hr noshade width="100%" size="1" id="GetJLocationFormat">
<h3>JLocation形式の取得</h3>
<blockquote>
<pre>
typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;</pre>
<pre>jvmtiError
GetJLocationFormat(jvmtiEnv* env,
            jvmtiJlocationFormat* format_ptr)</pre>
</blockquote>
        仮想マシンのバイト・コード・インデックスを参照する位置情報から最大の機能が得られますが、<code>jlocation</code>の定義は、この情報を持たないVM実装を許可するため、意図的に制約を受けていません。
        <p></p>
        この関数は、このVMで使用される<code>jlocation</code>の表現を説明します。返される形式が<a href="#JVMTI_JLOCATION_JVMBCI"><code>JVMTI_JLOCATION_JVMBCI</code></a>の場合、<code>jlocation</code>を、<a href="#GetBytecodes"><code>GetBytecodes</code></a>から返される配列のインデックスとして使用できます。  
	<blockquote>
<a name="jvmtiJlocationFormat"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">JLocationの形式の列挙(<code>jvmtiJlocationFormat</code>)</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_JLOCATION_JVMBCI">JVMTI_JLOCATION_JVMBCI</code></td><td align="right">1</td><td>
	    <code>jlocation</code>の値は、仮想マシンのバイト・コード・インデックスを表す。つまり、メソッドの仮想マシン・コードのオフセット。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JLOCATION_MACHINEPC">JVMTI_JLOCATION_MACHINEPC</code></td><td align="right">2</td><td>
	    <code>jlocation</code>の値は、ネイティブ・マシンのプログラム・カウンタ値を表す。
	  </td>
</tr>
<tr>
<td><code id="JVMTI_JLOCATION_OTHER">JVMTI_JLOCATION_OTHER</code></td><td align="right">0</td><td>
	    <code>jlocation</code>の値は、その他の表現を持つ。
	  </td>
</tr>
</table>
</blockquote>
      
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#heapCallbacks">コールバック安全</a></td><td><a href="#FunctionTable">位置</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  どの段階でも呼び出せる
</td><td>
      いいえ
    </td><td>129</td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="GetJLocationFormat.format_ptr">format_ptr</code></td><td><code><a href="#jvmtiJlocationFormat">jvmtiJlocationFormat</a>*</code></td><td>
	    戻ったとき、<code>jlocation</code>値の形式識別子をポイントする。
	  <p></p>エージェントは<code>jvmtiJlocationFormat</code>へのポインタを渡す。戻ったとき、<code>jvmtiJlocationFormat</code>が設定されている。 </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        エラー
      </td>
</tr>
<tr>
<td colspan="2">
            この関数は、<a href="#universal-error">汎用エラー</a>、または次のエラーのいずれかを返します
          </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            エラー
          </td><td>
            説明
          </td>
</tr>
<tr>
<td><a href="#JVMTI_ERROR_NULL_POINTER"><code>JVMTI_ERROR_NULL_POINTER</code></a></td><td>
	  <a href="#GetJLocationFormat.format_ptr"><code>format_ptr</code></a>が<code>NULL</code>。
	  
	</td>
</tr>
</table>
<p id="ErrorSection"></p>
<p></p>
<hr noshade size="3">
<h2>
    エラー
  </h2>
<p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TI関数はすべて、<b><code>jvmtiError</code></b>エラー・コードを返します。
    <p></p>
    エージェントは、有効なパラメータを持つJVM<small style="font-size: xx-small">&nbsp;</small>TI関数を、適切なコンテキスト(たとえば、呼出し側スレッドが接続されていて、段階が適切)で呼び出します。実装によって、一部のエラー条件の検出が困難であったり、非効率的であったり、不可能であったりします。実装は、「<a href="#reqerrors">関数固有の必須エラー</a>」に一覧されているエラーを検出する必要があります。その他のエラーは、エラー条件に対する推奨されている応答を表します。 
  <p></p>
<h3 id="universal-error">汎用エラー</h3>
      次のエラーは、どの関数からも返される可能性があるエラーです。
    <p></p>
<dl>
<dt>
<code id="JVMTI_ERROR_NONE">JVMTI_ERROR_NONE (0) </code>
</dt>
<dd>
      エラーは発生しなかった。関数の実行が正常に終了したときに返されるエラー・コード。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NULL_POINTER">JVMTI_ERROR_NULL_POINTER (100) </code>
</dt>
<dd>
      ポインタが<code>NULL</code>。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_OUT_OF_MEMORY">JVMTI_ERROR_OUT_OF_MEMORY (110) </code>
</dt>
<dd>
      関数でメモリーの割当てが試行されたが、これ以上割り当てられるメモリーがなかった。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_ACCESS_DENIED">JVMTI_ERROR_ACCESS_DENIED (111) </code>
</dt>
<dd>
      この仮想マシンでは必要な機能が有効になっていない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNATTACHED_THREAD">JVMTI_ERROR_UNATTACHED_THREAD (115) </code>
</dt>
<dd>
      この関数の呼出しに使われているスレッドが、仮想マシンに接続されていない。呼出しは、接続されたスレッドから行う必要がある。JNI呼び出しAPIの<code>AttachCurrentThread</code>を参照。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_ENVIRONMENT">JVMTI_ERROR_INVALID_ENVIRONMENT (116) </code>
</dt>
<dd>
      指定されたJVM<small style="font-size: xx-small">&nbsp;</small>TI環境はもう接続されていない、または環境ではない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_WRONG_PHASE">JVMTI_ERROR_WRONG_PHASE (112) </code>
</dt>
<dd>
      現在の<a href="#GetPhase">段階</a>では、必要な機能を使用できない。仮想マシンが実行を完了している場合、常に返される。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INTERNAL">JVMTI_ERROR_INTERNAL (113) </code>
</dt>
<dd>
      予期しない内部エラーが発生した。
    <p></p>
</dd>
</dl>
<p></p>
<h3 id="reqerrors">関数固有の必須エラー</h3>
      一部のJVM<small style="font-size: xx-small">&nbsp;</small>TI関数は、次のエラーを返します。これらのエラーは、条件が満たされたとき、実装によって返される必要があります。
    <p></p>
<dl>
<dt>
<code id="JVMTI_ERROR_INVALID_PRIORITY">JVMTI_ERROR_INVALID_PRIORITY (12) </code>
</dt>
<dd>
      無効な優先順位。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_THREAD_NOT_SUSPENDED">JVMTI_ERROR_THREAD_NOT_SUSPENDED (13) </code>
</dt>
<dd>
      スレッドは中断されていない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_THREAD_SUSPENDED">JVMTI_ERROR_THREAD_SUSPENDED (14) </code>
</dt>
<dd>
      スレッドはすでに中断されている。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_THREAD_NOT_ALIVE">JVMTI_ERROR_THREAD_NOT_ALIVE (15) </code>
</dt>
<dd>
      この操作を行うには、スレッドが活動中(開始され、まだ終了していない)でなければならない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_CLASS_NOT_PREPARED">JVMTI_ERROR_CLASS_NOT_PREPARED (22) </code>
</dt>
<dd>
      クラスがロードされているが、まだ準備されていない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NO_MORE_FRAMES">JVMTI_ERROR_NO_MORE_FRAMES (31) </code>
</dt>
<dd>
      指定された深さに、Javaプログラミング言語またはJNIスタック・フレームが存在しない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_OPAQUE_FRAME">JVMTI_ERROR_OPAQUE_FRAME (32) </code>
</dt>
<dd>
      フレームの情報が入手できない(ネイティブ・フレームの場合など)。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_DUPLICATE">JVMTI_ERROR_DUPLICATE (40) </code>
</dt>
<dd>
      すでに設定された項目。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NOT_FOUND">JVMTI_ERROR_NOT_FOUND (41) </code>
</dt>
<dd>
      目的の要素(フィールドやブレークポイントなど)が見つからない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NOT_MONITOR_OWNER">JVMTI_ERROR_NOT_MONITOR_OWNER (51) </code>
</dt>
<dd>
      このスレッドはrawモニターを所有していない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INTERRUPT">JVMTI_ERROR_INTERRUPT (52) </code>
</dt>
<dd>
      呼出しの完了前に割り込まれた。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNMODIFIABLE_CLASS">JVMTI_ERROR_UNMODIFIABLE_CLASS (79) </code>
</dt>
<dd>
      クラスは変更できない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NOT_AVAILABLE">JVMTI_ERROR_NOT_AVAILABLE (98) </code>
</dt>
<dd>
      この機能はこの仮想マシンでは使用できない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_ABSENT_INFORMATION">JVMTI_ERROR_ABSENT_INFORMATION (101) </code>
</dt>
<dd>
      要求された情報が入手できない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_EVENT_TYPE">JVMTI_ERROR_INVALID_EVENT_TYPE (102) </code>
</dt>
<dd>
      指定されたイベント・タイプのIDが認識されない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NATIVE_METHOD">JVMTI_ERROR_NATIVE_METHOD (104) </code>
</dt>
<dd>
      要求された情報がネイティブ・メソッドで使用できない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED">JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED (106) </code>
</dt>
<dd>
      クラス・ローダーがこの操作をサポートしない。
    <p></p>
</dd>
</dl>
<p></p>
<h3 id="function-specific-errors">関数固有のエージェント・エラー</h3>
      次のエラーは、一部のJVM<small style="font-size: xx-small">&nbsp;</small>TI関数から返される可能性があるエラーです。これらのエラーは、エージェントによって無効なパラメータが渡された場合や、無効なコンテキストで使用された場合に返されます。これらのエラーは、実装なしで検出できます。
    <p></p>
<dl>
<dt>
<code id="JVMTI_ERROR_INVALID_THREAD">JVMTI_ERROR_INVALID_THREAD (10) </code>
</dt>
<dd>
      渡されたスレッドは有効なスレッドではない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_FIELDID">JVMTI_ERROR_INVALID_FIELDID (25) </code>
</dt>
<dd>
      無効なフィールド。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_METHODID">JVMTI_ERROR_INVALID_METHODID (23) </code>
</dt>
<dd>
      無効なメソッド。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_LOCATION">JVMTI_ERROR_INVALID_LOCATION (24) </code>
</dt>
<dd>
      無効な位置。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_OBJECT">JVMTI_ERROR_INVALID_OBJECT (20) </code>
</dt>
<dd>
      無効なオブジェクト。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_CLASS">JVMTI_ERROR_INVALID_CLASS (21) </code>
</dt>
<dd>
      無効なクラス。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_TYPE_MISMATCH">JVMTI_ERROR_TYPE_MISMATCH (34) </code>
</dt>
<dd>
      使用した関数と変数の型が合わない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_SLOT">JVMTI_ERROR_INVALID_SLOT (35) </code>
</dt>
<dd>
      無効なスロット。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_MUST_POSSESS_CAPABILITY">JVMTI_ERROR_MUST_POSSESS_CAPABILITY (99) </code>
</dt>
<dd>
      この環境で使用される権限がfalse。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_THREAD_GROUP">JVMTI_ERROR_INVALID_THREAD_GROUP (11) </code>
</dt>
<dd>
      スレッド・グループが無効。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_MONITOR">JVMTI_ERROR_INVALID_MONITOR (50) </code>
</dt>
<dd>
      無効なrawモニター。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_ILLEGAL_ARGUMENT">JVMTI_ERROR_ILLEGAL_ARGUMENT (103) </code>
</dt>
<dd>
      不正な引数。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_TYPESTATE">JVMTI_ERROR_INVALID_TYPESTATE (65) </code>
</dt>
<dd>
      スレッドの状態が変更されたため、不整合が生じている。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_VERSION">JVMTI_ERROR_UNSUPPORTED_VERSION (68) </code>
</dt>
<dd>
      新しいクラス・ファイルのバージョンがこのVMでサポートされていない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_INVALID_CLASS_FORMAT">JVMTI_ERROR_INVALID_CLASS_FORMAT (60) </code>
</dt>
<dd>
      新しいクラス・ファイルの形式が正しくない(VMは<code>ClassFormatError</code>を返す)。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION">JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION (61) </code>
</dt>
<dd>
      新しいクラス・ファイルの定義が循環定義になる(VMは<code>ClassCircularityError</code>を返す)。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED (63) </code>
</dt>
<dd>
      新しいクラス・ファイルでメソッドの追加が必要。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED (64) </code>
</dt>
<dd>
      新しいクラスのバージョンによってフィールドが変更される。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_FAILS_VERIFICATION">JVMTI_ERROR_FAILS_VERIFICATION (62) </code>
</dt>
<dd>
      クラス・バイトが検証に失敗する。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED (66) </code>
</dt>
<dd>
      新しいクラスのバージョンの直接スーパー・クラスが異なる、または直接実装されているインタフェースが異なる。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED (67) </code>
</dt>
<dd>
      新しいクラスのバージョンでは旧クラスのバージョンで宣言したメソッドを宣言しない。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_NAMES_DONT_MATCH">JVMTI_ERROR_NAMES_DONT_MATCH (69) </code>
</dt>
<dd>
      新しいクラス・ファイル内で定義されたクラス名が、旧クラス・オブジェクト内の名前と異なる。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED (70) </code>
</dt>
<dd>
      新しいクラスのバージョンの修飾子が異なる。
    <p></p>
</dd>
<dt>
<code id="JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED">JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED (71) </code>
</dt>
<dd>
      新しいクラスのバージョンのメソッドの修飾子が旧クラスのバージョンの修飾子と異なる。
    <p></p>
</dd>
</dl>
<p></p>
<p></p>
<p id="DataSection"></p>
<p></p>
<hr noshade size="3">
<h2>
    データ型
  </h2>
<p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TIは、JNIによって定義されたデータ型を拡張します。
  <p id="jniTypes"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">JVM Tool Interfaceで使用するJNIの型</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code>jboolean</code></td><td><a name="jboolean"></a> Javaプログラミング言語<code>boolean</code>を保持します。符号なし8ビット。
      </td>
</tr>
<tr>
<td><code>jchar</code></td><td><a name="jchar"></a> Javaプログラミング言語<code>char</code>を保持します。符号なし16ビット。
      </td>
</tr>
<tr>
<td><code>jint</code></td><td><a name="jint"></a> Javaプログラミング言語<code>int</code>を保持します。符号付き32ビット。
      </td>
</tr>
<tr>
<td><code>jlong</code></td><td><a name="jlong"></a> Javaプログラミング言語<code>long</code>を保持します。符号付き64ビット。
      </td>
</tr>
<tr>
<td><code>jfloat</code></td><td><a name="jfloat"></a> Javaプログラミング言語<code>float</code>を保持します。32ビット。
      </td>
</tr>
<tr>
<td><code>jdouble</code></td><td><a name="jdouble"></a> Javaプログラミング言語<code>double</code>を保持します。64ビット。
      </td>
</tr>
<tr>
<td><code>jobject</code></td><td><a name="jobject"></a>Javaプログラミング言語オブジェクトを保持する。 
      </td>
</tr>
<tr>
<td><code>jclass</code></td><td><a name="jclass"></a>Javaプログラミング言語クラスを保持する。 
      </td>
</tr>
<tr>
<td><code>jvalue</code></td><td><a name="jvalue"></a>すべてのプリミティブ型および<code>jobject</code>の和集合である。つまり、Javaプログラミング言語の任意の値を保持する。 
      </td>
</tr>
<tr>
<td><code>jfieldID</code></td><td><a name="jfieldID"></a>Javaプログラミング言語のフィールドを識別する。JVM<small style="font-size: xx-small">&nbsp;</small>TIの関数やイベントから返された<code>jfieldID</code>は、安全に格納できる。
      </td>
</tr>
<tr>
<td><code>jmethodID</code></td><td><a name="jmethodID"></a>Javaプログラミング言語メソッド、イニシャライザ、またはコンストラクタを識別する。JVM<small style="font-size: xx-small">&nbsp;</small>TIの関数やイベントから返された<code>jmethodID</code>は、安全に格納できる。ただし、クラスがアンロードされた場合、それらは無効になるので使用してはいけない。
      </td>
</tr>
<tr>
<td><code>JNIEnv</code></td><td><a name="JNIEnv"></a>JNI関数テーブルのポインタ。<code>JNIEnv *</code>のポインタはJNI環境。 
      </td>
</tr>
</table>
<p id="jvmtiTypes"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">JVM Tool Interface基底型</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code>jvmtiEnv</code></td><td><a name="jvmtiEnv"></a>JVM<small style="font-size: xx-small">&nbsp;</small>TI<a href="#environments">環境</a>のポインタ。<a href="#FunctionSection">「関数」セクション</a>を参照。<code>jvmtiEnv</code>は<a href="#FunctionTable">関数テーブル</a>のポインタをポイントする。
      </td>
</tr>
<tr>
<td rowspan="2"><code>jthread</code></td><td><a name="jthread"></a>スレッドを保持する<a href="#jobject"><code>jobject</code></a>のサブタイプ。
      </td>
</tr>
<tr>
<td>
<pre>typedef jobject jthread;</pre>
</td>
</tr>
<tr>
<td rowspan="2"><code>jthreadGroup</code></td><td><a name="jthreadGroup"></a>スレッド・グループを保持する<a href="#jobject"><code>jobject</code></a>のサブタイプ。
      </td>
</tr>
<tr>
<td>
<pre>typedef jobject jthreadGroup;</pre>
</td>
</tr>
<tr>
<td rowspan="2"><code>jlocation</code></td><td><a name="jlocation"></a>メソッド内の単調に増加する実行可能位置を表す64ビット値。<code>-1</code>はネイティブ・メソッドを示す。ある特定のVMでの形式については、<a href="#GetJLocationFormat"><code>GetJLocationFormat</code></a>を参照。
      </td>
</tr>
<tr>
<td>
<pre>typedef jlong jlocation;</pre>
</td>
</tr>
<tr>
<td rowspan="2"><code>jrawMonitorID</code></td><td><a name="jrawMonitorID"></a>rawモニター。
      </td>
</tr>
<tr>
<td>
<pre>struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;</pre>
</td>
</tr>
<tr>
<td><code>jvmtiError</code></td><td><a name="jvmtiError"></a>戻りエラー・コードを保持する。可能な値については、「<a href="#ErrorSection">エラー</a>」を参照。
	<blockquote>
<pre>
typedef enum { 
    JVMTI_ERROR_NONE = 0,  
    JVMTI_ERROR_INVALID_THREAD = 10,
      ... 
} jvmtiError;
</pre>
</blockquote>
      
</td>
</tr>
<tr>
<td><code>jvmtiEvent</code></td><td><a name="jvmtiEvent"></a>イベント・タイプの識別子。可能な値については、「<a href="#EventSection">イベント</a>」を参照。この仕様の将来のバージョンでは、イベント・タイプ識別子としてゼロが割り当てられないことが保証される。
<blockquote>
<pre>
typedef enum { 
    JVMTI_EVENT_SINGLE_STEP = 1, 
    JVMTI_EVENT_BREAKPOINT = 2, 
      ... 
} jvmtiEvent;
</pre>
</blockquote>
      
</td>
</tr>
<tr>
<td><code>jvmtiEventCallbacks</code></td><td><a name="jvmtiEventCallbacks"></a>イベント用コールバック。
<blockquote>
<pre>
typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
      ... 
} jvmtiEventCallbacks;
</pre>
</blockquote>
        完全な構造については「<a href="#jvmtiEventCallbacks">イベント・コールバック</a>」を参照。
        <p></p>
        たとえば、VM初期化コールバックは次のように定義される。
<blockquote>
<pre>
typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env, 
     JNIEnv* jni_env,
     jthread thread);
</pre>
</blockquote>
        コールバック関数の定義については個々のイベントを参照。
      </td>
</tr>
<tr>
<td rowspan="2"><code>jniNativeInterface</code></td><td><a name="jniNativeInterface"></a><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp23720">JNI仕様</a>で定義されたJNI関数テーブル<code>JNINativeInterface</code>の型識別子。JNI参照実装では、下線付きで定義される。
      </td>
</tr>
<tr>
<td>
<pre>typedef struct JNINativeInterface_ jniNativeInterface;</pre>
</td>
</tr>
</table>
<p></p>
<a name="StructureTypeDefinitions"></a>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        構造型の定義
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><a href="#jvmtiAddrLocationMap"><code>jvmtiAddrLocationMap</code></a></td><td>位置エントリのネイティブ・アドレス</td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities"><code>jvmtiCapabilities</code></a></td><td>権限の構造体</td>
</tr>
<tr>
<td><a href="#jvmtiClassDefinition"><code>jvmtiClassDefinition</code></a></td><td>クラスの再定義の説明</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionEventInfo"><code>jvmtiExtensionEventInfo</code></a></td><td>拡張イベント情報</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionFunctionInfo"><code>jvmtiExtensionFunctionInfo</code></a></td><td>拡張関数情報</td>
</tr>
<tr>
<td><a href="#jvmtiFrameInfo"><code>jvmtiFrameInfo</code></a></td><td>スタック・フレーム情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapCallbacks"><code>jvmtiHeapCallbacks</code></a></td><td>ヒープ・コールバック関数構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfo"><code>jvmtiHeapReferenceInfo</code></a></td><td>参照情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoArray"><code>jvmtiHeapReferenceInfoArray</code></a></td><td>配列参照用の参照情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoConstantPool"><code>jvmtiHeapReferenceInfoConstantPool</code></a></td><td>定数プール参照用の参照情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoField"><code>jvmtiHeapReferenceInfoField</code></a></td><td>フィールド参照用の参照情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoJniLocal"><code>jvmtiHeapReferenceInfoJniLocal</code></a></td><td>JNIローカル参照用の参照情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoReserved"><code>jvmtiHeapReferenceInfoReserved</code></a></td><td>その他の参照用の参照情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceInfoStackLocal"><code>jvmtiHeapReferenceInfoStackLocal</code></a></td><td>局所変数参照用の参照情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiLineNumberEntry"><code>jvmtiLineNumberEntry</code></a></td><td>行番号テーブルのエントリ</td>
</tr>
<tr>
<td><a href="#jvmtiLocalVariableEntry"><code>jvmtiLocalVariableEntry</code></a></td><td>局所変数テーブルのエントリ</td>
</tr>
<tr>
<td><a href="#jvmtiMonitorStackDepthInfo"><code>jvmtiMonitorStackDepthInfo</code></a></td><td>モニター・スタック深さ情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiMonitorUsage"><code>jvmtiMonitorUsage</code></a></td><td>オブジェクト・モニターの使用情報</td>
</tr>
<tr>
<td><a href="#jvmtiParamInfo"><code>jvmtiParamInfo</code></a></td><td>拡張関数/イベント・パラメータ情報</td>
</tr>
<tr>
<td><a href="#jvmtiStackInfo"><code>jvmtiStackInfo</code></a></td><td>スタック情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiThreadGroupInfo"><code>jvmtiThreadGroupInfo</code></a></td><td>スレッド・グループ情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiThreadInfo"><code>jvmtiThreadInfo</code></a></td><td>スレッド情報構造体</td>
</tr>
<tr>
<td><a href="#jvmtiTimerInfo"><code>jvmtiTimerInfo</code></a></td><td>タイマー情報</td>
</tr>
</table>
<p></p>
<a name="FunctionTypeDefinitions"></a>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        関数型の定義
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><a href="#jvmtiArrayPrimitiveValueCallback"><code>jvmtiArrayPrimitiveValueCallback</code></a></td><td>配列プリミティブ値コールバック</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionEvent"><code>jvmtiExtensionEvent</code></a></td><td>拡張イベント</td>
</tr>
<tr>
<td><a href="#jvmtiExtensionFunction"><code>jvmtiExtensionFunction</code></a></td><td>拡張関数</td>
</tr>
<tr>
<td><a href="#jvmtiHeapIterationCallback"><code>jvmtiHeapIterationCallback</code></a></td><td>ヒープ反復コールバック</td>
</tr>
<tr>
<td><a href="#jvmtiHeapObjectCallback"><code>jvmtiHeapObjectCallback</code></a></td><td>ヒープ・オブジェクトのコールバック</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceCallback"><code>jvmtiHeapReferenceCallback</code></a></td><td>ヒープ参照コールバック</td>
</tr>
<tr>
<td><a href="#jvmtiHeapRootCallback"><code>jvmtiHeapRootCallback</code></a></td><td>ヒープ・ルート・オブジェクトのコールバック</td>
</tr>
<tr>
<td><a href="#jvmtiObjectReferenceCallback"><code>jvmtiObjectReferenceCallback</code></a></td><td>オブジェクト参照のコールバック</td>
</tr>
<tr>
<td><a href="#jvmtiPrimitiveFieldCallback"><code>jvmtiPrimitiveFieldCallback</code></a></td><td>プリミティブ・フィールド・コールバック</td>
</tr>
<tr>
<td><a href="#jvmtiReservedCallback"><code>jvmtiReservedCallback</code></a></td><td>将来使用するために予約されたコールバック</td>
</tr>
<tr>
<td><a href="#jvmtiStackReferenceCallback"><code>jvmtiStackReferenceCallback</code></a></td><td>スタック参照オブジェクトのコールバック</td>
</tr>
<tr>
<td><a href="#jvmtiStartFunction"><code>jvmtiStartFunction</code></a></td><td>エージェント起動関数</td>
</tr>
<tr>
<td><a href="#jvmtiStringPrimitiveValueCallback"><code>jvmtiStringPrimitiveValueCallback</code></a></td><td>文字列プリミティブ値コールバック</td>
</tr>
</table>
<p></p>
<a name="EnumerationDefinitions"></a>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        列挙型の定義
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><a href="#jvmtiEventMode"><code>jvmtiEventMode</code></a></td><td>イベントの有効化と無効化</td>
</tr>
<tr>
<td><a href="#jvmtiHeapObjectFilter"><code>jvmtiHeapObjectFilter</code></a></td><td>ヒープ・オブジェクトのフィルタの列挙</td>
</tr>
<tr>
<td><a href="#jvmtiHeapReferenceKind"><code>jvmtiHeapReferenceKind</code></a></td><td>ヒープ参照の列挙</td>
</tr>
<tr>
<td><a href="#jvmtiHeapRootKind"><code>jvmtiHeapRootKind</code></a></td><td>ヒープ・ルートの種類の列挙</td>
</tr>
<tr>
<td><a href="#jvmtiIterationControl"><code>jvmtiIterationControl</code></a></td><td>反復制御の列挙</td>
</tr>
<tr>
<td><a href="#jvmtiJlocationFormat"><code>jvmtiJlocationFormat</code></a></td><td>JLocationの形式の列挙</td>
</tr>
<tr>
<td><a href="#jvmtiObjectReferenceKind"><code>jvmtiObjectReferenceKind</code></a></td><td>オブジェクト参照の列挙</td>
</tr>
<tr>
<td><a href="#jvmtiParamKind"><code>jvmtiParamKind</code></a></td><td>拡張関数/イベント・パラメータの種類</td>
</tr>
<tr>
<td><a href="#jvmtiParamTypes"><code>jvmtiParamTypes</code></a></td><td>拡張関数/イベント・パラメータの型</td>
</tr>
<tr>
<td><a href="#jvmtiPhase"><code>jvmtiPhase</code></a></td><td>実行の段階</td>
</tr>
<tr>
<td><a href="#jvmtiPrimitiveType"><code>jvmtiPrimitiveType</code></a></td><td>プリミティブ型の列挙</td>
</tr>
<tr>
<td><a href="#jvmtiTimerKind"><code>jvmtiTimerKind</code></a></td><td>タイマーの種類</td>
</tr>
<tr>
<td><a href="#jvmtiVerboseFlag"><code>jvmtiVerboseFlag</code></a></td><td>冗長フラグの列挙</td>
</tr>
</table>
<p></p>
<a name="FunctionTable"></a>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        関数テーブルのレイアウト
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        位置
      </td><td>
        機能
      </td><td>
        宣言
      </td>
</tr>
<tr>
<td align="right">  1</td><td><i>予約済み</i></td><td>
<pre>void *reserved1;</pre>
</td>
</tr>
<tr>
<td align="right">  2</td><td><a href="#SetEventNotificationMode">イベント通知モードの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env, 
                       jvmtiEventMode mode, 
                       jvmtiEvent event_type, 
                       jthread event_thread, 
                        ...);</pre>
</td>
</tr>
<tr>
<td align="right">  3</td><td><i>予約済み</i></td><td>
<pre>void *reserved3;</pre>
</td>
</tr>
<tr>
<td align="right">  4</td><td><a href="#GetAllThreads">すべてのスレッドの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env, 
                       jint* threads_count_ptr, 
                       jthread** threads_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  5</td><td><a href="#SuspendThread">スレッドの中断</a></td><td>
<pre>jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  6</td><td><a href="#ResumeThread">スレッドの再開</a></td><td>
<pre>jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  7</td><td><a href="#StopThread">スレッドの停止</a></td><td>
<pre>jvmtiError (JNICALL *StopThread) (jvmtiEnv* env, 
                       jthread thread, 
                       jobject exception);</pre>
</td>
</tr>
<tr>
<td align="right">  8</td><td><a href="#InterruptThread">スレッドの割り込み</a></td><td>
<pre>jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  9</td><td><a href="#GetThreadInfo">スレッド情報の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env, 
                       jthread thread, 
                       jvmtiThreadInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  10</td><td><a href="#GetOwnedMonitorInfo">所有モニター情報の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* owned_monitor_count_ptr, 
                       jobject** owned_monitors_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  11</td><td><a href="#GetCurrentContendedMonitor">現在競合しているモニターの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env, 
                       jthread thread, 
                       jobject* monitor_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  12</td><td><a href="#RunAgentThread">エージェント・スレッドの実行</a></td><td>
<pre>jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env, 
                       jthread thread, 
                       jvmtiStartFunction proc, 
                       const void* arg, 
                       jint priority);</pre>
</td>
</tr>
<tr>
<td align="right">  13</td><td><a href="#GetTopThreadGroups">トップ・レベルのスレッド・グループの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env, 
                       jint* group_count_ptr, 
                       jthreadGroup** groups_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  14</td><td><a href="#GetThreadGroupInfo">スレッド・グループ情報の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env, 
                       jthreadGroup group, 
                       jvmtiThreadGroupInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  15</td><td><a href="#GetThreadGroupChildren">子スレッド・グループの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env, 
                       jthreadGroup group, 
                       jint* thread_count_ptr, 
                       jthread** threads_ptr, 
                       jint* group_count_ptr, 
                       jthreadGroup** groups_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  16</td><td><a href="#GetFrameCount">フレーム・カウントの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  17</td><td><a href="#GetThreadState">スレッド状態の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* thread_state_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  18</td><td><a href="#GetCurrentThread">現在のスレッドの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env, 
                       jthread* thread_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  19</td><td><a href="#GetFrameLocation">フレームの位置の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jmethodID* method_ptr, 
                       jlocation* location_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  20</td><td><a href="#NotifyFramePop">フレームのポップの通知</a></td><td>
<pre>jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth);</pre>
</td>
</tr>
<tr>
<td align="right">  21</td><td><a href="#GetLocalObject">局所変数の取得 - オブジェクト型</a></td><td>
<pre>jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jobject* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  22</td><td><a href="#GetLocalInt">局所変数の取得 - 整数型</a></td><td>
<pre>jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jint* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  23</td><td><a href="#GetLocalLong">局所変数の取得 - 長整数型</a></td><td>
<pre>jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jlong* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  24</td><td><a href="#GetLocalFloat">局所変数の取得 - 浮動小数点数型</a></td><td>
<pre>jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jfloat* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  25</td><td><a href="#GetLocalDouble">局所変数の取得 - 倍精度浮動小数点数型</a></td><td>
<pre>jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jdouble* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  26</td><td><a href="#SetLocalObject">局所変数の設定 - オブジェクト型</a></td><td>
<pre>jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jobject value);</pre>
</td>
</tr>
<tr>
<td align="right">  27</td><td><a href="#SetLocalInt">局所変数の設定 - 整数型</a></td><td>
<pre>jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jint value);</pre>
</td>
</tr>
<tr>
<td align="right">  28</td><td><a href="#SetLocalLong">局所変数の設定 - 長整数型</a></td><td>
<pre>jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jlong value);</pre>
</td>
</tr>
<tr>
<td align="right">  29</td><td><a href="#SetLocalFloat">局所変数の設定 - 浮動小数点数型</a></td><td>
<pre>jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jfloat value);</pre>
</td>
</tr>
<tr>
<td align="right">  30</td><td><a href="#SetLocalDouble">局所変数の設定 - 倍精度浮動小数点数型</a></td><td>
<pre>jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jint slot, 
                       jdouble value);</pre>
</td>
</tr>
<tr>
<td align="right">  31</td><td><a href="#CreateRawMonitor">rawモニターの作成</a></td><td>
<pre>jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env, 
                       const char* name, 
                       jrawMonitorID* monitor_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  32</td><td><a href="#DestroyRawMonitor">rawモニターの破棄</a></td><td>
<pre>jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  33</td><td><a href="#RawMonitorEnter">rawモニターの開始</a></td><td>
<pre>jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  34</td><td><a href="#RawMonitorExit">rawモニターの終了</a></td><td>
<pre>jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  35</td><td><a href="#RawMonitorWait">rawモニターの待機</a></td><td>
<pre>jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env, 
                       jrawMonitorID monitor, 
                       jlong millis);</pre>
</td>
</tr>
<tr>
<td align="right">  36</td><td><a href="#RawMonitorNotify">rawモニターの通知</a></td><td>
<pre>jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  37</td><td><a href="#RawMonitorNotifyAll">rawモニターの通知(すべて)</a></td><td>
<pre>jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env, 
                       jrawMonitorID monitor);</pre>
</td>
</tr>
<tr>
<td align="right">  38</td><td><a href="#SetBreakpoint">ブレークポイントの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env, 
                       jmethodID method, 
                       jlocation location);</pre>
</td>
</tr>
<tr>
<td align="right">  39</td><td><a href="#ClearBreakpoint">ブレークポイントの解除</a></td><td>
<pre>jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env, 
                       jmethodID method, 
                       jlocation location);</pre>
</td>
</tr>
<tr>
<td align="right">  40</td><td><i>予約済み</i></td><td>
<pre>void *reserved40;</pre>
</td>
</tr>
<tr>
<td align="right">  41</td><td><a href="#SetFieldAccessWatch">フィールド・アクセスの監視の設定</a></td><td>
<pre>jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  42</td><td><a href="#ClearFieldAccessWatch">フィールド・アクセスの監視の解除</a></td><td>
<pre>jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  43</td><td><a href="#SetFieldModificationWatch">フィールド変更の監視の設定</a></td><td>
<pre>jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  44</td><td><a href="#ClearFieldModificationWatch">フィールド変更の監視の解除</a></td><td>
<pre>jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field);</pre>
</td>
</tr>
<tr>
<td align="right">  45</td><td><a href="#IsModifiableClass">変更可能クラスかどうかの検査</a></td><td>
<pre>jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jboolean* is_modifiable_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  46</td><td><a href="#Allocate">Allocate</a></td><td>
<pre>jvmtiError (JNICALL *Allocate) (jvmtiEnv* env, 
                       jlong size, 
                       unsigned char** mem_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  47</td><td><a href="#Deallocate">Deallocate</a></td><td>
<pre>jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env, 
                       unsigned char* mem);</pre>
</td>
</tr>
<tr>
<td align="right">  48</td><td><a href="#GetClassSignature">クラスのシグニチャの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env, 
                       jclass klass, 
                       char** signature_ptr, 
                       char** generic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  49</td><td><a href="#GetClassStatus">クラスのステータスの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* status_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  50</td><td><a href="#GetSourceFileName">ソース・ファイル名の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env, 
                       jclass klass, 
                       char** source_name_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  51</td><td><a href="#GetClassModifiers">クラスの修飾子の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* modifiers_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  52</td><td><a href="#GetClassMethods">クラスのメソッドの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* method_count_ptr, 
                       jmethodID** methods_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  53</td><td><a href="#GetClassFields">クラスのフィールドの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* field_count_ptr, 
                       jfieldID** fields_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  54</td><td><a href="#GetImplementedInterfaces">実装されたインタフェースの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* interface_count_ptr, 
                       jclass** interfaces_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  55</td><td><a href="#IsInterface">インタフェースかどうかの検査</a></td><td>
<pre>jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env, 
                       jclass klass, 
                       jboolean* is_interface_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  56</td><td><a href="#IsArrayClass">配列クラスかどうかの検査</a></td><td>
<pre>jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jboolean* is_array_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  57</td><td><a href="#GetClassLoader">クラス・ローダーの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env, 
                       jclass klass, 
                       jobject* classloader_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  58</td><td><a href="#GetObjectHashCode">オブジェクトのハッシュ・コードの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env, 
                       jobject object, 
                       jint* hash_code_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  59</td><td><a href="#GetObjectMonitorUsage">オブジェクトのモニターの利用情報を取得</a></td><td>
<pre>jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env, 
                       jobject object, 
                       jvmtiMonitorUsage* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  60</td><td><a href="#GetFieldName">フィールドの名前とシグニチャの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       char** name_ptr, 
                       char** signature_ptr, 
                       char** generic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  61</td><td><a href="#GetFieldDeclaringClass">フィールドの宣言クラスの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       jclass* declaring_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  62</td><td><a href="#GetFieldModifiers">フィールドの修飾子の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       jint* modifiers_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  63</td><td><a href="#IsFieldSynthetic">合成フィールドかどうかの検査</a></td><td>
<pre>jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env, 
                       jclass klass, 
                       jfieldID field, 
                       jboolean* is_synthetic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  64</td><td><a href="#GetMethodName">メソッドの名前とシグニチャの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env, 
                       jmethodID method, 
                       char** name_ptr, 
                       char** signature_ptr, 
                       char** generic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  65</td><td><a href="#GetMethodDeclaringClass">メソッドの宣言クラスの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env, 
                       jmethodID method, 
                       jclass* declaring_class_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  66</td><td><a href="#GetMethodModifiers">メソッドの修飾子の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* modifiers_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  67</td><td><i>予約済み</i></td><td>
<pre>void *reserved67;</pre>
</td>
</tr>
<tr>
<td align="right">  68</td><td><a href="#GetMaxLocals">局所変数の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* max_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  69</td><td><a href="#GetArgumentsSize">引数のサイズの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* size_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  70</td><td><a href="#GetLineNumberTable">行番号テーブルの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* entry_count_ptr, 
                       jvmtiLineNumberEntry** table_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  71</td><td><a href="#GetMethodLocation">メソッドの配置位置の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env, 
                       jmethodID method, 
                       jlocation* start_location_ptr, 
                       jlocation* end_location_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  72</td><td><a href="#GetLocalVariableTable">局所変数テーブルの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* entry_count_ptr, 
                       jvmtiLocalVariableEntry** table_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  73</td><td><a href="#SetNativeMethodPrefix">ネイティブ・メソッド接頭辞の設定</a></td><td>
<pre>jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env, 
                       const char* prefix);</pre>
</td>
</tr>
<tr>
<td align="right">  74</td><td><a href="#SetNativeMethodPrefixes">複数のネイティブ・メソッド接頭辞の設定</a></td><td>
<pre>jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env, 
                       jint prefix_count, 
                       char** prefixes);</pre>
</td>
</tr>
<tr>
<td align="right">  75</td><td><a href="#GetBytecodes">バイト・コードの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env, 
                       jmethodID method, 
                       jint* bytecode_count_ptr, 
                       unsigned char** bytecodes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  76</td><td><a href="#IsMethodNative">ネイティブ・メソッドかどうかの検査</a></td><td>
<pre>jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env, 
                       jmethodID method, 
                       jboolean* is_native_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  77</td><td><a href="#IsMethodSynthetic">合成メソッドかどうかの検査</a></td><td>
<pre>jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env, 
                       jmethodID method, 
                       jboolean* is_synthetic_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  78</td><td><a href="#GetLoadedClasses">ロード済みクラスの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env, 
                       jint* class_count_ptr, 
                       jclass** classes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  79</td><td><a href="#GetClassLoaderClasses">クラス・ローダー・クラスの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env, 
                       jobject initiating_loader, 
                       jint* class_count_ptr, 
                       jclass** classes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  80</td><td><a href="#PopFrame">フレームのポップ</a></td><td>
<pre>jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  81</td><td><a href="#ForceEarlyReturnObject">早期復帰の強制 - オブジェクト型</a></td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env, 
                       jthread thread, 
                       jobject value);</pre>
</td>
</tr>
<tr>
<td align="right">  82</td><td><a href="#ForceEarlyReturnInt">早期復帰の強制 - 整数型</a></td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env, 
                       jthread thread, 
                       jint value);</pre>
</td>
</tr>
<tr>
<td align="right">  83</td><td><a href="#ForceEarlyReturnLong">早期復帰の強制 - 長整数型</a></td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env, 
                       jthread thread, 
                       jlong value);</pre>
</td>
</tr>
<tr>
<td align="right">  84</td><td><a href="#ForceEarlyReturnFloat">早期復帰の強制 - 浮動小数点数型</a></td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env, 
                       jthread thread, 
                       jfloat value);</pre>
</td>
</tr>
<tr>
<td align="right">  85</td><td><a href="#ForceEarlyReturnDouble">早期復帰の強制 - 倍精度浮動小数点数型</a></td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env, 
                       jthread thread, 
                       jdouble value);</pre>
</td>
</tr>
<tr>
<td align="right">  86</td><td><a href="#ForceEarlyReturnVoid">早期復帰の強制 - void型</a></td><td>
<pre>jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env, 
                       jthread thread);</pre>
</td>
</tr>
<tr>
<td align="right">  87</td><td><a href="#RedefineClasses">クラスの再定義</a></td><td>
<pre>jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env, 
                       jint class_count, 
                       const jvmtiClassDefinition* class_definitions);</pre>
</td>
</tr>
<tr>
<td align="right">  88</td><td><a href="#GetVersionNumber">バージョン番号の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env, 
                       jint* version_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  89</td><td><a href="#GetCapabilities">権限の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env, 
                       jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  90</td><td><a href="#GetSourceDebugExtension">ソース・デバッグ拡張機能の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env, 
                       jclass klass, 
                       char** source_debug_extension_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  91</td><td><a href="#IsMethodObsolete">廃棄されたメソッドかどうかの検査</a></td><td>
<pre>jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env, 
                       jmethodID method, 
                       jboolean* is_obsolete_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  92</td><td><a href="#SuspendThreadList">スレッド・リストの中断</a></td><td>
<pre>jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env, 
                       jint request_count, 
                       const jthread* request_list, 
                       jvmtiError* results);</pre>
</td>
</tr>
<tr>
<td align="right">  93</td><td><a href="#ResumeThreadList">スレッド・リストの再開</a></td><td>
<pre>jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env, 
                       jint request_count, 
                       const jthread* request_list, 
                       jvmtiError* results);</pre>
</td>
</tr>
<tr>
<td align="right">  94</td><td><i>予約済み</i></td><td>
<pre>void *reserved94;</pre>
</td>
</tr>
<tr>
<td align="right">  95</td><td><i>予約済み</i></td><td>
<pre>void *reserved95;</pre>
</td>
</tr>
<tr>
<td align="right">  96</td><td><i>予約済み</i></td><td>
<pre>void *reserved96;</pre>
</td>
</tr>
<tr>
<td align="right">  97</td><td><i>予約済み</i></td><td>
<pre>void *reserved97;</pre>
</td>
</tr>
<tr>
<td align="right">  98</td><td><i>予約済み</i></td><td>
<pre>void *reserved98;</pre>
</td>
</tr>
<tr>
<td align="right">  99</td><td><i>予約済み</i></td><td>
<pre>void *reserved99;</pre>
</td>
</tr>
<tr>
<td align="right">  100</td><td><a href="#GetAllStackTraces">すべてのスタック・トレースの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env, 
                       jint max_frame_count, 
                       jvmtiStackInfo** stack_info_ptr, 
                       jint* thread_count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  101</td><td><a href="#GetThreadListStackTraces">スレッド・リストのスタック・トレースの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env, 
                       jint thread_count, 
                       const jthread* thread_list, 
                       jint max_frame_count, 
                       jvmtiStackInfo** stack_info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  102</td><td><a href="#GetThreadLocalStorage">スレッド・ローカルな記憶領域の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env, 
                       jthread thread, 
                       void** data_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  103</td><td><a href="#SetThreadLocalStorage">スレッド・ローカルな記憶領域の設定</a></td><td>
<pre>jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env, 
                       jthread thread, 
                       const void* data);</pre>
</td>
</tr>
<tr>
<td align="right">  104</td><td><a href="#GetStackTrace">スタック・トレースの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env, 
                       jthread thread, 
                       jint start_depth, 
                       jint max_frame_count, 
                       jvmtiFrameInfo* frame_buffer, 
                       jint* count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  105</td><td><i>予約済み</i></td><td>
<pre>void *reserved105;</pre>
</td>
</tr>
<tr>
<td align="right">  106</td><td><a href="#GetTag">タグの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetTag) (jvmtiEnv* env, 
                       jobject object, 
                       jlong* tag_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  107</td><td><a href="#SetTag">タグの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetTag) (jvmtiEnv* env, 
                       jobject object, 
                       jlong tag);</pre>
</td>
</tr>
<tr>
<td align="right">  108</td><td><a href="#ForceGarbageCollection">ガベージ・コレクションの強制</a></td><td>
<pre>jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);</pre>
</td>
</tr>
<tr>
<td align="right">  109</td><td><a href="#IterateOverObjectsReachableFromObject">オブジェクトから到達可能なオブジェクトの反復</a></td><td>
<pre>jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env, 
                       jobject object, 
                       jvmtiObjectReferenceCallback object_reference_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  110</td><td><a href="#IterateOverReachableObjects">到達可能なオブジェクトの反復</a></td><td>
<pre>jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env, 
                       jvmtiHeapRootCallback heap_root_callback, 
                       jvmtiStackReferenceCallback stack_ref_callback, 
                       jvmtiObjectReferenceCallback object_ref_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  111</td><td><a href="#IterateOverHeap">ヒープの反復</a></td><td>
<pre>jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env, 
                       jvmtiHeapObjectFilter object_filter, 
                       jvmtiHeapObjectCallback heap_object_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  112</td><td><a href="#IterateOverInstancesOfClass">クラスのインスタンスの反復</a></td><td>
<pre>jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env, 
                       jclass klass, 
                       jvmtiHeapObjectFilter object_filter, 
                       jvmtiHeapObjectCallback heap_object_callback, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  113</td><td><i>予約済み</i></td><td>
<pre>void *reserved113;</pre>
</td>
</tr>
<tr>
<td align="right">  114</td><td><a href="#GetObjectsWithTags">タグを使ったオブジェクトの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env, 
                       jint tag_count, 
                       const jlong* tags, 
                       jint* count_ptr, 
                       jobject** object_result_ptr, 
                       jlong** tag_result_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  115</td><td><a href="#FollowReferences">参照の追跡</a></td><td>
<pre>jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env, 
                       jint heap_filter, 
                       jclass klass, 
                       jobject initial_object, 
                       const jvmtiHeapCallbacks* callbacks, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  116</td><td><a href="#IterateThroughHeap">ヒープ内での反復</a></td><td>
<pre>jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env, 
                       jint heap_filter, 
                       jclass klass, 
                       const jvmtiHeapCallbacks* callbacks, 
                       const void* user_data);</pre>
</td>
</tr>
<tr>
<td align="right">  117</td><td><i>予約済み</i></td><td>
<pre>void *reserved117;</pre>
</td>
</tr>
<tr>
<td align="right">  118</td><td><i>予約済み</i></td><td>
<pre>void *reserved118;</pre>
</td>
</tr>
<tr>
<td align="right">  119</td><td><i>予約済み</i></td><td>
<pre>void *reserved119;</pre>
</td>
</tr>
<tr>
<td align="right">  120</td><td><a href="#SetJNIFunctionTable">JNI関数テーブルの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env, 
                       const jniNativeInterface* function_table);</pre>
</td>
</tr>
<tr>
<td align="right">  121</td><td><a href="#GetJNIFunctionTable">JNI関数テーブルの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env, 
                       jniNativeInterface** function_table);</pre>
</td>
</tr>
<tr>
<td align="right">  122</td><td><a href="#SetEventCallbacks">イベント・コールバックの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env, 
                       const jvmtiEventCallbacks* callbacks, 
                       jint size_of_callbacks);</pre>
</td>
</tr>
<tr>
<td align="right">  123</td><td><a href="#GenerateEvents">イベントの生成</a></td><td>
<pre>jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env, 
                       jvmtiEvent event_type);</pre>
</td>
</tr>
<tr>
<td align="right">  124</td><td><a href="#GetExtensionFunctions">拡張関数の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env, 
                       jint* extension_count_ptr, 
                       jvmtiExtensionFunctionInfo** extensions);</pre>
</td>
</tr>
<tr>
<td align="right">  125</td><td><a href="#GetExtensionEvents">拡張イベントの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env, 
                       jint* extension_count_ptr, 
                       jvmtiExtensionEventInfo** extensions);</pre>
</td>
</tr>
<tr>
<td align="right">  126</td><td><a href="#SetExtensionEventCallback">拡張イベント・コールバックの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env, 
                       jint extension_event_index, 
                       jvmtiExtensionEvent callback);</pre>
</td>
</tr>
<tr>
<td align="right">  127</td><td><a href="#DisposeEnvironment">環境の破棄</a></td><td>
<pre>jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);</pre>
</td>
</tr>
<tr>
<td align="right">  128</td><td><a href="#GetErrorName">エラー名の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env, 
                       jvmtiError error, 
                       char** name_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  129</td><td><a href="#GetJLocationFormat">JLocation形式の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env, 
                       jvmtiJlocationFormat* format_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  130</td><td><a href="#GetSystemProperties">システム・プロパティの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env, 
                       jint* count_ptr, 
                       char*** property_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  131</td><td><a href="#GetSystemProperty">システム・プロパティの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env, 
                       const char* property, 
                       char** value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  132</td><td><a href="#SetSystemProperty">システム・プロパティの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env, 
                       const char* property, 
                       const char* value_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  133</td><td><a href="#GetPhase">段階の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env, 
                       jvmtiPhase* phase_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  134</td><td><a href="#GetCurrentThreadCpuTimerInfo">現在のスレッドのCPUタイマー情報を取得</a></td><td>
<pre>jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env, 
                       jvmtiTimerInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  135</td><td><a href="#GetCurrentThreadCpuTime">現在のスレッドのCPU時間を取得</a></td><td>
<pre>jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env, 
                       jlong* nanos_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  136</td><td><a href="#GetThreadCpuTimerInfo">スレッドのCPUタイマー情報を取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env, 
                       jvmtiTimerInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  137</td><td><a href="#GetThreadCpuTime">スレッドのCPU時間を取得</a></td><td>
<pre>jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env, 
                       jthread thread, 
                       jlong* nanos_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  138</td><td><a href="#GetTimerInfo">タイマー情報の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env, 
                       jvmtiTimerInfo* info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  139</td><td><a href="#GetTime">時間の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetTime) (jvmtiEnv* env, 
                       jlong* nanos_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  140</td><td><a href="#GetPotentialCapabilities">潜在的な権限の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env, 
                       jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  141</td><td><i>予約済み</i></td><td>
<pre>void *reserved141;</pre>
</td>
</tr>
<tr>
<td align="right">  142</td><td><a href="#AddCapabilities">権限の追加</a></td><td>
<pre>jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env, 
                       const jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  143</td><td><a href="#RelinquishCapabilities">権限の放棄</a></td><td>
<pre>jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env, 
                       const jvmtiCapabilities* capabilities_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  144</td><td><a href="#GetAvailableProcessors">使用可能なプロセッサの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env, 
                       jint* processor_count_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  145</td><td><a href="#GetClassVersionNumbers">クラス・バージョン番号の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* minor_version_ptr, 
                       jint* major_version_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  146</td><td><a href="#GetConstantPool">定数プールの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env, 
                       jclass klass, 
                       jint* constant_pool_count_ptr, 
                       jint* constant_pool_byte_count_ptr, 
                       unsigned char** constant_pool_bytes_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  147</td><td><a href="#GetEnvironmentLocalStorage">環境ローカル記憶領域の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env, 
                       void** data_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  148</td><td><a href="#SetEnvironmentLocalStorage">環境ローカル記憶領域の設定</a></td><td>
<pre>jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env, 
                       const void* data);</pre>
</td>
</tr>
<tr>
<td align="right">  149</td><td><a href="#AddToBootstrapClassLoaderSearch">ブートストラップ・クラス・ローダー検索の追加</a></td><td>
<pre>jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env, 
                       const char* segment);</pre>
</td>
</tr>
<tr>
<td align="right">  150</td><td><a href="#SetVerboseFlag">冗長フラグの設定</a></td><td>
<pre>jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env, 
                       jvmtiVerboseFlag flag, 
                       jboolean value);</pre>
</td>
</tr>
<tr>
<td align="right">  151</td><td><a href="#AddToSystemClassLoaderSearch">システム・クラス・ローダー検索の追加</a></td><td>
<pre>jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env, 
                       const char* segment);</pre>
</td>
</tr>
<tr>
<td align="right">  152</td><td><a href="#RetransformClasses">クラスの再変換</a></td><td>
<pre>jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env, 
                       jint class_count, 
                       const jclass* classes);</pre>
</td>
</tr>
<tr>
<td align="right">  153</td><td><a href="#GetOwnedMonitorStackDepthInfo">所有モニターのスタックの深さ情報の取得</a></td><td>
<pre>jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env, 
                       jthread thread, 
                       jint* monitor_info_count_ptr, 
                       jvmtiMonitorStackDepthInfo** monitor_info_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  154</td><td><a href="#GetObjectSize">オブジェクト・サイズの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env, 
                       jobject object, 
                       jlong* size_ptr);</pre>
</td>
</tr>
<tr>
<td align="right">  155</td><td><a href="#GetLocalInstance">局所インスタンスの取得</a></td><td>
<pre>jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env, 
                       jthread thread, 
                       jint depth, 
                       jobject* value_ptr);</pre>
</td>
</tr>
</table>
<p></p>
<p id="EventSection"></p>
<p></p>
<hr noshade size="3">
<h2>イベント</h2>
<h4 id="eventIntro">イベントの処理</h4>
    エージェントは、アプリケーション・プログラム内で発生する多くのイベントについての通知を受けることができます。
    <p></p>
    イベントを処理するには、<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>を使ってコールバック関数のセットを指定します。イベントごとに、対応するコールバック関数が呼び出されます。コールバック関数の引数は、イベントに関する追加情報を提供します。 
    <p></p>
    コールバック関数は通常、アプリケーション・スレッド内から呼び出されます。JVM<small style="font-size: xx-small">&nbsp;</small>TI実装がイベントをキューに入れることは、決してありません。これは、イベントのコールバック関数を注意深く記述する必要があることを意味しています。このあと、一般的なガイドラインを説明します。さらに詳しい提案については、個々のイベントの説明を参照してください。
    <p></p>
    
<ul type="disc">
      
<li>イベント・コールバック関数の実行中にスローされた例外は、現在のアプリケーション・スレッド内で現在保留中の例外を上書きできてしまいます。したがって、例外を生成する可能性のあるJNI呼出しをイベント・コールバック関数から実行する場合は、保留中の例外を保存するように気を付けなければなりません。
      </li>
      
<li>イベント・コールバック関数は、再入可能でなければなりません。JVM<small style="font-size: xx-small">&nbsp;</small>TI実装は、イベントをキューに入れません。エージェントが複数のイベントを一度に1つずつ処理する必要がある場合は、イベント・コールバック関数の内部でrawモニターを使うと、イベントの処理を直列化できます。
      </li>
      
<li>JNIのFindClass関数を実行してクラスをロードするイベント・コールバック関数では、FindClassは現在のネイティブ・メソッドに関連付けられたクラス・ローダーを見つける、という点に注意する必要があります。クラスのロードの目的とする場合、コールバックのパラメータとしてJNI環境を含むイベント・コールバックは、それがネイティブ呼出しであるかのように扱われます(そのネイティブ・メソッドは、イベント・スレッドの現在のフレームのクラス内に存在する)。
      </li>
    
</ul>
    
<p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TIイベントの中には、JNI参照を使ってオブジェクトを識別するものがあります。JVM<small style="font-size: xx-small">&nbsp;</small>TIイベント内のすべての参照は、JNIローカル参照で、イベント・コールバック関数から復帰すると無効になります。記述されていない場合、イベント・コールバック内で送信されたポインタによって参照されるメモリーは、イベント・コールバックの終了後は参照できません。
    <p></p>
    特に明記されていないかぎり、イベントの配信は、そのイベントが発生したスレッド上で行われます。イベントは発生と同時に送信されます。各イベントの仕様には、そのイベントの送信が可能な<a href="#GetPhase">段階</a>のセットが含まれています。イベントをトリガーするアクティビティが別の段階で発生しても、イベントは送信されません。 
    <p></p>
    イベントを生成するスレッドの実行ステータスが変更されることはありません(たとえば、イベントによってスレッドが中断されることはない)。エージェントがイベント発生時の中断を必要とする場合、<a href="#SuspendThread"><code>SuspendThread</code></a>でスレッドを明示的に中断するのは、エージェントの責任となります。
    <p></p>
    複数の環境で有効になっているイベントは、これらの環境が作成された順に、各エージェントに送信されます。
  <h4 id="enablingevents">イベントの有効化</h4>
    すべてのイベントは、初期段階では無効になっています。イベントを受信するには、次のようにします。
      <ul type="disc">
	
<li>
	  イベントが権限を必要とする場合、<a href="#AddCapabilities"><code>AddCapabilities</code></a>を使ってその権限を追加する必要がある。
	</li>
	
<li>
	  <a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>を使って、イベントのコールバックを設定する必要がある。
	</li>
	
<li>
	  <a href="#SetEventNotificationMode"><code>SetEventNotificationMode</code></a>を使って、イベントを有効にする必要がある。 
	</li>
      
</ul>
  
<h4 id="eventorder">同じ位置で発生する複数のイベント</h4>
    多くの状況で、1つのスレッド内の同じ位置で複数のイベントが発生する可能性があります。そのような状況では、このセクションで説明する順序で、イベント・コールバックによりすべてのイベントがレポートされます。
    <p></p>
    現在位置がメソッドのエントリ・ポイントである場合は、同一スレッド内の現在位置で発生したほかのすべてのイベントより前に、<a href="#MethodEntry"><code>MethodEntry</code></a>イベントがレポートされます。
    <p></p>
    現在位置で例外のキャッチが検出された場合(catch節の先頭の場合か、未処理の例外を解除したネイティブ・メソッドが復帰した位置の場合)は、同一スレッド内の現在位置で発生したほかのすべてのイベントより前に、<code>exceptionCatch</code>イベントがレポートされます。
    <p></p>
    <code>singleStep</code>イベントまたは<code>breakpoint</code>イベントが現在位置でトリガーされる場合、そのイベントは、現在位置のコードが実行される直前に発生するものと定義されています。これらのイベントは、同一スレッド内の現在位置にあるコードの実行によりトリガーされるどのイベント(特に、<code>exception</code>、<code>fieldAccess</code>、および<code>fieldModification</code>)よりも前にレポートされます。ステップ・イベントとブレークポイント・イベントの両方が同一のスレッドおよび場所でトリガーされた場合は、ステップ・イベントがブレークポイント・イベントより前にレポートされます。
    <p></p>
    現在位置がメソッドの終了ポイント(つまり、呼出し側に復帰する前の最後の位置)である場合、<a href="#MethodExit"><code>MethodExit</code></a>イベントおよび<a href="#FramePop"><code>FramePop</code></a>イベント(要求されている場合)は、同一スレッド内の現在位置で発生するほかのすべてのイベントのあとにレポートされます。これら2つのイベントについては、レポートされる順序は特に指定されていません。
    <p></p>
    あるイベントをエージェントが処理している最中に、同じスレッド内の同じ位置で別の(共通位置)イベントがトリガーされる可能性があります。<i>x</i>型のイベントの処理中にそのような<i>y</i>型のイベントがトリガーされ、かつ上で規定した順序付けに基づいて<i>x</i>が<i>y</i>よりも先である場合、現在のスレッドと位置に対して共通位置イベント<i>y</i>が報告されます。<i>x</i>が<i>y</i>よりも先でない場合、<i>y</i>は現在のスレッドと位置に対して報告されません。たとえば、<a href="#SingleStep"><code>SingleStep</code></a>の処理中に現在位置でブレークポイントが設定された場合、そのブレークポイントは、スレッドが現在位置を離れる前に報告されます。
    <p></p>以下のイベントは、ほかのイベントと同じ位置で発生したと見なされることがありません。
    <ul type="disc">
      
<li>
<a href="#VMStart"><code>VMStart</code></a>
</li>
      
<li>
<a href="#VMInit"><code>VMInit</code></a>
</li>
      
<li>
<a href="#VMDeath"><code>VMDeath</code></a>
</li>
      
<li>
<a href="#ThreadStart"><code>ThreadStart</code></a>
</li>
      
<li>
<a href="#ThreadEnd"><code>ThreadEnd</code></a>
</li>
      
<li>
<a href="#ClassLoad"><code>ClassLoad</code></a>
</li>
      
<li>
<a href="#ClassPrepare"><code>ClassPrepare</code></a>
</li>
    
</ul>
  
<h4 id="jvmtiEventCallbacks">イベント・コールバック</h4>
      以下のイベント・コールバック構造体では、イベントのハンドラ関数を指定できます。これは、<a href="#SetEventCallbacks"><code>SetEventCallbacks</code></a>関数で設定されます。 
  <blockquote>
<pre>
typedef struct {
    jvmtiEventVMInit VMInit;
    jvmtiEventVMDeath VMDeath;
    jvmtiEventThreadStart ThreadStart;
    jvmtiEventThreadEnd ThreadEnd;
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
    jvmtiEventClassLoad ClassLoad;
    jvmtiEventClassPrepare ClassPrepare;
    jvmtiEventVMStart VMStart;
    jvmtiEventException Exception;
    jvmtiEventExceptionCatch ExceptionCatch;
    jvmtiEventSingleStep SingleStep;
    jvmtiEventFramePop FramePop;
    jvmtiEventBreakpoint Breakpoint;
    jvmtiEventFieldAccess FieldAccess;
    jvmtiEventFieldModification FieldModification;
    jvmtiEventMethodEntry MethodEntry;
    jvmtiEventMethodExit MethodExit;
    jvmtiEventNativeMethodBind NativeMethodBind;
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
    jvmtiEventDataDumpRequest DataDumpRequest;
    jvmtiEventReserved reserved72;
    jvmtiEventMonitorWait MonitorWait;
    jvmtiEventMonitorWaited MonitorWaited;
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
    jvmtiEventReserved reserved77;
    jvmtiEventReserved reserved78;
    jvmtiEventReserved reserved79;
    jvmtiEventResourceExhausted ResourceExhausted;
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
    jvmtiEventObjectFree ObjectFree;
    jvmtiEventVMObjectAlloc VMObjectAlloc;
} jvmtiEventCallbacks;
</pre>
</blockquote>
<p></p>
<hr noshade width="100%" size="1">
<h3 id="EventIndex">イベントの索引</h3>
<ul>
<li>
<a href="#Breakpoint"><b>ブレークポイント</b></a>
</li>
<li>
<a href="#ClassFileLoadHook"><b>クラス・ファイル・ロード・フック</b></a>
</li>
<li>
<a href="#ClassLoad"><b>クラスのロード</b></a>
</li>
<li>
<a href="#ClassPrepare"><b>クラスの準備</b></a>
</li>
<li>
<a href="#CompiledMethodLoad"><b>コンパイル済みメソッドのロード</b></a>
</li>
<li>
<a href="#CompiledMethodUnload"><b>コンパイル済みメソッドのアンロード</b></a>
</li>
<li>
<a href="#DataDumpRequest"><b>データ・ダンプ要求</b></a>
</li>
<li>
<a href="#DynamicCodeGenerated"><b>動的コード生成</b></a>
</li>
<li>
<a href="#Exception"><b>例外</b></a>
</li>
<li>
<a href="#ExceptionCatch"><b>例外キャッチ</b></a>
</li>
<li>
<a href="#FieldAccess"><b>フィールド・アクセス</b></a>
</li>
<li>
<a href="#FieldModification"><b>フィールドの変更</b></a>
</li>
<li>
<a href="#FramePop"><b>フレームのポップ</b></a>
</li>
<li>
<a href="#GarbageCollectionFinish"><b>ガベージ・コレクションの完了</b></a>
</li>
<li>
<a href="#GarbageCollectionStart"><b>ガベージ・コレクションの開始</b></a>
</li>
<li>
<a href="#MethodEntry"><b>メソッド・エントリ</b></a>
</li>
<li>
<a href="#MethodExit"><b>メソッド終了</b></a>
</li>
<li>
<a href="#MonitorContendedEnter"><b>競合するモニター開始</b></a>
</li>
<li>
<a href="#MonitorContendedEntered"><b>競合するモニター開始済み</b></a>
</li>
<li>
<a href="#MonitorWait"><b>モニター待機</b></a>
</li>
<li>
<a href="#MonitorWaited"><b>モニター待機終了</b></a>
</li>
<li>
<a href="#NativeMethodBind"><b>ネイティブ・メソッドのバインド</b></a>
</li>
<li>
<a href="#ObjectFree"><b>オブジェクトの解放</b></a>
</li>
<li>
<a href="#ResourceExhausted"><b>リソース不足</b></a>
</li>
<li>
<a href="#SingleStep"><b>ステップ実行</b></a>
</li>
<li>
<a href="#ThreadEnd"><b>スレッドの終了</b></a>
</li>
<li>
<a href="#ThreadStart"><b>スレッドの開始</b></a>
</li>
<li>
<a href="#VMDeath"><b>VM終了イベント</b></a>
</li>
<li>
<a href="#VMInit"><b>VM初期化イベント</b></a>
</li>
<li>
<a href="#VMObjectAlloc"><b>VMオブジェクト割り当て</b></a>
</li>
<li>
<a href="#VMStart"><b>VM開始イベント</b></a>
</li>
</ul>
<p id="SingleStep"></p>
<hr noshade size="3">
<h2>ステップ実行</h2>
<p></p>
<blockquote>
<pre>void JNICALL
SingleStep(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
      ステップ実行イベントを利用すると、エージェントは、VMで可能な最小の単位でスレッドの実行を追跡できます。ステップ実行イベントは、スレッドが新しい位置に達するたびに生成されます。通常、ステップ実行イベントは、<cite>Java(tm)仮想マシン仕様</cite>に定義されているように、1つのVM命令が完了したことを示します。ただし、位置の定義が異なる実装もあります。いずれにしても、<code>method</code>および<code>location</code>パラメータによって現在の位置を一意に識別できるため、この情報があればソース・ファイルと行番号へのマッピングが可能です。
      <p></p>
      ネイティブ・メソッド内からは、ステップ実行イベントは生成されません。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_SINGLE_STEP</code></td><td>60</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_single_step_events"><code>can_generate_single_step_events</code></a></td><td>
	  <a href="#SingleStep">ステップ実行</a>イベントを取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="SingleStep.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="SingleStep.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    新しい命令を実行しようとしているスレッド
	  </td>
</tr>
<tr>
<td><code id="SingleStep.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    新しい命令を実行しようとしているメソッド
	  </td>
</tr>
<tr>
<td><code id="SingleStep.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  新しい命令の位置
	</td>
</tr>
</table>
<p id="Breakpoint"></p>
<hr noshade size="3">
<h2>ブレークポイント</h2>
<p></p>
<blockquote>
<pre>void JNICALL
Breakpoint(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location)</pre>
</blockquote>
      ブレークポイント・イベントは、<a href="#SetBreakpoint"><code>SetBreakpoint</code></a>を使ってブレークポイントとして指定された位置にスレッドが達した時点で生成されます。<code>method</code>および<code>location</code>パラメータは、現在の位置を一意に識別し、ソース・ファイルと行番号(その情報が入手できる場合)にマッピングできます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_BREAKPOINT</code></td><td>62</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_breakpoint_events"><code>can_generate_breakpoint_events</code></a></td><td>
	  <a href="#Breakpoint"><code>Breakpoint</code></a>イベントを<a href="#SetBreakpoint">設定</a>し、取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="Breakpoint.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境。
          </td>
</tr>
<tr>
<td><code id="Breakpoint.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    ブレークポイントに達したスレッド
	  </td>
</tr>
<tr>
<td><code id="Breakpoint.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    ブレークポイントに達したメソッド
	  </td>
</tr>
<tr>
<td><code id="Breakpoint.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  ブレークポイントの位置
	</td>
</tr>
</table>
<p id="FieldAccess"></p>
<hr noshade size="3">
<h2>フィールド・アクセス</h2>
<p></p>
<blockquote>
<pre>void JNICALL
FieldAccess(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field)</pre>
</blockquote>
      フィールド・アクセス・イベントは、<a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>を使ってウォッチポイントとして指定されたフィールドにスレッドがアクセスした時点で生成されます。<code>method</code>および<code>location</code>パラメータは、現在の位置を一意に識別し、ソース・ファイルと行番号(その情報が入手できる場合)にマッピングできます。 
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_FIELD_ACCESS</code></td><td>63</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_access_events"><code>can_generate_field_access_events</code></a></td><td>
	  フィールド・アクセスにウォッチポイントを設定できる - <a href="#SetFieldAccessWatch"><code>SetFieldAccessWatch</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="FieldAccess.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="FieldAccess.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    フィールドにアクセスするスレッド
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    アクセスが発生しているメソッド
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  アクセスが発生している位置
	</td>
</tr>
<tr>
<td><code id="FieldAccess.field_klass">field_klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	    アクセスされるフィールドのクラス
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    フィールドがインスタンス・フィールドの場合はアクセスされているフィールドを持つオブジェクト、それ以外の場合は<code>NULL</code>
	  </td>
</tr>
<tr>
<td><code id="FieldAccess.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	    アクセスされているフィールド
	  </td>
</tr>
</table>
<p id="FieldModification"></p>
<hr noshade size="3">
<h2>フィールドの変更</h2>
<p></p>
<blockquote>
<pre>void JNICALL
FieldModification(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jclass field_klass,
            jobject object,
            jfieldID field,
            char signature_type,
            jvalue new_value)</pre>
</blockquote>
      フィールドの変更イベントは、<a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>を使ってウォッチポイントとして指定されたフィールドをスレッドが変更した時点で生成されます。<code>method</code>および<code>location</code>パラメータは、現在の位置を一意に識別し、ソース・ファイルと行番号(その情報が入手できる場合)にマッピングできます。 
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_FIELD_MODIFICATION</code></td><td>64</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_field_modification_events"><code>can_generate_field_modification_events</code></a></td><td>
	  フィールドの変更にウォッチポイントを設定できる - <a href="#SetFieldModificationWatch"><code>SetFieldModificationWatch</code></a>
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="FieldModification.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="FieldModification.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    フィールドを変更するスレッド
	  </td>
</tr>
<tr>
<td><code id="FieldModification.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    変更が発生しているメソッド
	  </td>
</tr>
<tr>
<td><code id="FieldModification.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  変更が発生している位置
	</td>
</tr>
<tr>
<td><code id="FieldModification.field_klass">field_klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	    変更されているフィールドのクラス
	  </td>
</tr>
<tr>
<td><code id="FieldModification.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    フィールドがインスタンス・フィールドの場合は変更されているフィールドを持つオブジェクト、それ以外の場合は<code>NULL</code>
	  </td>
</tr>
<tr>
<td><code id="FieldModification.field">field</code></td><td><code><a href="#jfieldID">jfieldID</a></code></td><td>
	    変更されているフィールド
	  </td>
</tr>
<tr>
<td><code id="FieldModification.signature_type">signature_type</code></td><td><code>char</code></td><td>
	  新しい値のシグニチャの型
	</td>
</tr>
<tr>
<td><code id="FieldModification.new_value">new_value</code></td><td><code><a href="#jvalue">jvalue</a></code></td><td>
	  新しい値
	</td>
</tr>
</table>
<p id="FramePop"></p>
<hr noshade size="3">
<h2>フレームのポップ</h2>
<p></p>
<blockquote>
<pre>void JNICALL
FramePop(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception)</pre>
</blockquote>
      フレーム・ポップ・イベントは、<a href="#NotifyFramePop"><code>NotifyFramePop</code></a>の呼出しで指定された単一のフレーム内の単一のメソッドから出る時点で生成されます。これは、戻り命令の実行または呼出し側への例外のスローによって終了された場合、trueとなります(<a href="#FramePop.was_popped_by_exception"><code>was_popped_by_exception</code></a>を参照)。ただし、<a href="#PopFrame"><code>PopFrame</code></a>関数によるフレームのポップはレポートされません。
      <p></p>
      <a href="#GetFrameLocation"><code>GetFrameLocation</code></a>によりレポートされる位置は、復帰しようとしているメソッド内の復帰直前の実行可能位置を識別します。 
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_FRAME_POP</code></td><td>61</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_frame_pop_events"><code>can_generate_frame_pop_events</code></a></td><td>
	  <a href="#FramePop"><code>FramePop</code></a>イベントを<a href="#NotifyFramePop">設定</a>し、取得できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="FramePop.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="FramePop.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    フレームをポップするスレッド
	  </td>
</tr>
<tr>
<td><code id="FramePop.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    ポップされるメソッド
	  </td>
</tr>
<tr>
<td><code id="FramePop.was_popped_by_exception">was_popped_by_exception</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	  フレームが例外のスローによってポップされた場合はtrue。メソッドが戻り命令によって終了した場合はfalse。
	</td>
</tr>
</table>
<p id="MethodEntry"></p>
<hr noshade size="3">
<h2>メソッド・エントリ</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MethodEntry(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method)</pre>
</blockquote>
      メソッド・エントリ・イベントは、Javaプログラミング言語メソッド(ネイティブ・メソッドを含む)に入る時点で生成されます。
      <p></p>
      <a href="#GetFrameLocation"><code>GetFrameLocation</code></a>によりレポートされる位置は、メソッド内の初期実行可能位置を識別します。 
      <p></p>
      多くのプラットフォームでは、メソッド・エントリ・イベントまたはメソッド終了イベントを有効にすると、パフォーマンスが大幅に低下します。したがって、プロ・ファイリングなど、パフォーマンスを重視する処理での使用はお薦めしません。これらの場合には、<a href="#bci">バイトコード・インストゥルメンテーション</a>を使用すべきです。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_METHOD_ENTRY</code></td><td>65</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_entry_events"><code>can_generate_method_entry_events</code></a></td><td>
	  メソッドに入るときにメソッド・エントリ・イベントを生成できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="MethodEntry.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="MethodEntry.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    メソッドに入るスレッド
	  </td>
</tr>
<tr>
<td><code id="MethodEntry.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    入る先のメソッド
	  </td>
</tr>
</table>
<p id="MethodExit"></p>
<hr noshade size="3">
<h2>メソッド終了</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MethodExit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jboolean was_popped_by_exception,
            jvalue return_value)</pre>
</blockquote>
      メソッド終了イベントは、Javaプログラミング言語メソッドおよびネイティブ・メソッドから終了する時点で生成されます。これは、戻り命令の実行または呼出し側への例外のスローによって終了された場合、trueとなります(<a href="#MethodExit.was_popped_by_exception"><code>was_popped_by_exception</code></a>を参照)。
      <p></p>
      <code>method</code>フィールドは、入るメソッドまたは出るメソッドを一意に識別します。<code>frame</code>フィールドは、メソッドのスタック・フレームへのアクセスを提供します。
      <p></p>
      <a href="#GetFrameLocation"><code>GetFrameLocation</code></a>によりレポートされる位置は、復帰しようとしているメソッド内の復帰直前の実行可能位置を識別します。 
      <p></p>
        多くのプラットフォームでは、メソッド・エントリ・イベントまたはメソッド終了イベントを有効にすると、パフォーマンスが大幅に低下します。したがって、プロ・ファイリングなど、パフォーマンスを重視する処理での使用はお薦めしません。これらの場合には、<a href="#bci">バイトコード・インストゥルメンテーション</a>を使用すべきです。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_METHOD_EXIT</code></td><td>66</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_method_exit_events"><code>can_generate_method_exit_events</code></a></td><td>
	  メソッドの終了時にメソッド終了イベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="MethodExit.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="MethodExit.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    メソッドを終了するスレッド
	  </td>
</tr>
<tr>
<td><code id="MethodExit.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    終了されるメソッド
	  </td>
</tr>
<tr>
<td><code id="MethodExit.was_popped_by_exception">was_popped_by_exception</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	  フレームが例外のスローによってポップされた場合はtrue。メソッドが戻り命令によって終了した場合はfalse。
	</td>
</tr>
<tr>
<td><code id="MethodExit.return_value">return_value</code></td><td><code><a href="#jvalue">jvalue</a></code></td><td>
	  終了されるメソッドの戻り値。<a href="#MethodExit.was_popped_by_exception"><code>was_popped_by_exception</code></a>がtrueの場合、未定義で、使用すべきでない。
	</td>
</tr>
</table>
<p id="NativeMethodBind"></p>
<hr noshade size="3">
<h2>ネイティブ・メソッドのバインド</h2>
<p></p>
<blockquote>
<pre>void JNICALL
NativeMethodBind(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            void* address,
            void** new_address_ptr)</pre>
</blockquote>
      ネイティブ・メソッド・バインド・イベントは、VMがJavaプログラミング言語のネイティブ・メソッドを、そのネイティブ・メソッドを実装する関数のアドレスにバインドした時点で送信されます。これは、ネイティブ・メソッドの初回呼出し時に発生しますが、JNI関数<code>RegisterNatives</code>の呼出し時にも発生します。このイベントを使えば、エージェントが指定するプロキシ関数にバインドをリダイレクトできます。このイベントは、ネイティブ・メソッドがバインド解除された場合には送信されません。通常、このプロキシ関数は特定のメソッドに固有であるか、あるいは一般的な場合に対応できるように自動生成されたアセンブリ・コードでなければいけません。インストゥルメンテーション・コードが実行された後、通常は元のバインディング・アドレスにある関数が呼び出されるからです。元のバインディングを復元したり、リダイレクションを変更したりするには、JNI関数<code>RegisterNatives</code>を使用します。一部のイベントは初期段階で送信可能です。この時点ではJNIや大部分のJVM<small style="font-size: xx-small">&nbsp;</small>TIは使用不可能ですが、メソッドやアドレスを後で使用するために保存しておくことはできます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  初期段階、開始段階、およびライブ段階で送信される
</td><td><code>JVMTI_EVENT_NATIVE_METHOD_BIND</code></td><td>67</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_native_method_bind_events"><code>can_generate_native_method_bind_events</code></a></td><td>
	  ネイティブ・メソッドが実装にバインドされているときイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="NativeMethodBind.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境は、初期<a href="#GetPhase">段階</a>中に送信されると<code>NULL</code>になる。
          </td>
</tr>
<tr>
<td><code id="NativeMethodBind.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    バインドを要求するスレッド
	  </td>
</tr>
<tr>
<td><code id="NativeMethodBind.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    バインドされるネイティブ・メソッド
	  </td>
</tr>
<tr>
<td><code id="NativeMethodBind.address">address</code></td><td><code>void*</code></td><td>
	  VMのバインド先のアドレス(ネイティブ・メソッドの実装アドレス)
	</td>
</tr>
<tr>
<td><code id="NativeMethodBind.new_address_ptr">new_address_ptr</code></td><td><code>void**</code></td><td>
	  参照アドレスが変更された場合(つまり、<code>*new_address_ptr</code>が設定された場合)、代わりに、提供されたアドレスへのバインドが行われる。
	</td>
</tr>
</table>
<p id="Exception"></p>
<hr noshade size="3">
<h2>例外</h2>
<p></p>
<blockquote>
<pre>void JNICALL
Exception(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception,
            jmethodID catch_method,
            jlocation catch_location)</pre>
</blockquote>
      例外イベントは、Javaプログラミング言語メソッド内で例外が初めて検出されるたびに生成されます。ここで、「例外」は任意の<code>java.lang.Throwable</code>を意味します。例外は、Javaプログラミング言語メソッド、ネイティブ・メソッドのいずれかによってスローされる可能性がありますが、ネイティブ・メソッドの場合には、その例外がJavaプログラミング言語メソッド内で初めて認識されるまで、イベントは生成されません。ネイティブ・メソッド内で例外が設定された後クリアされた場合(したがって、例外が一度もJavaプログラミング言語コードから可視状態にならなかった場合)、例外イベントは生成されません。
      <p></p>
      <code>method</code>および<code>location</code>パラメータは、現在の位置(例外が検出された位置)を一意に識別し、ソース・ファイルと行番号(その情報が入手できる場合)にマッピングできます。<code>exception</code>フィールドは、スローされた例外オブジェクトを識別します。<code>catch_method</code>と<code>catch_location</code>は、スローされた例外を処理するcatch節が存在する場合に、その位置を識別します。そのようなcatch節が存在しない場合、各フィールドは0に設定されます。スレッドがこのcatch節に到達するという保証はありません。呼出しスタック上で、スロー位置とcatch節の間にネイティブ・メソッドが存在していれば、それらのネイティブ・メソッドのいずれかによって例外がリセットされる可能性があります。同様に、非キャッチとして報告された例外(<code>catch_klass</code>などが0に設定された例外)は、実際にはネイティブ・メソッドによってキャッチされる可能性があります。エージェントからこれらの発生をチェックするには、<a href="#ExceptionCatch"><code>ExceptionCatch</code></a>イベントを監視します。finally節は、キャッチ/再スローとして実装される点に注意してください。したがって、それらはキャッチ位置で報告されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_EXCEPTION</code></td><td>58</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_exception_events"><code>can_generate_exception_events</code></a></td><td>
	  <a href="#Exception">例外スロー</a>イベントおよび<a href="#ExceptionCatch">例外キャッチ</a>イベントを取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="Exception.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="Exception.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    例外を生成するスレッド
	  </td>
</tr>
<tr>
<td><code id="Exception.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    例外を生成するメソッド
	  </td>
</tr>
<tr>
<td><code id="Exception.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  例外が発生した位置
	</td>
</tr>
<tr>
<td><code id="Exception.exception">exception</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    スローされる例外
	  </td>
</tr>
<tr>
<td><code id="Exception.catch_method">catch_method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    例外をキャッチするメソッド。既知のキャッチがない場合は<code>NULL</code>
	  </td>
</tr>
<tr>
<td><code id="Exception.catch_location">catch_location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  例外をキャッチする位置。既知のキャッチがない場合はゼロ
	</td>
</tr>
</table>
<p id="ExceptionCatch"></p>
<hr noshade size="3">
<h2>例外キャッチ</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ExceptionCatch(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jmethodID method,
            jlocation location,
            jobject exception)</pre>
</blockquote>
      例外キャッチ・イベントは、スローされた例外がキャッチされた時点で生成されます。ここで、「例外」は任意の<code>java.lang.Throwable</code>を意味します。例外がJavaプログラミング言語メソッド内でキャッチされた場合は、catch節に到達した時点でこのイベントが生成されます。例外がネイティブ・メソッド内でキャッチされた場合は、Javaプログラミング言語メソッドに制御が戻った直後にこのイベントが生成されます。例外キャッチ・イベントは、Javaプログラミング言語メソッド内でスローが検出された例外に対して生成されます。finally節は、キャッチ/再スローとして実装される点に注意してください。このため、これらは例外キャッチ・イベントを生成します。
      <p></p>
      <code>method</code>および<code>location</code>パラメータは、現在の位置を一意に識別し、ソース・ファイルと行番号(その情報が入手できる場合)にマッピングできます。Javaプログラミング言語メソッド内でキャッチされた例外の場合は、<code>exception</code>オブジェクトが例外オブジェクトを識別します。ネイティブ・メソッド内でキャッチされた例外は、例外のキャッチがレポートされた時点で入手可能とはかぎらないので、<code>exception</code>フィールドは<code>NULL</code>に設定されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_EXCEPTION_CATCH</code></td><td>59</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_exception_events"><code>can_generate_exception_events</code></a></td><td>
	  <a href="#Exception">例外スロー</a>イベントおよび<a href="#ExceptionCatch">例外キャッチ</a>イベントを取得できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ExceptionCatch.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="ExceptionCatch.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    例外をキャッチするスレッド
	  </td>
</tr>
<tr>
<td><code id="ExceptionCatch.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    例外をキャッチするメソッド
	  </td>
</tr>
<tr>
<td><code id="ExceptionCatch.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  例外がキャッチされる位置
	</td>
</tr>
<tr>
<td><code id="ExceptionCatch.exception">exception</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    キャッチされる例外
	  </td>
</tr>
</table>
<p id="ThreadStart"></p>
<hr noshade size="3">
<h2>スレッドの開始</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ThreadStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)</pre>
</blockquote>
      スレッド開始イベントは、新しいスレッドによって、スレッドの初期メソッドが実行される前に、生成されます。 
      <p></p>
      スレッド開始イベントが生成される前に、<a href="#GetAllThreads"><code>GetAllThreads</code></a>によって返される配列に、そのスレッドが含まれている可能性があります。また、スレッド開始イベントの前に、その他のイベントがスレッド上に生成される可能性があります。
      <p></p>
      イベントは新しく開始された<a href="#ThreadStart.thread"><code>thread</code></a>に送信されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始段階とライブ段階で送信される
</td><td><code>JVMTI_EVENT_THREAD_START</code></td><td>52</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ThreadStart.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境。
          </td>
</tr>
<tr>
<td><code id="ThreadStart.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    開始するスレッド
	  </td>
</tr>
</table>
<p id="ThreadEnd"></p>
<hr noshade size="3">
<h2>スレッドの終了</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ThreadEnd(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)</pre>
</blockquote>
      スレッド終了イベントは、停止しようとしているスレッドによって、スレッドの初期メソッドの実行完了後に、生成されます。 
      <p></p>
      スレッド終了イベントが生成されたあと、<a href="#GetAllThreads"><code>GetAllThreads</code></a>によって返される配列に、そのスレッドが含まれている可能性があります。スレッド終了イベントのあと、スレッド上にイベントは生成されません。
      <p></p>
      イベントは終了する<a href="#ThreadEnd.thread"><code>thread</code></a>に送信されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始段階とライブ段階で送信される
</td><td><code>JVMTI_EVENT_THREAD_END</code></td><td>53</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ThreadEnd.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境。
          </td>
</tr>
<tr>
<td><code id="ThreadEnd.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    終了するスレッド
	  </td>
</tr>
</table>
<p id="ClassLoad"></p>
<hr noshade size="3">
<h2>クラスのロード</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ClassLoad(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)</pre>
</blockquote>
      クラス・ロード・イベントは、クラスが最初にロードされた時点で生成されます。特定のスレッドによりクラス・ロード・イベントが生成される順序は、そのスレッド内でクラスがロードされる順序と一致することが保証されています。配列クラスの作成では、クラス・ロード・イベントは生成されません。プリミティブ・クラス(java.lang.Integer.TYPEなど)の作成では、クラス・ロード・イベントは生成されません。
      <p></p>
      このイベントは、クラスのロードの早い段階で送信されます。このため、クラスは慎重に使用する必要があります。たとえば、メソッドやフィールドがまだロードされていないため、メソッド、フィールド、サブクラスなどへの照会で、正しい結果が得られません。<i>Java言語仕様</i>のクラスとインタフェースのロードを参照してください。ほとんどの場合、<a href="#ClassPrepare"><code>ClassPrepare</code></a>の方が有効です。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始段階とライブ段階で送信される
</td><td><code>JVMTI_EVENT_CLASS_LOAD</code></td><td>55</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ClassLoad.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="ClassLoad.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    クラスをロードするスレッド
	  </td>
</tr>
<tr>
<td><code id="ClassLoad.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	    ロードされるクラス
	  </td>
</tr>
</table>
<p id="ClassPrepare"></p>
<hr noshade size="3">
<h2>クラスの準備</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ClassPrepare(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jclass klass)</pre>
</blockquote>
      クラス準備イベントは、クラスの準備が完了した時点で生成されます。この時点では、クラスのフィールド、メソッド、および実装されたインタフェースが利用可能ですが、クラスのコードはまだ何も実行されていません。配列クラスは、フィールドやメソッドを持つことがないため、配列クラスについてクラス準備イベントが生成されることはありません。プリミティブ・クラス(たとえば、<code>java.lang.Integer.TYPE</code>)についても、クラス準備イベントは生成されません。 
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始段階とライブ段階で送信される
</td><td><code>JVMTI_EVENT_CLASS_PREPARE</code></td><td>56</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ClassPrepare.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="ClassPrepare.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    クラス準備イベントを生成するスレッド
	  </td>
</tr>
<tr>
<td><code id="ClassPrepare.klass">klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	    準備されるクラス
	  </td>
</tr>
</table>
<p id="ClassFileLoadHook"></p>
<hr noshade size="3">
<h2>クラス・ファイル・ロードフック</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ClassFileLoadHook(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jclass class_being_redefined,
            jobject loader,
            const char* name,
            jobject protection_domain,
            jint class_data_len,
            const unsigned char* class_data,
            jint* new_class_data_len,
            unsigned char** new_class_data)</pre>
</blockquote>
      このイベントは、VMがクラス・ファイル・データを取得したとき、そのクラスのメモリー内部表現を構築する前の時点で送信されます。また、このイベントは、任意のJVM<small style="font-size: xx-small">&nbsp;</small>TI環境内から呼び出された<a href="#RetransformClasses"><code>RetransformClasses</code></a>関数または<a href="#RedefineClasses"><code>RedefineClasses</code></a>関数によってクラスが変更されようとしているときにも送信されます。エージェントは、VMによって送信された既存のクラス・ファイル・データを実装して、プロ・ファイリング\/デバッグ・フックを含めることができます。使用方法については、<a href="#bci">バイト・コード・インストゥルメンテーション</a>の説明を参照してください。
      <p></p>
    このイベントは、VMの初期化前(初期<a href="#GetPhase">段階</a>)に送信される可能性があります。この期間中、VMリソースは作成すべきではありません。この関数と互換性のないクラス(例: ROM化されたクラス)が存在しますが、それらのクラスではこのイベントは生成されません。
    <p></p>
    エージェントは、メモリー割当て関数<a href="#Allocate"><code>Allocate</code></a>を使用して、修正したクラス・ファイル・データのバッファ用の領域を割り当てる必要があります。新しいクラス・ファイル・データのバッファを解放する処理は、VMにより、<a href="#Deallocate"><code>Deallocate</code></a>を使用して実行されるからです。<a href="#Allocate"><code>Allocate</code></a>は初期段階で使用できます。
    <p></p>
    エージェントは、クラス・ファイルを変更する場合、新しく実装されたクラス・ファイル・データ・バッファをポイントするように<code>new_class_data</code>を設定し、この呼び出しから戻る前に、<code>new_class_data_len</code>にそのバッファの長さを設定する必要があります。変更が不要な場合、エージェントは<code>new_class_data</code>を設定しません。複数のエージェントがこのイベントを有効にしている場合、結果はチェーンになります。つまり、<code>new_class_data</code>が設定されている場合は、これが次のエージェントの<code>class_data</code>になります。
    <p></p>
    このイベントが各環境に送信される順番は、ほかのイベントの場合とは異なります。このイベントは次の順番で環境に送信されます。
    <ul type="disc">
      
<li>
<a href="#jvmtiCapabilities.can_retransform_classes">再変換不可能</a>な環境(作成された順番)
      </li>
      
<li>
<a href="#jvmtiCapabilities.can_retransform_classes">再変換可能</a>な環境(作成された順番)
      </li>
    
</ul>
    このイベントが<a href="#RetransformClasses"><code>RetransformClasses</code></a>によって起動された場合、<a href="#jvmtiCapabilities.can_retransform_classes">再変換可能</a>な環境だけにこのイベントが送信されます。
  <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  初期段階、開始段階、およびライブ段階で送信される
</td><td><code>JVMTI_EVENT_CLASS_FILE_LOAD_HOOK</code></td><td>54</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
          任意の機能
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_all_class_hook_events"><code>can_generate_all_class_hook_events</code></a></td><td>
	  ロードされたすべてのクラスに対して、ClassFileLoadHookイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境。初期<a href="#GetPhase">段階</a>中に送信された場合は<code>NULL</code>になる。
          </td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.class_being_redefined">class_being_redefined</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	  <a href="#RedefineClasses">再定義</a>または<a href="#RetransformClasses">再変換</a>されるクラス。クラスのロードによって送信された場合は<code>NULL</code>。
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.loader">loader</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    クラスをロードするクラス・ローダー。ブートストラップ・クラス・ローダーの場合は<code>NULL</code>。
	  </td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.name">name</code></td><td><code>const char*</code></td><td>
            ロード対象クラスの名前。VM内部修飾名(「java/util/List」など)。<a href="#mUTF">modified UTF-8</a>文字列としてエンコードされる。注: クラスの定義時に<code>NULL</code>名が使用されたか名前が指定されなかった場合、<code>name</code>は<code>NULL</code>になる。
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.protection_domain">protection_domain</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	  クラスの<code>ProtectionDomain</code>。
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.class_data_len">class_data_len</code></td><td><code><a href="#jint">jint</a></code></td><td>
	  現在のクラス・ファイル・データのバッファの長さ。
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.class_data">class_data</code></td><td><code>const unsigned char*</code></td><td>
	  現在のクラス・ファイル・データのバッファのポインタ。
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.new_class_data_len">new_class_data_len</code></td><td><code><a href="#jint">jint</a>*</code></td><td>
	  新しいクラス・ファイル・データのバッファの長さのポインタ。
	</td>
</tr>
<tr>
<td><code id="ClassFileLoadHook.new_class_data">new_class_data</code></td><td><code>unsigned char**</code></td><td>
	  実装済みクラス・ファイル・データのバッファのポインタへのポインタ。
	</td>
</tr>
</table>
<p id="VMStart"></p>
<hr noshade size="3">
<h2>VM開始イベント</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMStart(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)</pre>
</blockquote>
      VM初期化イベントはVMの開始を示します。この時点で、JNIはライブ状態になっていますが、VMはまだ完全に初期化されていません。このイベントが生成されたら、エージェントは任意のJNI関数を自由に呼び出せます。このイベントは開始段階の始まりを示します。開始段階で許可されたJVM<small style="font-size: xx-small">&nbsp;</small>TI関数を呼び出せます。
      <p></p>
      VMの起動に失敗した場合、このイベントは送信されません。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  開始段階とライブ段階で送信される
</td><td><code>JVMTI_EVENT_VM_START</code></td><td>57</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="VMStart.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境。
          </td>
</tr>
</table>
<p id="VMInit"></p>
<hr noshade size="3">
<h2>VM初期化イベント</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMInit(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread)</pre>
</blockquote>
      VM初期化イベントはVM初期化の完了を示します。このイベントが生成されたら、エージェントは任意のJNI関数またはJVM<small style="font-size: xx-small">&nbsp;</small>TI関数を自由に呼び出せます。VM初期化イベントと同時かそれより先に発生するイベントが存在する可能性がありますが、先行イベントが存在する場合、その処理は慎重に行うべきです。VMの初期化が完了していないからです。メイン・アプリケーション・スレッドのスレッド開始イベントは、VM初期化イベントのハンドラが復帰するまで発生しないことが保証されています。
      <p></p>
      VMの起動に失敗した場合、このイベントは送信されません。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_VM_INIT</code></td><td>50</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="VMInit.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境。
          </td>
</tr>
<tr>
<td><code id="VMInit.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    初期スレッド
	  </td>
</tr>
</table>
<p id="VMDeath"></p>
<hr noshade size="3">
<h2>VM終了イベント</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMDeath(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env)</pre>
</blockquote>
      VM終了イベントは、VMの終了をエージェントに通知します。VMDeathイベントのあとは、イベントは発生しません。
      <p></p>
      VMの起動に失敗した場合、このイベントは送信されません。こうした場合、<a href="#onunload">Agent_OnUnload</a>は呼び出される点に注意してください。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_VM_DEATH</code></td><td>51</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="VMDeath.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
</table>
<p id="CompiledMethodLoad"></p>
<hr noshade size="3">
<h2>コンパイル済みメソッドのロード</h2>
<p></p>
<blockquote>
<pre>typedef struct {
    const void* start_address;
    jlocation location;
} jvmtiAddrLocationMap;</pre>
<pre>void JNICALL
CompiledMethodLoad(jvmtiEnv *jvmti_env,
            jmethodID method,
            jint code_size,
            const void* code_addr,
            jint map_length,
            const jvmtiAddrLocationMap* map,
            const void* compile_info)</pre>
</blockquote>
      メソッドがVMによってコンパイルされ、メモリー内にロードされる時点で送信されます。アンロードされた場合、<a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a>イベントが送信されます。移動した場合、新しい<code>CompiledMethodLoad</code>イベントに続いて、<a href="#CompiledMethodUnload"><code>CompiledMethodUnload</code></a>イベントが送信されます。単一のメソッドが複数の形式でコンパイルされることがあり、このイベントがその形式ごとに送信される点に注意してください。また、複数のメソッドが単一のアドレス範囲にインラインされることがあり、このイベントが各メソッドごとに送信される点にも注意してください。
      <p></p>
      これらのイベントは、最初の発生のあと、<a href="#GenerateEvents"><code>GenerateEvents</code></a>によって送信できます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_COMPILED_METHOD_LOAD</code></td><td>68</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p id="jvmtiAddrLocationMap"></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader"><code>jvmtiAddrLocationMap</code> - 位置エントリのネイティブ・アドレス</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          フィールド
        </td><td>
          型
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="jvmtiAddrLocationMap.start_address">start_address</code></td><td><code>const void*</code></td><td>
	  位置に対応するコードの開始ネイティブ・アドレス
	</td>
</tr>
<tr>
<td><code id="jvmtiAddrLocationMap.location">location</code></td><td><code><a href="#jlocation">jlocation</a></code></td><td>
	  対応する位置。位置の意味については、<a href="#GetJLocationFormat"><code>GetJLocationFormat</code></a>を参照。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a></td><td>
	  メソッドのコンパイル時またはアンロード時にイベントを生成できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    コンパイルおよびロードされているメソッド
	  </td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.code_size">code_size</code></td><td><code><a href="#jint">jint</a></code></td><td>
	  コンパイルされたコードのサイズ
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.code_addr">code_addr</code></td><td><code>const void*</code></td><td>
	  コンパイルされたメソッド・コードがロードされるアドレス
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.map_length">map_length</code></td><td><code><a href="#jint">jint</a></code></td><td>
	  アドレス・マップ内の<a href="#jvmtiAddrLocationMap"><code>jvmtiAddrLocationMap</code></a>エントリの数。マッピング情報が提供されない場合はゼロ。
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.map">map</code></td><td><code>const <a href="#jvmtiAddrLocationMap">jvmtiAddrLocationMap</a>*</code></td><td>
	  ネイティブ・アドレスと位置のマッピング。各エントリのネイティブ・アドレス範囲は、<a href="#jvmtiAddrLocationMap.start_address"><code>start_address</code></a>から次のエントリの<code>start_address-1</code>まで。マッピング情報が提供されない場合は<code>NULL</code>。
	</td>
</tr>
<tr>
<td><code id="CompiledMethodLoad.compile_info">compile_info</code></td><td><code>const void*</code></td><td>
	  VM固有のコンパイル情報。参照されるコンパイル情報は、VMによって管理され、収集のためにエージェントに依存していてはならない。この情報の内容と寿命は、VM実装によって定義される。
	</td>
</tr>
</table>
<p id="CompiledMethodUnload"></p>
<hr noshade size="3">
<h2>コンパイル済みメソッドのアンロード</h2>
<p></p>
<blockquote>
<pre>void JNICALL
CompiledMethodUnload(jvmtiEnv *jvmti_env,
            jmethodID method,
            const void* code_addr)</pre>
</blockquote>
      コンパイル済メソッドがメモリーからアンロードされた時点で送信されます。このイベントは、アンロードを実行したスレッド上で送信されない可能性があります。このイベントは、アンロード発生後少し経ってから送信される可能性がありますが、新しく生成されたコンパイル済メソッドによってメモリーが再利用される前に送信されます。このイベントは、クラスのアンロード後に送信される可能性があります。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_COMPILED_METHOD_UNLOAD</code></td><td>69</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_compiled_method_load_events"><code>can_generate_compiled_method_load_events</code></a></td><td>
	  メソッドのコンパイル時またはアンロード時にイベントを生成できる
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="CompiledMethodUnload.method">method</code></td><td><code><a href="#jmethodID">jmethodID</a></code></td><td>
	    アンロード対象のコンパイル済メソッド。コンパイル済メソッドの識別専用。クラスはアンロードされるため、メソッドを以後のJNIまたはJVM<small style="font-size: xx-small">&nbsp;</small>TI関数の引数として使用できない。
	  </td>
</tr>
<tr>
<td><code id="CompiledMethodUnload.code_addr">code_addr</code></td><td><code>const void*</code></td><td>
	  コンパイルされたメソッド・コードがロードされたアドレス。コンパイル済メソッドの識別専用。領域が回収済の可能性がある。
	</td>
</tr>
</table>
<p id="DynamicCodeGenerated"></p>
<hr noshade size="3">
<h2>動的コード生成</h2>
<p></p>
<blockquote>
<pre>void JNICALL
DynamicCodeGenerated(jvmtiEnv *jvmti_env,
            const char* name,
            const void* address,
            jint length)</pre>
</blockquote>
      仮想マシンのコンポーネントが動的に生成された時点で送信されます。これは、コンパイル済のJavaプログラミング言語コードには対応しません。<a href="#CompiledMethodLoad"><code>CompiledMethodLoad</code></a>を参照してください。これは、コマンド行オプションに応じて異なる内容で生成されるインタープリタなどの、ネイティブ・コード用です。
      <p></p>
      このイベントには、制御権限はありません。VMは、これらのイベントを生成できない場合、何も送信しません。
      <p></p>
      これらのイベントは、最初の発生のあと、<a href="#GenerateEvents"><code>GenerateEvents</code></a>によって送信できます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  初期段階、開始段階、およびライブ段階で送信される
</td><td><code>JVMTI_EVENT_DYNAMIC_CODE_GENERATED</code></td><td>70</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="DynamicCodeGenerated.name">name</code></td><td><code>const char*</code></td><td>
	  コードの名前。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。エンドユーザーへの表示用。名前は一意でない可能性がある。
	</td>
</tr>
<tr>
<td><code id="DynamicCodeGenerated.address">address</code></td><td><code>const void*</code></td><td>
	  コードのネイティブ・アドレス
	</td>
</tr>
<tr>
<td><code id="DynamicCodeGenerated.length">length</code></td><td><code><a href="#jint">jint</a></code></td><td>
	  コードの長さ(バイト単位)
	</td>
</tr>
</table>
<p id="DataDumpRequest"></p>
<hr noshade size="3">
<h2>データ・ダンプ要求</h2>
<p></p>
<blockquote>
<pre>void JNICALL
DataDumpRequest(jvmtiEnv *jvmti_env)</pre>
</blockquote>
      VMによって送信され、エージェントにデータをダンプするよう要求します。これは単に示唆しているだけであり、エージェントはこのイベントに必ずしも反応する必要はありません。これは、ユーザーからのコマンド行シグナルを処理する場合に便利です。たとえば、Java 2 JDKの場合、Win32上ではCtrl+Breakキー、Solaris上ではCtrl+\キーで、このイベントはVMからエージェントへ送信されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_DATA_DUMP_REQUEST</code></td><td>71</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
</table>
<p id="MonitorContendedEnter"></p>
<hr noshade size="3">
<h2>競合するモニター開始</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorContendedEnter(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)</pre>
</blockquote>
      スレッドがJavaプログラミング言語モニターに入ろうとしたとき、そのモニターがすでに別のスレッドによって獲得されている場合に送信されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_MONITOR_CONTENDED_ENTER</code></td><td>75</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a></td><td>
	  モニターの使用率に関するイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="MonitorContendedEnter.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="MonitorContendedEnter.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    モニターに入ろうとするスレッドのJNIローカル参照
	  </td>
</tr>
<tr>
<td><code id="MonitorContendedEnter.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    モニターのJNIローカル参照
	  </td>
</tr>
</table>
<p id="MonitorContendedEntered"></p>
<hr noshade size="3">
<h2>競合するモニター開始済み</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorContendedEntered(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object)</pre>
</blockquote>
      別のスレッドがJavaプログラミング言語モニターを解放するのを待ったあとで、スレッドがそのJavaモニターに入るときに送信されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_MONITOR_CONTENDED_ENTERED</code></td><td>76</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a></td><td>
	  モニターの使用率に関するイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="MonitorContendedEntered.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="MonitorContendedEntered.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    モニターに入るスレッドのJNIローカル参照
	  </td>
</tr>
<tr>
<td><code id="MonitorContendedEntered.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    モニターのJNIローカル参照
	  </td>
</tr>
</table>
<p id="MonitorWait"></p>
<hr noshade size="3">
<h2>モニター待機</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorWait(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jlong timeout)</pre>
</blockquote>
      スレッドがオブジェクトを待機しようとしているときに送信されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_MONITOR_WAIT</code></td><td>73</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a></td><td>
	  モニターの使用率に関するイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="MonitorWait.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="MonitorWait.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    待機しようとするスレッドのJNIローカル参照
	  </td>
</tr>
<tr>
<td><code id="MonitorWait.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    モニターのJNIローカル参照
	  </td>
</tr>
<tr>
<td><code id="MonitorWait.timeout">timeout</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	  スレッドが待機する時間(単位はミリ秒)。
	</td>
</tr>
</table>
<p id="MonitorWaited"></p>
<hr noshade size="3">
<h2>モニター待機終了</h2>
<p></p>
<blockquote>
<pre>void JNICALL
MonitorWaited(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jboolean timed_out)</pre>
</blockquote>
      スレッドがオブジェクトの待機を終了するときに送信されます。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_MONITOR_WAITED</code></td><td>74</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_monitor_events"><code>can_generate_monitor_events</code></a></td><td>
	  モニターの使用率に関するイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="MonitorWaited.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="MonitorWaited.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    待機を終了したスレッドのJNIローカル参照
	  </td>
</tr>
<tr>
<td><code id="MonitorWaited.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    モニターのJNIローカル参照。
	  </td>
</tr>
<tr>
<td><code id="MonitorWaited.timed_out">timed_out</code></td><td><code><a href="#jboolean">jboolean</a></code></td><td>
	  モニターがタイム・アウトになった場合true
	</td>
</tr>
</table>
<p id="ResourceExhausted"></p>
<hr noshade size="3">
<h2>リソース不足</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ResourceExhausted(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jint flags,
            const void* reserved,
            const char* description)</pre>
</blockquote>
      実行中のアプリケーションが必要とするVMリソースが使い果たされたときに送信されます。任意の権限によって必要とされるものを除けば、不足を報告するリソース・セットは実装に依存します。
      <p></p>
      次のビット・フラグは、リソース不足のプロパティを定義します。
      <blockquote>
<a name="jvmtiResourceExhaustionFlags"></a>
<table border="1" cellpadding="3" cellspacing="0">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">リソース不足フラグ</td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
          定数
        </td><td>
          値
        </td><td>
          説明
        </td>
</tr>
<tr>
<td><code id="JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR">JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR</code></td><td align="right">0x0001</td><td>
          このイベントが返されたあと、VMは<code>java.lang.OutOfMemoryError</code>をスローする。
        </td>
</tr>
<tr>
<td><code id="JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP">JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP</code></td><td align="right">0x0002</td><td>
	  VMが、Java<sup style="font-size: xx-small">TM</sup>プラットフォームの<i>ヒープ</i>からメモリーを割り当てることができなかった。<i>ヒープ</i>とは、すべてのクラス・インスタンスおよび配列のメモリーの割当て元となる実行時データ領域のことである。
        </td>
</tr>
<tr>
<td><code id="JVMTI_RESOURCE_EXHAUSTED_THREADS">JVMTI_RESOURCE_EXHAUSTED_THREADS</code></td><td align="right">0x0004</td><td>
	  VMがスレッドを作成できなかった。
        </td>
</tr>
</table>
</blockquote>
    
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_RESOURCE_EXHAUSTED</code></td><td>80</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_RESOURCE_EXHAUSTED, NULL)</code></td><td>1.1</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>必要な機能</b></td>
</tr>
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center">
          任意の機能
        </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_resource_exhaustion_heap_events"><code>can_generate_resource_exhaustion_heap_events</code></a></td><td>
        VMが<a href="#JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP">ヒープ</a>からメモリーの割り当てを行えない場合に、イベントを生成できる。
      </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_resource_exhaustion_threads_events"><code>can_generate_resource_exhaustion_threads_events</code></a></td><td>
        VMが<a href="#JVMTI_RESOURCE_EXHAUSTED_THREADS">スレッドを作成</a>できない場合にイベントを生成できる。
      </td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ResourceExhausted.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
          </td>
</tr>
<tr>
<td><code id="ResourceExhausted.flags">flags</code></td><td><code><a href="#jint">jint</a></code></td><td>
	  <a href="#jvmtiResourceExhaustionFlags">リソース不足フラグ</a>で指定される、リソース不足のプロパティを定義するフラグ。
	  </td>
</tr>
<tr>
<td><code id="ResourceExhausted.reserved">reserved</code></td><td><code>const void*</code></td><td>
	  予約済み。
	</td>
</tr>
<tr>
<td><code id="ResourceExhausted.description">description</code></td><td><code>const char*</code></td><td>
	  リソース不足の説明。<a href="#mUTF">修正UTF-8</a>文字列としてエンコードされる。
	</td>
</tr>
</table>
<p id="VMObjectAlloc"></p>
<hr noshade size="3">
<h2>VMオブジェクト割当て</h2>
<p></p>
<blockquote>
<pre>void JNICALL
VMObjectAlloc(jvmtiEnv *jvmti_env,
            JNIEnv* jni_env,
            jthread thread,
            jobject object,
            jclass object_klass,
            jlong size)</pre>
</blockquote>
      メソッドによって、仮想マシンがJavaプログラミング言語コードに対して可視のオブジェクトを割り当て、その他の実装メカニズムがこの割り当てを検出できない場合に送信されます。通常、オブジェクトの割当ては、割り当てるメソッドのバイト・コードを実装することによって検出されます。JNI関数呼出しにより、ネイティブ・コードで生成されたオブジェクト割当ては、<a href="#jniIntercept">JNI関数の遮断</a>によって検出されます。バイト・コードに関連付けられておらず、ネイティブでないメソッドは、VMによって直接実行されます。このイベントは、これらのメソッドによって送信されます。仮想マシンが、これらのメソッドの一部またはすべてに対してバイト・コードを実装できない場合、このイベントが送信されることがあります。
      <p></p>
      次に、このイベントが送信される典型的な事例を示します。
      <ul type="disc">
        
<li>リフレクション -- たとえば、<code>java.lang.Class.newInstance()</code>
</li>
        
<li>バイト・コードで表されていないメソッド -- たとえば、VMの組込みメソッドとJ2MEプリロード・クラス</li>
      
</ul>
      次の場合、このイベントは生成されません。
      <ul type="disc">
        
<li>バイト・コードによる割り当て -- たとえば、<code>new</code>および<code>newarray</code> VM命令</li>
        
<li>JNI関数呼出しによる割り当て -- たとえば、<code>AllocObject</code>
</li>
        
<li>VM初期化中の割当て</li>
        
<li>VM内部オブジェクト</li>
      
</ul>
    
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_VM_OBJECT_ALLOC</code></td><td>84</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_vm_object_alloc_events"><code>can_generate_vm_object_alloc_events</code></a></td><td>
	  オブジェクトのVM割当てに関するイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.jni_env">jni_env</code></td><td><code> <a href="#JNIEnv">JNIEnv</a> *</code></td><td>
            イベントの現在のスレッドのJNI環境
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.thread">thread</code></td><td><code><a href="#jthread">jthread</a></code></td><td>
	    オブジェクトを割り当てるスレッド。
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.object">object</code></td><td><code><a href="#jobject">jobject</a></code></td><td>
	    割り当てられたオブジェクトのJNIローカル参照
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.object_klass">object_klass</code></td><td><code><a href="#jclass">jclass</a></code></td><td>
	    オブジェクトのクラスのJNIローカル参照
	  </td>
</tr>
<tr>
<td><code id="VMObjectAlloc.size">size</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	    オブジェクトのサイズ(バイト単位)。<a href="#GetObjectSize"><code>GetObjectSize</code></a>を参照。
	</td>
</tr>
</table>
<p id="ObjectFree"></p>
<hr noshade size="3">
<h2>オブジェクトの解放</h2>
<p></p>
<blockquote>
<pre>void JNICALL
ObjectFree(jvmtiEnv *jvmti_env,
            jlong tag)</pre>
</blockquote>
      オブジェクトの解放イベントは、ガベージ・コレクタがオブジェクトを解放した時点で送信されます。イベントは、タグ付きオブジェクトの場合にのみ送信されます(「<a href="#Heap">ヒープ関数</a>」を参照)。
      <p></p>
      イベント・ハンドラは、特別に使用が許可されているJVM<small style="font-size: xx-small">&nbsp;</small>TI関数以外の関数およびJNI関数を使用できません(rawモニター関数、メモリー管理関数、環境ローカル記憶領域関数を参照)。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_OBJECT_FREE</code></td><td>83</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_object_free_events"><code>can_generate_object_free_events</code></a></td><td>
	  ガベージ・コレクタがオブジェクトを解放するときにイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
<tr>
<td><code id="ObjectFree.tag">tag</code></td><td><code><a href="#jlong">jlong</a></code></td><td>
	  解放されるオブジェクトのタグ
	</td>
</tr>
</table>
<p id="GarbageCollectionStart"></p>
<hr noshade size="3">
<h2>ガベージ・コレクションの開始</h2>
<p></p>
<blockquote>
<pre>void JNICALL
GarbageCollectionStart(jvmtiEnv *jvmti_env)</pre>
</blockquote>
      ガベージ・コレクションの開始イベントは、ガベージ・コレクションによる一時停止が開始されたとき送信されます。処理を停止する(stop-the-world)コレクション、つまりすべてのスレッドがJava仮想マシンのステータスの変更を終了している間に収集されるコレクションだけがレポートされます。このため、コレクタによっては、これらのイベントを生成しません。このイベントは、VMがまだ停止している間に送信されるので、イベント・ハンドラは、JNI関数、およびJVM<small style="font-size: xx-small">&nbsp;</small>TI関数(特別にそのような使用が許可されているものを除く)を使用してはいけません(rawモニター、メモリー管理、および環境ローカル記憶領域関数を参照)。
      <p></p>
      このイベントは、常に<a href="#GarbageCollectionFinish"><code>GarbageCollectionFinish</code></a>と一致するペア(どちらのイベントも有効と見なされる)として送信され、これらの間に、ガベージ・コレクション・イベントは発生しません。
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_GARBAGE_COLLECTION_START</code></td><td>81</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_garbage_collection_events"><code>can_generate_garbage_collection_events</code></a></td><td>
	  ガベージ・コレクションの開始または終了時にイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
</table>
<p id="GarbageCollectionFinish"></p>
<hr noshade size="3">
<h2>ガベージ・コレクションの完了</h2>
<p></p>
<blockquote>
<pre>void JNICALL
GarbageCollectionFinish(jvmtiEnv *jvmti_env)</pre>
</blockquote>
      ガベージ・コレクションの終了イベントは、ガベージ・コレクションによる一時停止が終了したとき送信されます。このイベントは、VMがまだ停止している間に送信されるので、イベント・ハンドラは、JNI関数、およびJVM<small style="font-size: xx-small">&nbsp;</small>TI関数(特別にそのような使用が許可されているものを除く)を使用してはいけません(rawモニター、メモリー管理、および環境ローカル記憶領域関数を参照)。
      <p></p>
      一部のエージェントは、許可されていないJVM<small style="font-size: xx-small">&nbsp;</small>TIまたはJNI関数を使用する必要のある、ガベージ・コレクション後の操作を行う必要があります。そのような場合、rawモニターで待機するエージェント・スレッドを作成でき、ガベージ・コレクションの終了イベントでは、単にrawモニターに通知します。
      <p></p>
      このイベントは、常に<a href="#GarbageCollectionStart"><code>GarbageCollectionStart</code></a>と一致するペア(どちらのイベントも有効と見なされる)として送信されます。
      
    <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><a href="#jvmtiPhase">段階</a></td><td><a href="#jvmtiEvent">イベント・タイプ</a></td><td><a href="#jvmtiEvent">番号</a></td><td><a href="#enablingevents">有効化</a></td><td><a href="#ChangeHistory">導入されたバージョン</a></td>
</tr>
<tr>
<td>
  ライブ段階でしか送信されない
</td><td><code>JVMTI_EVENT_GARBAGE_COLLECTION_FINISH</code></td><td>82</td><td><code><a href="#SetEventNotificationMode">SetEventNotificationMode</a>(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL)</code></td><td>1.0</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="2" align="center" class="tableHeader">
        権限
      </td>
</tr>
<tr>
<td colspan="2"><b>任意の機能:</b> すべての仮想マシンに実装することはないと考えられます。このイベントを使用するためには、次の権限(<a href="#GetCapabilities"><code>GetCapabilities</code></a>から返される)がtrueである必要があります。
              </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
            権限
          </td><td>
            効果
          </td>
</tr>
<tr>
<td><a href="#jvmtiCapabilities.can_generate_garbage_collection_events"><code>can_generate_garbage_collection_events</code></a></td><td>
	  ガベージ・コレクションの開始または終了時にイベントを生成できる。
	</td>
</tr>
</table>
<p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#CCCCFF">
<td colspan="3" align="center" class="tableHeader">
        パラメータ
      </td>
</tr>
<tr bgcolor="#EEEEFF">
<td>
        名前
      </td><td>
        型
      </td><td>
        説明
      </td>
</tr>
</table>
<p id="ConstantIndex"></p>
<p></p>
<hr noshade size="3">
<h2>
        定数の索引
      </h2>
<blockquote>
<a href="#JVMTI_CLASS_STATUS_ARRAY"><code>JVMTI_CLASS_STATUS_ARRAY</code></a> <br> <a href="#JVMTI_CLASS_STATUS_ERROR"><code>JVMTI_CLASS_STATUS_ERROR</code></a> <br> <a href="#JVMTI_CLASS_STATUS_INITIALIZED"><code>JVMTI_CLASS_STATUS_INITIALIZED</code></a> <br> <a href="#JVMTI_CLASS_STATUS_PREPARED"><code>JVMTI_CLASS_STATUS_PREPARED</code></a> <br> <a href="#JVMTI_CLASS_STATUS_PRIMITIVE"><code>JVMTI_CLASS_STATUS_PRIMITIVE</code></a> <br> <a href="#JVMTI_CLASS_STATUS_VERIFIED"><code>JVMTI_CLASS_STATUS_VERIFIED</code></a> <br> <a href="#JVMTI_DISABLE"><code>JVMTI_DISABLE</code></a> <br> <a href="#JVMTI_ENABLE"><code>JVMTI_ENABLE</code></a> <br> <a href="#JVMTI_HEAP_FILTER_CLASS_TAGGED"><code>JVMTI_HEAP_FILTER_CLASS_TAGGED</code></a> <br> <a href="#JVMTI_HEAP_FILTER_CLASS_UNTAGGED"><code>JVMTI_HEAP_FILTER_CLASS_UNTAGGED</code></a> <br> <a href="#JVMTI_HEAP_FILTER_TAGGED"><code>JVMTI_HEAP_FILTER_TAGGED</code></a> <br> <a href="#JVMTI_HEAP_FILTER_UNTAGGED"><code>JVMTI_HEAP_FILTER_UNTAGGED</code></a> <br> <a href="#JVMTI_HEAP_OBJECT_EITHER"><code>JVMTI_HEAP_OBJECT_EITHER</code></a> <br> <a href="#JVMTI_HEAP_OBJECT_TAGGED"><code>JVMTI_HEAP_OBJECT_TAGGED</code></a> <br> <a href="#JVMTI_HEAP_OBJECT_UNTAGGED"><code>JVMTI_HEAP_OBJECT_UNTAGGED</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_CLASS"><code>JVMTI_HEAP_REFERENCE_CLASS</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_CLASS_LOADER"><code>JVMTI_HEAP_REFERENCE_CLASS_LOADER</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_CONSTANT_POOL"><code>JVMTI_HEAP_REFERENCE_CONSTANT_POOL</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_FIELD"><code>JVMTI_HEAP_REFERENCE_FIELD</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_INTERFACE"><code>JVMTI_HEAP_REFERENCE_INTERFACE</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_JNI_GLOBAL"><code>JVMTI_HEAP_REFERENCE_JNI_GLOBAL</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_JNI_LOCAL"><code>JVMTI_HEAP_REFERENCE_JNI_LOCAL</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_MONITOR"><code>JVMTI_HEAP_REFERENCE_MONITOR</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_OTHER"><code>JVMTI_HEAP_REFERENCE_OTHER</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN"><code>JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_SIGNERS"><code>JVMTI_HEAP_REFERENCE_SIGNERS</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_STACK_LOCAL"><code>JVMTI_HEAP_REFERENCE_STACK_LOCAL</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_STATIC_FIELD"><code>JVMTI_HEAP_REFERENCE_STATIC_FIELD</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_SUPERCLASS"><code>JVMTI_HEAP_REFERENCE_SUPERCLASS</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_SYSTEM_CLASS"><code>JVMTI_HEAP_REFERENCE_SYSTEM_CLASS</code></a> <br> <a href="#JVMTI_HEAP_REFERENCE_THREAD"><code>JVMTI_HEAP_REFERENCE_THREAD</code></a> <br> <a href="#JVMTI_HEAP_ROOT_JNI_GLOBAL"><code>JVMTI_HEAP_ROOT_JNI_GLOBAL</code></a> <br> <a href="#JVMTI_HEAP_ROOT_JNI_LOCAL"><code>JVMTI_HEAP_ROOT_JNI_LOCAL</code></a> <br> <a href="#JVMTI_HEAP_ROOT_MONITOR"><code>JVMTI_HEAP_ROOT_MONITOR</code></a> <br> <a href="#JVMTI_HEAP_ROOT_OTHER"><code>JVMTI_HEAP_ROOT_OTHER</code></a> <br> <a href="#JVMTI_HEAP_ROOT_STACK_LOCAL"><code>JVMTI_HEAP_ROOT_STACK_LOCAL</code></a> <br> <a href="#JVMTI_HEAP_ROOT_SYSTEM_CLASS"><code>JVMTI_HEAP_ROOT_SYSTEM_CLASS</code></a> <br> <a href="#JVMTI_HEAP_ROOT_THREAD"><code>JVMTI_HEAP_ROOT_THREAD</code></a> <br> <a href="#JVMTI_ITERATION_ABORT"><code>JVMTI_ITERATION_ABORT</code></a> <br> <a href="#JVMTI_ITERATION_CONTINUE"><code>JVMTI_ITERATION_CONTINUE</code></a> <br> <a href="#JVMTI_ITERATION_IGNORE"><code>JVMTI_ITERATION_IGNORE</code></a> <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED"><code>JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED</code></a> <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_MASK"><code>JVMTI_JAVA_LANG_THREAD_STATE_MASK</code></a> <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_NEW"><code>JVMTI_JAVA_LANG_THREAD_STATE_NEW</code></a> <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE"><code>JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE</code></a> <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED"><code>JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED</code></a> <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING"><code>JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING</code></a> <br> <a href="#JVMTI_JAVA_LANG_THREAD_STATE_WAITING"><code>JVMTI_JAVA_LANG_THREAD_STATE_WAITING</code></a> <br> <a href="#JVMTI_JLOCATION_JVMBCI"><code>JVMTI_JLOCATION_JVMBCI</code></a> <br> <a href="#JVMTI_JLOCATION_MACHINEPC"><code>JVMTI_JLOCATION_MACHINEPC</code></a> <br> <a href="#JVMTI_JLOCATION_OTHER"><code>JVMTI_JLOCATION_OTHER</code></a> <br> <a href="#JVMTI_KIND_ALLOC_ALLOC_BUF"><code>JVMTI_KIND_ALLOC_ALLOC_BUF</code></a> <br> <a href="#JVMTI_KIND_ALLOC_BUF"><code>JVMTI_KIND_ALLOC_BUF</code></a> <br> <a href="#JVMTI_KIND_IN"><code>JVMTI_KIND_IN</code></a> <br> <a href="#JVMTI_KIND_IN_BUF"><code>JVMTI_KIND_IN_BUF</code></a> <br> <a href="#JVMTI_KIND_IN_PTR"><code>JVMTI_KIND_IN_PTR</code></a> <br> <a href="#JVMTI_KIND_OUT"><code>JVMTI_KIND_OUT</code></a> <br> <a href="#JVMTI_KIND_OUT_BUF"><code>JVMTI_KIND_OUT_BUF</code></a> <br> <a href="#JVMTI_PHASE_DEAD"><code>JVMTI_PHASE_DEAD</code></a> <br> <a href="#JVMTI_PHASE_LIVE"><code>JVMTI_PHASE_LIVE</code></a> <br> <a href="#JVMTI_PHASE_ONLOAD"><code>JVMTI_PHASE_ONLOAD</code></a> <br> <a href="#JVMTI_PHASE_PRIMORDIAL"><code>JVMTI_PHASE_PRIMORDIAL</code></a> <br> <a href="#JVMTI_PHASE_START"><code>JVMTI_PHASE_START</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_BOOLEAN"><code>JVMTI_PRIMITIVE_TYPE_BOOLEAN</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_BYTE"><code>JVMTI_PRIMITIVE_TYPE_BYTE</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_CHAR"><code>JVMTI_PRIMITIVE_TYPE_CHAR</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_DOUBLE"><code>JVMTI_PRIMITIVE_TYPE_DOUBLE</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_FLOAT"><code>JVMTI_PRIMITIVE_TYPE_FLOAT</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_INT"><code>JVMTI_PRIMITIVE_TYPE_INT</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_LONG"><code>JVMTI_PRIMITIVE_TYPE_LONG</code></a> <br> <a href="#JVMTI_PRIMITIVE_TYPE_SHORT"><code>JVMTI_PRIMITIVE_TYPE_SHORT</code></a> <br> <a href="#JVMTI_REFERENCE_ARRAY_ELEMENT"><code>JVMTI_REFERENCE_ARRAY_ELEMENT</code></a> <br> <a href="#JVMTI_REFERENCE_CLASS"><code>JVMTI_REFERENCE_CLASS</code></a> <br> <a href="#JVMTI_REFERENCE_CLASS_LOADER"><code>JVMTI_REFERENCE_CLASS_LOADER</code></a> <br> <a href="#JVMTI_REFERENCE_CONSTANT_POOL"><code>JVMTI_REFERENCE_CONSTANT_POOL</code></a> <br> <a href="#JVMTI_REFERENCE_FIELD"><code>JVMTI_REFERENCE_FIELD</code></a> <br> <a href="#JVMTI_REFERENCE_INTERFACE"><code>JVMTI_REFERENCE_INTERFACE</code></a> <br> <a href="#JVMTI_REFERENCE_PROTECTION_DOMAIN"><code>JVMTI_REFERENCE_PROTECTION_DOMAIN</code></a> <br> <a href="#JVMTI_REFERENCE_SIGNERS"><code>JVMTI_REFERENCE_SIGNERS</code></a> <br> <a href="#JVMTI_REFERENCE_STATIC_FIELD"><code>JVMTI_REFERENCE_STATIC_FIELD</code></a> <br> <a href="#JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP"><code>JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP</code></a> <br> <a href="#JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR"><code>JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR</code></a> <br> <a href="#JVMTI_RESOURCE_EXHAUSTED_THREADS"><code>JVMTI_RESOURCE_EXHAUSTED_THREADS</code></a> <br> <a href="#JVMTI_THREAD_MAX_PRIORITY"><code>JVMTI_THREAD_MAX_PRIORITY</code></a> <br> <a href="#JVMTI_THREAD_MIN_PRIORITY"><code>JVMTI_THREAD_MIN_PRIORITY</code></a> <br> <a href="#JVMTI_THREAD_NORM_PRIORITY"><code>JVMTI_THREAD_NORM_PRIORITY</code></a> <br> <a href="#JVMTI_THREAD_STATE_ALIVE"><code>JVMTI_THREAD_STATE_ALIVE</code></a> <br> <a href="#JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER"><code>JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER</code></a> <br> <a href="#JVMTI_THREAD_STATE_IN_NATIVE"><code>JVMTI_THREAD_STATE_IN_NATIVE</code></a> <br> <a href="#JVMTI_THREAD_STATE_IN_OBJECT_WAIT"><code>JVMTI_THREAD_STATE_IN_OBJECT_WAIT</code></a> <br> <a href="#JVMTI_THREAD_STATE_INTERRUPTED"><code>JVMTI_THREAD_STATE_INTERRUPTED</code></a> <br> <a href="#JVMTI_THREAD_STATE_PARKED"><code>JVMTI_THREAD_STATE_PARKED</code></a> <br> <a href="#JVMTI_THREAD_STATE_RUNNABLE"><code>JVMTI_THREAD_STATE_RUNNABLE</code></a> <br> <a href="#JVMTI_THREAD_STATE_SLEEPING"><code>JVMTI_THREAD_STATE_SLEEPING</code></a> <br> <a href="#JVMTI_THREAD_STATE_SUSPENDED"><code>JVMTI_THREAD_STATE_SUSPENDED</code></a> <br> <a href="#JVMTI_THREAD_STATE_TERMINATED"><code>JVMTI_THREAD_STATE_TERMINATED</code></a> <br> <a href="#JVMTI_THREAD_STATE_VENDOR_1"><code>JVMTI_THREAD_STATE_VENDOR_1</code></a> <br> <a href="#JVMTI_THREAD_STATE_VENDOR_2"><code>JVMTI_THREAD_STATE_VENDOR_2</code></a> <br> <a href="#JVMTI_THREAD_STATE_VENDOR_3"><code>JVMTI_THREAD_STATE_VENDOR_3</code></a> <br> <a href="#JVMTI_THREAD_STATE_WAITING"><code>JVMTI_THREAD_STATE_WAITING</code></a> <br> <a href="#JVMTI_THREAD_STATE_WAITING_INDEFINITELY"><code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY</code></a> <br> <a href="#JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT"><code>JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT</code></a> <br> <a href="#JVMTI_TIMER_ELAPSED"><code>JVMTI_TIMER_ELAPSED</code></a> <br> <a href="#JVMTI_TIMER_TOTAL_CPU"><code>JVMTI_TIMER_TOTAL_CPU</code></a> <br> <a href="#JVMTI_TIMER_USER_CPU"><code>JVMTI_TIMER_USER_CPU</code></a> <br> <a href="#JVMTI_TYPE_CCHAR"><code>JVMTI_TYPE_CCHAR</code></a> <br> <a href="#JVMTI_TYPE_CVOID"><code>JVMTI_TYPE_CVOID</code></a> <br> <a href="#JVMTI_TYPE_JBOOLEAN"><code>JVMTI_TYPE_JBOOLEAN</code></a> <br> <a href="#JVMTI_TYPE_JBYTE"><code>JVMTI_TYPE_JBYTE</code></a> <br> <a href="#JVMTI_TYPE_JCHAR"><code>JVMTI_TYPE_JCHAR</code></a> <br> <a href="#JVMTI_TYPE_JCLASS"><code>JVMTI_TYPE_JCLASS</code></a> <br> <a href="#JVMTI_TYPE_JDOUBLE"><code>JVMTI_TYPE_JDOUBLE</code></a> <br> <a href="#JVMTI_TYPE_JFIELDID"><code>JVMTI_TYPE_JFIELDID</code></a> <br> <a href="#JVMTI_TYPE_JFLOAT"><code>JVMTI_TYPE_JFLOAT</code></a> <br> <a href="#JVMTI_TYPE_JINT"><code>JVMTI_TYPE_JINT</code></a> <br> <a href="#JVMTI_TYPE_JLONG"><code>JVMTI_TYPE_JLONG</code></a> <br> <a href="#JVMTI_TYPE_JMETHODID"><code>JVMTI_TYPE_JMETHODID</code></a> <br> <a href="#JVMTI_TYPE_JNIENV"><code>JVMTI_TYPE_JNIENV</code></a> <br> <a href="#JVMTI_TYPE_JOBJECT"><code>JVMTI_TYPE_JOBJECT</code></a> <br> <a href="#JVMTI_TYPE_JSHORT"><code>JVMTI_TYPE_JSHORT</code></a> <br> <a href="#JVMTI_TYPE_JTHREAD"><code>JVMTI_TYPE_JTHREAD</code></a> <br> <a href="#JVMTI_TYPE_JVALUE"><code>JVMTI_TYPE_JVALUE</code></a> <br> <a href="#JVMTI_VERBOSE_CLASS"><code>JVMTI_VERBOSE_CLASS</code></a> <br> <a href="#JVMTI_VERBOSE_GC"><code>JVMTI_VERBOSE_GC</code></a> <br> <a href="#JVMTI_VERBOSE_JNI"><code>JVMTI_VERBOSE_JNI</code></a> <br> <a href="#JVMTI_VERBOSE_OTHER"><code>JVMTI_VERBOSE_OTHER</code></a> <br> <a href="#JVMTI_VERSION_INTERFACE_JNI"><code>JVMTI_VERSION_INTERFACE_JNI</code></a> <br> <a href="#JVMTI_VERSION_INTERFACE_JVMTI"><code>JVMTI_VERSION_INTERFACE_JVMTI</code></a> <br> <a href="#JVMTI_VERSION_MASK_INTERFACE_TYPE"><code>JVMTI_VERSION_MASK_INTERFACE_TYPE</code></a> <br> <a href="#JVMTI_VERSION_MASK_MAJOR"><code>JVMTI_VERSION_MASK_MAJOR</code></a> <br> <a href="#JVMTI_VERSION_MASK_MICRO"><code>JVMTI_VERSION_MASK_MICRO</code></a> <br> <a href="#JVMTI_VERSION_MASK_MINOR"><code>JVMTI_VERSION_MASK_MINOR</code></a> <br> <a href="#JVMTI_VERSION_SHIFT_MAJOR"><code>JVMTI_VERSION_SHIFT_MAJOR</code></a> <br> <a href="#JVMTI_VERSION_SHIFT_MICRO"><code>JVMTI_VERSION_SHIFT_MICRO</code></a> <br> <a href="#JVMTI_VERSION_SHIFT_MINOR"><code>JVMTI_VERSION_SHIFT_MINOR</code></a> <br> <a href="#JVMTI_VISIT_ABORT"><code>JVMTI_VISIT_ABORT</code></a> <br> <a href="#JVMTI_VISIT_OBJECTS"><code>JVMTI_VISIT_OBJECTS</code></a> <br>
</blockquote>
<p id="ChangeHistory"></p>
<p></p>
<hr noshade size="3">
<h2>変更履歴</h2>
    最終更新日: 09/05/07<br>バージョン: 1.2.3<p></p>
    JVM<small style="font-size: xx-small">&nbsp;</small>TI仕様は発展中のドキュメントであり、メジャー、マイナー、マイクロの各バージョン番号を持ちます。リリース版の仕様はメジャー・バージョンとマイナー・バージョンで一意に識別されます。この仕様に含まれる関数、イベント、権限には「導入されたバージョン」値が示されていますが、これは、その機能が導入されたメジャー・バージョンとマイナー・バージョンです。VMが実装する仕様のバージョンを実行時に取得するには、<a href="#GetVersionNumber"><code>GetVersionNumber</code></a>関数を使用します。
  <p></p>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tr bgcolor="#EEEEFF">
<td><b>バージョン</b> <br> <b>日付</b></td><td><b>変更点</b></td>
</tr>
<tr>
<td>2002年11月14日</td><td>
    XML文書に変換。
  </td>
</tr>
<tr>
<td>2002年11月14日</td><td>
    ヒープ・ダンプ関数の記述に誤りがあったため、一時的に内容を削除。
  </td>
</tr>
<tr>
<td>2002年11月18日</td><td>
    詳しいスループットを追加。
  </td>
</tr>
<tr>
<td>2002年11月18日</td><td>
    JVMTI_THREAD_STATUS_RUNNINGをJVMTI_THREAD_STATUS_RUNNABLEに変更。
  </td>
</tr>
<tr>
<td>2002年11月19日</td><td>
    AsyncGetStackTraceを追加。
  </td>
</tr>
<tr>
<td>2002年11月19日</td><td>
    GetStackTraceの戻り値jframeIDを追加。
  </td>
</tr>
<tr>
<td>2002年11月19日</td><td>
    GetCurrentFrame関数とGetCallingFrame関数の記述にGetStackTraceと重複する点があったため、一時的に内容を削除。
  </td>
</tr>
<tr>
<td>2002年11月19日</td><td>
    重複したClearAllBreakpointsを削除。
  </td>
</tr>
<tr>
<td>2002年11月19日</td><td>
    GetSystemPropertiesを追加。
  </td>
</tr>
<tr>
<td>2002年11月19日</td><td>
    スレッド・ローカルな記憶領域関数がjthreadを使用するように変更。
  </td>
</tr>
<tr>
<td>2002年11月20日</td><td>
    GetJLocationFormatを追加。
  </td>
</tr>
<tr>
<td>2002年11月22日</td><td>
    イベントと概要のテキストを追加。
  </td>
</tr>
<tr>
<td>2002年11月22日</td><td>
    型と定数の定義のクロス・リファレンスを追加。
  </td>
</tr>
<tr>
<td>2002年11月24日</td><td>
    DTDを追加。
  </td>
</tr>
<tr>
<td>2002年11月24日</td><td>
    権限関数のセクションを追加。
  </td>
</tr>
<tr>
<td>2002年11月29日</td><td>
    各関数およびイベントに権限を割当て。
  </td>
</tr>
<tr>
<td>2002年11月29日</td><td>
    <a href="#jniIntercept">JNI遮断関数</a>を追加。
  </td>
</tr>
<tr>
<td>2002年11月30日</td><td>
    SetEventNotificationMode権限を自動生成。
  </td>
</tr>
<tr>
<td>2002年11月30日</td><td>
    <a href="#VMObjectAlloc"><code>VMObjectAlloc</code></a>イベントを追加。
  </td>
</tr>
<tr>
<td>2002年11月30日</td><td>
    <a href="#DynamicCodeGenerated"><code>DynamicCodeGenerated</code></a>イベントを追加。
  </td>
</tr>
<tr>
<td>2002年11月30日</td><td>
    宣言の定数を追加。
  </td>
</tr>
<tr>
<td>2002年11月30日</td><td>
    メソッドの終了とフレーム・ポップが例外を送信するように変更。
  </td>
</tr>
<tr>
<td>2002年12月1日</td><td>
    ForceGarbageCollectionを追加。
  </td>
</tr>
<tr>
<td>2002年12月2日</td><td>
    Xrunセクションの改訂:  GetStackTraceの説明をわかりやすく変更し、例を追加。幅の問題を修正。「エージェント」を矛盾なく使用。
  </td>
</tr>
<tr>
<td>2002年12月8日</td><td>
    以前の概要情報を削除。「<a href="#environments">JVM<small style="font-size: xx-small">&nbsp;</small>TI環境</a>」セクションを追加。
  </td>
</tr>
<tr>
<td>2002年12月8日</td><td>
    <a href="#DisposeEnvironment"><code>DisposeEnvironment</code></a>を追加します。
  </td>
</tr>
<tr>
<td>2002年12月9日</td><td>
    多数の細かい更新。
  </td>
</tr>
<tr>
<td>2002年12月15日</td><td>
    ヒープ・プロファイリング関数を追加: 注釈の取得/設定、ライブ・オブジェクト/ヒープの反復処理。ヒープ・プロファイリング関数のプレースホルダーを追加: ヒープ・ルート。ヒープ・プロファイリング・イベントを追加: オブジェクトの解放。ヒープ・プロファイリング・イベントを再設計: VMオブジェクト割当て。ヒープ・プロファイリング・イベントのプレースホルダーを追加: ガベージ・コレクションの開始/終了。ネイティブ・メソッド・バインド・イベントを追加。
  </td>
</tr>
<tr>
<td>2002年12月19日</td><td>
    関数の中断/再開の説明を改訂。jvmdiタグ付きの元の情報を追加。その他の修正。
  </td>
</tr>
<tr>
<td>2002年12月24日</td><td>
    型にセマンティックスを追加。
  </td>
</tr>
<tr>
<td>2002年12月27日</td><td>
    ローカル参照のセクションを追加。型からパラメータの説明を自動生成。
  </td>
</tr>
<tr>
<td>2002年12月28日</td><td>
    RunAgentThreadがthreadStartを送信することを文書化。
  </td>
</tr>
<tr>
<td>2002年12月29日</td><td>
    重複したローカル参照と割当て解除の警告を削除。GetRawMonitorNameを割当て済みバッファに変換。GenerateEventsを追加。
  </td>
</tr>
<tr>
<td>2002年12月30日</td><td>
    rawモニターを型に変更し、名前をjrawMonitorIDに変更。
  </td>
</tr>
<tr>
<td>2003年1月1日</td><td>
    元の情報を追加。JVMDIの問題の参照を整理。Deallocateの警告が自動生成されるようになったので削除。
  </td>
</tr>
<tr>
<td>2003年1月2日</td><td>
    jthreadの表現の問題を修正。
  </td>
</tr>
<tr>
<td>2003年1月3日</td><td>
    権限を64ビットにバッファ・アウト(自動処理)。
  </td>
</tr>
<tr>
<td>2003年1月4日</td><td>
    列挙の定数を列挙型に変更。パラメータは列挙型。型のセクションを整理し、索引を作成。残っているデータ定義エンティティをコールバックで置換え。
  </td>
</tr>
<tr>
<td>2003年1月7日</td><td>
    GenerateEventsの説明を修正。より多くの内部セマンティックスを有効化。
  </td>
</tr>
<tr>
<td>2003年1月9日</td><td>
    以前のGetSystemPropertiesを、固定情報ではなく割り当てられた情報を使用する2つの関数で置換え。SetSystemPropertyを追加。より多くの内部セマンティックスを有効化。
  </td>
</tr>
<tr>
<td>2003年1月12日</td><td>
    SetEventNotificationModeの末尾に可変引数を追加。
  </td>
</tr>
<tr>
<td>2003年1月20日</td><td>
    割当てサイズがjlongであることを反映するように仕様を修正。
  </td>
</tr>
<tr>
<td>2003年1月22日</td><td>
    RunAgentThreadの引数としてNULLを許可。
  </td>
</tr>
<tr>
<td>2003年1月22日</td><td>
    標準命名規則Removed AsyncGetStackTraceの名前を修正。
  </td>
</tr>
<tr>
<td>2003年1月29日</td><td>
    jthreadを使用するためGetThreadを削除。
  </td>
</tr>
<tr>
<td>2003年1月31日</td><td>
    GetMethodNameと同様にNULLを許可するようにGetFieldNameを変更。
  </td>
</tr>
<tr>
<td><b>v40</b> <br>2003年2月29日</td><td>
      概要のテキストを書き直し、起動、環境、およびバイト・コード・インストゥルメンテーションに関するセクションを追加。EGディスカッションに従ってコマンド行引数を変更。権限のセクションに概要情報を追加。拡張メカニズムのカテゴリと関数を追加。SuspendAllThreadsの削除を指定(説明を改訂)。IterateOverLiveObjectsの名前をIterateOverReachableObjectsに変更し、この変更に応じてテキストも変更。IterateOverHeapの説明を改訂。CompiledMethodLoadの説明を改訂。関数呼出しの必要条件について検討。SetAllocationHooksの説明を改訂。全体にわたって「解決予定」として問題を追加。その他。
  </td>
</tr>
<tr>
<td><b>v41</b> <br>2003年3月6日</td><td>
      GetOwnedMonitorInfoの呼出しから構造体を削除。大部分のエラー・ドキュメントを自動生成。手書きの(不規則な)エラー・ドキュメントを削除。権限の使用に関する説明を改善(空の初期セット)。jintパラメータに最小値を追加。権限can_access_thread_local_storageを削除。エラーJVMTI_ERROR_NOT_IMPLEMENTEDをJVMTI_ERROR_MUST_POSSESS_CAPABILITYに名称変更。*NOT_IMPLEMENTEDについても同様。説明を修正。
  </td>
</tr>
<tr>
<td><b>v42</b> <br>2003年3月8日</td><td>
      GetClassSignatureの名前をGetClassNameに変更。IterateOverClassObjectsの名前をIterateOverInstancesOfClassに変更。GetMaxStackを削除(オペランド・スタックはJVM<small style="font-size: xx-small">&nbsp;</small>TIでは使用されない)。説明を修正: 起動時間の定義、PopFrameからのネイティブ・フレーム・ポップの削除、その他の改訂。
  </td>
</tr>
<tr>
<td><b>v43</b> <br>2003年3月8日</td><td>
      細かい編集上の問題を修正。
  </td>
</tr>
<tr>
<td><b>v44</b> <br>2003年3月10日</td><td>
      段階の情報を追加。イベント番号を再マップ(コンパクト化)。
  </td>
</tr>
<tr>
<td><b>v45</b> <br>2003年3月11日</td><td>
      段階の情報をさらに追加 -「すべて」を許可。rawモニターの照会およびイベントを削除。説明の細かい修正。
  </td>
</tr>
<tr>
<td><b>v46</b> <br>2003年3月12日</td><td>
      GetPhaseを追加。文書全体で「段階」を使用。GetRawMonitorNameを削除。GetObjectMonitorsを削除。
  </td>
</tr>
<tr>
<td><b>v47</b> <br>2003年3月12日</td><td>
      リンク、XML、スペル・チェックによる修正。コールバック構造体を自動生成。
  </td>
</tr>
<tr>
<td><b>v48</b> <br>2003年3月13日</td><td>
      1文字のXMLを修正。
  </td>
</tr>
<tr>
<td><b>v49</b> <br>2003年3月13日</td><td>
      イベント・パラメータ名と対応するように関数パラメータ名を変更(fooBarBazをfoo_bar_bazに変更)。
  </td>
</tr>
<tr>
<td><b>v50</b> <br>2003年3月14日</td><td>
      壊れたリンクを修正。スレッド・マーカーを修正。
  </td>
</tr>
<tr>
<td><b>v51</b> <br>2003年3月14日</td><td>
      コンパイラの問題を回避するため、128より小さくなるように定数を変更。
  </td>
</tr>
<tr>
<td><b>v52</b> <br>2003年3月23日</td><td>
      権限について全面的に見直し。GetStackTraceをGetStackTraceとGetStackFramesに分割。
  </td>
</tr>
<tr>
<td><b>v54</b> <br>2003年4月8日</td><td>
      フレームの参照に、jframeIDではなく深さを使用。不適切になったGetCurrentFrame、GetCallerFrame、およびGetStackFramesを削除。イベントからフレーム引数を削除。
  </td>
</tr>
<tr>
<td><b>v55</b> <br>2003年4月9日</td><td>
      テストにより、バッファを使用するほうが効率がよいとわかったため、GetObjectWithAnnotationを削除。GetObjectsWithAnnotationsにannotation_countを追加
  </td>
</tr>
<tr>
<td><b>v56</b> <br>2003年4月10日</td><td>
      GetObjectsWithAnnotationsに挿入されたあいまいな記述を削除
  </td>
</tr>
<tr>
<td><b>v58</b> <br>2003年4月13日</td><td>
      メソッドのjclass/jmethodIDという表現を単なるjmethodIDで置換え。すべてのイベントの第1引数としてJvmtiEnv*を渡す。不適切な箇所からJNIEnv*を削除。can_access_framesをcan_access_local_variablesで置換え。純粋なスタック・アクセスから削除。can_get_synthetic_attributeを使用。説明を修正。長さゼロの配列は割当て解除する必要があることを明記。RelinquishCapabilitiesの説明を明確化。JVMTI_ERROR_VM_DEADをJVMTI_ERROR_WRONG_PHASEに一般化。
  </td>
</tr>
<tr>
<td><b>v59</b> <br>2003年4月27日</td><td>
      OBSOLETE_METHOD_IDの不要な間接参照を削除。
  </td>
</tr>
<tr>
<td><b>v60</b> <br>2003年5月4日</td><td>
      OnLoad時のDestroyRawMonitorを許可。
  </td>
</tr>
<tr>
<td><b>v61</b> <br>2003年5月7日</td><td>
      DestroyRawMonitorにモニターの所有者でない場合に返されるエラーを追加。
  </td>
</tr>
<tr>
<td><b>v62</b> <br>2003年5月13日</td><td>
      rawモニターのセマンティックスを改訂。<code>GetThreadStatus</code>のフラグを変更。<code>GetClassLoader</code>は、ブートストラップ・クラス・ローダーの場合NULLを返す。<code>GetClassName</code>の問題を追加。局所変数シグニチャを定義。<code>GetObjectsWithAnnotations</code>の注釈配列内のゼロを禁止。<code>GetObjectsWithAnnotations</code>の仕様を削除。<code>SetAllocationHooks</code>を削除します。<code>SuspendAllThreads</code>を削除します。
  </td>
</tr>
<tr>
<td><b>v63</b> <br>2003年5月14日</td><td>
      データ型<code>jvmtiEventCallbacks</code>を定義。ゼロ長の割当てはNULLを返す。SetAllocationHooksはJVMDIでは保持されるがJVM<small style="font-size: xx-small">&nbsp;</small>TIからは削除。JVMTI_THREAD_STATUS_FLAG_INTERRUPTEDを追加。
  </td>
</tr>
<tr>
<td><b>v64</b> <br>2003年5月15日</td><td>
      レビューにより表現を変更。
  </td>
</tr>
<tr>
<td><b>v65</b> <br>2003年5月15日</td><td>
      最初のアルファ版。jmethodIDとjfieldIDを一意に変更。jclassは使用しない。
  </td>
</tr>
<tr>
<td><b>v66</b> <br>2003年5月27日</td><td>
      細かいXSLTエラーを修正。
  </td>
</tr>
<tr>
<td><b>v67</b> <br>2003年6月13日</td><td>
      jfieldIDの一意化を取り消し(jmethodIDはそのまま)。
  </td>
</tr>
<tr>
<td><b>v68</b> <br>2003年6月17日</td><td>
      6月11日のExpert Groupミーティングによる変更 -- ヒープ関数の見直し: シングル・コールバック、GetHeapRootsの削除、到達可能なイテレータの追加、「注釈」の名前を「タグ」に変更。ほとんどの関数で、NULLスレッド・パラメータは現在のスレッド。タイマーを追加。ForceExitを削除。GetEnvironmentLocalStorageを追加。冗長フラグおよびイベントを追加。AddToBootstrapClassLoaderSearchを追加。ClassFileLoadHookを更新。
  </td>
</tr>
<tr>
<td><b>v69</b> <br>2003年6月18日</td><td>
      問題点のセクションを改訂。GetClassNameの名前をGetClassSignatureに戻し、説明を修正。GetClassSignature、GetFieldSignature、GetMethodSignature、およびGetLocalVariableTableにジェネリック・シグニチャを追加。EstimateCostOfCapabilitiesを削除。システム・プロパティ関数がシステム・プロパティのVMビューで動作することを明示。Agent_OnLoadの説明を改訂。イベントのJNIEnv*から定数を削除。メタデータ・アクセサを追加。
  </td>
</tr>
<tr>
<td><b>v70</b> <br>2003年6月18日</td><td>
      GetStackTraceにstart_depthを追加。システム・プロパティを新しいカテゴリに移動。GetObjectSizeを追加。コマンド行フラグからXを削除。XML、HTML、スペル・チェックによる修正。
  </td>
</tr>
<tr>
<td><b>v71</b> <br>2003年6月19日</td><td>
      JVMTI_HEAP_ROOT_THREADを6に修正。各説明が関数名に一致するように変更。あいまいな表現を修正。
  </td>
</tr>
<tr>
<td><b>v72</b> <br>2003年6月26日</td><td>
      SetThreadLocalStorageとSetEnvironmentLocalStorageでは、値をNULLに設定できなければならない。NotifyFramePop、GetFrameLocationm、およびフレームについて記述する必要があるすべての局所変数の操作を修正。全体にわたって、文法を修正し、説明を明瞭化する必要がある。大文字と小文字の区別、および句読点に一貫性を持たせる必要がある。マイクロ・バージョン番号と、メジャー、マイナー、およびマイクロ・バージョン番号にアクセスするマスクが必要。エラー・コード・リストに、実装によって返されるエラー・コードを示す必要がある。コマンド行プロパティをプロパティ関数内で可視にする必要がある。現在のスレッドからのポップを禁止。ポップできないとき、実装が不透明なフレーム・エラーを返すことを許可。NativeMethodBindイベントは、どの段階でも送信できなければならない。DynamicCodeGeneratedイベントは、どの段階でも送信できなければならない。VMInitの前に、次の関数の実行が許可されなければならない: Set/GetEnvironmentLocalStorage GetMethodDeclaringClass GetClassSignature GetClassModifiers IsInterface IsArrayClass GetMethodName GetMethodModifiers GetMaxLocals GetArgumentsSize GetLineNumberTable GetMethodLocation IsMethodNative IsMethodSynthetic。XSLに対するその他の変更: 引数の説明で、ポインタの前ではなく後ろにアスタリスクを表示する必要がある。NotifyFramePop、GetFrameLocationm、およびその他の局所変数の操作にNO_MORE_FRAMESエラーを追加する必要がある。活動状態でないスレッドは、無効なスレッドとは異なったエラーを返す必要がある。
  </td>
</tr>
<tr>
<td><b>v73</b> <br>2003年7月7日</td><td>
      VerboseOutputイベントがメッセージ・パラメータを検出しなかった。細かい修正。
  </td>
</tr>
<tr>
<td><b>v74</b> <br>2003年7月14日</td><td>
      Technical Publications Departmentによる修正。スレッド・ローカルおよび環境ローカルな記憶領域にNULLを設定することを許可。
  </td>
</tr>
<tr>
<td><b>v75</b> <br>2003年7月23日</td><td>
      オーバーロードされたJVM_OnLoadの代わりに新しいAgent_OnLoadを使用。コールバックにJNICALLを追加(XSL)。イベントとコールバックの両方についてJNICALLの要件を文書化(XSL)。RedefineClassesをメソッドと属性に限定。VerboseOutputイベントを削除。VMObjectAlloc: イベント送信時に制限し、メソッド・パラメータを削除。Tech Pubsによる編集に対する対応を完了。
  </td>
</tr>
<tr>
<td><b>v76</b> <br>2003年7月24日</td><td>
      ClassFileLoadHookイベントが再定義のブール型ではなくクラスを送信するように変更。
  </td>
</tr>
<tr>
<td><b>v77</b> <br>2003年7月24日</td><td>
      XMLファイル。テキストの細かい部分の改訂と修正。
  </td>
</tr>
<tr>
<td><b>v78</b> <br>2003年7月24日</td><td>
      JVM<small style="font-size: xx-small">&nbsp;</small>TIからGetExceptionHandlerTableとGetThrownExceptionsを削除。スタック・フレームがJVM仕様のフレームであることを明記。can_get_source_infoをcan_get_source_file_name、can_get_line_numbers、およびcan_get_source_debug_extensionに分割。PopFrameはネイティブ呼出しメソッドを持つことができない。GetClassloaderClassesから正確でない記述を削除(<cite>Java(tm)仮想マシン仕様のセクション4.4</cite>を参照)。
  </td>
</tr>
<tr>
<td><b>v79</b> <br>2003年7月24日</td><td>
      XMLおよびテキストを修正。スタック・フレームの説明をスタック・フレーム・カテゴリに移動。
  </td>
</tr>
<tr>
<td><b>v80</b> <br>2003年7月26日</td><td>
      GetClassloaderClassesにNULL (ブートストラップ・ローダー)を許可。クラスからの参照に新しいヒープ参照の種類を追加。タイマー情報の構造体とクエリー関数を追加。AvailableProcessorsを追加。GetOtherThreadCpuTimeの名前をGetThreadCpuTimeに変更。SetEventNotificationモードにJVMTI_ERROR_INVALID_THREADとJVMTI_ERROR_THREAD_NOT_ALIVEを明示的に追加。VM_INITイベントに初期スレッドを追加。AddToBootstrapClassLoaderSearchからプラットフォームの仮定条件を削除。
  </td>
</tr>
<tr>
<td><b>v81</b> <br>2003年7月26日</td><td>
      レビューにより、文法と表現を変更。
  </td>
</tr>
<tr>
<td><b>v82</b> <br>2003年7月27日</td><td>
      レビューにより、文法と表現をさらに変更。Agent_OnUnloadを追加。
  </td>
</tr>
<tr>
<td><b>v83</b> <br>2003年7月28日</td><td>
      Agent_OnUnloadの戻り型をvoidに変更。
  </td>
</tr>
<tr>
<td><b>v84</b> <br>2003年7月28日</td><td>
      JVMTI_REFERENCE_ARRAYの名前をJVMTI_REFERENCE_ARRAY_ELEMENTに変更。
  </td>
</tr>
<tr>
<td><b>v85</b> <br>2003年7月28日</td><td>
      AvailableProcessors()のjava.lang.Runtime.availableProcessors()の表現を借用。イベントIDがゼロにならないことを保証。解決された問題を削除。レビューにより、タイマー情報関数の名前を変更、説明を補足。
  </td>
</tr>
<tr>
<td><b>v86</b> <br>2003年7月29日</td><td>
      XMLで制御される実装に対して、仕様に影響のない変更を追加: SetThreadLocalStorageはVMモードで実行する必要がある。
  </td>
</tr>
<tr>
<td><b>0.1.87</b> <br>2003年8月5日</td><td>
      GetErrorNameを追加。jvmtiExtensionEventに可変引数の警告を追加。jvmtiExtensionEventのjvmtiEnv*から定数を削除。使用されないcan_get_exception_info権限を削除。jvmtiStartFunctionにjvmtiEnv*とJNIEnv*を渡す。jvmtiExtensionFunctionInfo.funcの宣言型を修正。拡張関数はエラー・コードを返す。バージョン番号付け方式を新規化。
  </td>
</tr>
<tr>
<td><b>0.2.88</b> <br>2003年8月5日</td><td>
      ClassUnloadイベントを削除。
  </td>
</tr>
<tr>
<td><b>0.2.89</b> <br>2003年8月8日</td><td>
      ヒープ参照イテレータのコールバックは、出力オブジェクト参照の無視を許可する列挙型を返す。JNIEnvを拡張イベント/拡張関数のパラメータ型として許可。
  </td>
</tr>
<tr>
<td><b>0.2.90</b> <br>2003年8月15日</td><td>
      タイプ・ミスを修正。
  </td>
</tr>
<tr>
<td><b>0.2.91</b> <br>2003年9月2日</td><td>
      すべてのメタデータ関数を削除: GetClassMetadata、GetFieldMetadata、およびGetMethodMetadata。
  </td>
</tr>
<tr>
<td><b>0.2.92</b> <br>2003年10月1日</td><td>
      関数Allocateにマーク付け。Deallocate、RawMonitor*、SetEnvironmentLocalStorage、およびGetEnvironmentLocalStorageをヒープ・コールバックおよびGCイベント内で安全に使用できるものとする。
  </td>
</tr>
<tr>
<td><b>0.2.93</b> <br>2003年11月24日</td><td>
      ヒープ反復関数およびコールバックにパススルーが不透明なユーザー・データ・ポインタを追加。CompiledMethodUnloadイベントで、コード・アドレスを送信する。GarbageCollectionOccurredイベントを追加。定数プール参照の種類を追加。関数CreateRawMonitorおよびDestroyRawMonitorをヒープ・コールバックおよびGCイベント内で安全に使用できるものとする。説明を改訂: VMDeath、GetCurrentThreadCpuTimerInfo、GetThreadCpuTimerInfo、IterateOverReachableObjects、IterateOverObjectsReachableFromObject、GetTime、およびJVMTI_ERROR_NULL_POINTER。欠落していたエラーを追加: GenerateEventsおよびAddToBootstrapClassLoaderSearch。ClassFileLoadHook名前パラメータの説明を修正。ヒープ・コールバックおよびGC/ObjectFreeイベント内で、明示的に許可された関数しか呼び出せないように指定。コールバック中、GetCurrentThreadCpuTimerInfo、GetCurrentThreadCpuTime、GetTimerInfo、およびGetTimeを許可。OnLoad段階でのSetTag/GetTagの呼出しを許可。SetEventNotificationModeに追加: 不適切なスレッド・レベルでの制御を試行した場合のエラー。jvmtiExceptionHandlerEntryを削除。スタックのネイティブ・メソッドの処理を修正 -- GetFrameLocationのlocation_ptrパラメータ、GetFrameLocation、jvmtiFrameInfo.location、およびjlocationからJVMTI_ERROR_OPAQUE_FRAMEを削除。スリープ時にMonitorWaitedイベントが送信されるという意味になってしまっているタイプ・ミスを削除(JVMPIより)。
  </td>
</tr>
<tr>
<td><b>0.2.94</b> <br>2003年11月25日</td><td>
      説明の改訂とタイプ・ミスの修正。
  </td>
</tr>
<tr>
<td><b>0.2.95</b> <br>2003年12月3日</td><td>
      ヒープ・イテレータでのNULL user_dataを許可。
  </td>
</tr>
<tr>
<td><b>0.2.97</b> <br>2004年1月28日</td><td>
      GetThreadStateを追加し、GetThreadStatusを非推奨にする。
  </td>
</tr>
<tr>
<td><b>0.2.98</b> <br>2004年1月29日</td><td>
      INVALID_SLOTおよびTYPE_MISMATCHエラーはオプションにしなければならない。
  </td>
</tr>
<tr>
<td><b>0.2.102</b> <br>2004年2月12日</td><td>
      MonitorContendedExitを削除。JNIEnvパラメータをVMObjectAllocに追加。ヒープ・コールバックのclass_tagおよびreferrer_indexパラメータを明示的に定義。
  </td>
</tr>
<tr>
<td><b>0.2.103</b> <br>2004年2月16日</td><td>
      JAVA_TOOL_OPTIONSのドキュメント化。
  </td>
</tr>
<tr>
<td><b>0.2.105</b> <br>2004年2月17日</td><td>
      開始段階を初期段階と開始段階とに分割。関数やイベントのVMStartイベント変更段階関連を追加。
  </td>
</tr>
<tr>
<td><b>0.3.6</b> <br>2004年2月18日</td><td>
      非推奨になっていたGetThreadStatusを削除。マイナー・バージョンを上げ、マイクロ・バージョンから100を引く
  </td>
</tr>
<tr>
<td><b>0.3.7</b> <br>2004年2月18日</td><td>
      タイマーのナノ秒値が符号なしであることをドキュメント化。ネイティブ・メソッドに関連するテキストを改訂。
  </td>
</tr>
<tr>
<td><b>0.3.8</b> <br>2004年2月19日</td><td>
      タイプ・ミスを修正。削除した非推奨のGetThreadStatusを削除。
  </td>
</tr>
<tr>
<td><b>0.3.9</b> <br>2004年2月23日</td><td>
      中断したスレッドでNotifyFramePopを実行しなければならない。
  </td>
</tr>
<tr>
<td><b>0.3.10</b> <br>2004年2月24日</td><td>
      一部のクラスを変更できないように、権限(<a href="#jvmtiCapabilities.can_redefine_any_class"><code>can_redefine_any_class</code></a>および<a href="#jvmtiCapabilities.can_generate_all_class_hook_events"><code>can_generate_all_class_hook_events</code></a>)およびエラー(<a href="#JVMTI_ERROR_UNMODIFIABLE_CLASS"><code>JVMTI_ERROR_UNMODIFIABLE_CLASS</code></a>)を追加。
  </td>
</tr>
<tr>
<td><b>0.3.11</b> <br>2004年2月28日</td><td>
      JVMTI_ERROR_MUST_POSSESS_CAPABILITYをSetEventNotificationModeに追加。
  </td>
</tr>
<tr>
<td><b>0.3.12</b> <br>2004年3月8日</td><td>
      CompiledMethodUnloadを明確にし、クラスのアンロード後にイベントがポストされる場合があることを明示。
  </td>
</tr>
<tr>
<td><b>0.3.13</b> <br>2004年3月5日</td><td>
      VMObjectAllocのsizeパラメータをjlongに変更し、GetObjectSizeに合わせる。
  </td>
</tr>
<tr>
<td><b>0.3.14</b> <br>2004年3月13日</td><td>
      JNI FindClass関数をイベント・コールバック関数で使用するためのガイドラインを追加。
  </td>
</tr>
<tr>
<td><b>0.3.15</b> <br>2004年3月15日</td><td>
      GetAllStackTracesおよびGetThreadListStackTracesを追加。
  </td>
</tr>
<tr>
<td><b>0.3.16</b> <br>2004年3月19日</td><td>
      ClassLoadおよびClassPrepareイベントは、開始段階中にポストできる。
  </td>
</tr>
<tr>
<td><b>0.3.17</b> <br>2004年3月25日</td><td>
      JVMTI_ERROR_NATIVE_METHODをGetLineNumberTable、GetLocalVariableTable、GetMaxLocals、GetArgumentsSize、GetMethodLocation、GetBytecodesに追加。
  </td>
</tr>
<tr>
<td><b>0.3.18</b> <br>2004年3月29日</td><td>
      タイマー情報構造体のタイマーの種類を返す。
  </td>
</tr>
<tr>
<td><b>0.3.19</b> <br>2004年3月31日</td><td>
      仕様の明確化: JVMTI_THREAD_STATE_IN_NATIVEにはJNIまたはJVM<small style="font-size: xx-small">&nbsp;</small>TIを含まない。ForceGarbageCollectionはファイナライザを実行しない。仕様のコンテキストはJavaプラットフォーム。以前のインストゥルメンテーションを警告。
  </td>
</tr>
<tr>
<td><b>0.3.20</b> <br>2004年4月1日</td><td>
      上記で明確化した箇所の改善、およびAgent_OnLoadが返したエラーでVMが終了する。
  </td>
</tr>
<tr>
<td><b>0.3.21</b> <br>2004年4月1日</td><td>
      配列クラスの作成では、クラス・ロード・イベントは生成されません。
  </td>
</tr>
<tr>
<td><b>0.3.22</b> <br>2004年4月7日</td><td>
      スレッド状態の階層をよりjava.lang.Thread.Stateにそろえる。
  </td>
</tr>
<tr>
<td><b>0.3.23</b> <br>2004年4月12日</td><td>
      スレッド状態について明確にした。
  </td>
</tr>
<tr>
<td><b>0.3.24</b> <br>2004年4月19日</td><td>
      エージェントによって実行できるため、GarbageCollectionOccurredイベントを削除。
  </td>
</tr>
<tr>
<td><b>0.3.25</b> <br>2004年4月22日</td><td>
      「コマンド行オプション」を定義。
  </td>
</tr>
<tr>
<td><b>0.3.26</b> <br>2004年4月29日</td><td>
      バイト・コード・インストゥルメンテーションの意図された使用方法を記述。拡張イベントの第1パラメータの説明を修正。
  </td>
</tr>
<tr>
<td><b>0.3.27</b> <br>2004年4月30日</td><td>
      説明の改訂とタイプ・ミスの修正。
  </td>
</tr>
<tr>
<td><b>0.3.28</b> <br>2004年5月18日</td><td>
      DataDumpRequestイベントを削除。
  </td>
</tr>
<tr>
<td><b>0.3.29</b> <br>2004年5月18日</td><td>
      ゼロ・タイムアウトのRawMonitorWaitを明確化。RunAgentThreadのあとのスレッド状態を明確化。
  </td>
</tr>
<tr>
<td><b>0.3.30</b> <br>2004年5月24日</td><td>
      クリーンアップ: 誤ったリンクや古いリンクの修正など。
  </td>
</tr>
<tr>
<td><b>0.3.31</b> <br>2004年5月30日</td><td>
      以下を含む明確化: すべての文字列が修正UTF-8。エージェント・スレッドの可視性。廃止メソッド・バージョンの意味。スレッド呼出ヒープのコールバック
  </td>
</tr>
<tr>
<td><b>1.0.32</b> <br>2004年6月1日</td><td>
      major.minorバージョン番号を"1.0"に変更。
  </td>
</tr>
<tr>
<td><b>1.0.33</b> <br>2004年6月2日</td><td>
      ForceGarbageCollectionとObjectFreeの相互作用を明確化。
  </td>
</tr>
<tr>
<td><b>1.0.34</b> <br>2004年6月6日</td><td>
      AddToBootstrapClassLoaderSearchとSetSystemPropertyをOnLoadフェーズのみに制限。
  </td>
</tr>
<tr>
<td><b>1.0.35</b> <br>2004年6月11日</td><td>
      SetTagのタイプ・ミスを修正。
  </td>
</tr>
<tr>
<td><b>1.0.36</b> <br>2004年6月18日</td><td>
      商標を修正。GetThreadStateの使用法の例にパラメータを追加。
  </td>
</tr>
<tr>
<td><b>1.0.37</b> <br>2004年8月4日</td><td>
      著作権の更新。
  </td>
</tr>
<tr>
<td><b>1.0.38</b> <br>2004年11月5日</td><td>
      欠落していた関数テーブル・レイアウトを追加。欠落していた、関数のC++メンバー関数形式の説明を追加。CFLHの名前がNULLになる可能性があることを明確化。J2SE<sup style="font-size: xx-small">TM</sup> 5.0の一部としてリリース。
  </td>
</tr>
<tr>
<td><b>1.1.47</b> <br>2005年4月24日</td><td>
      major.minorバージョン番号を"1.1"に変更。ForceEarlyReturn*関数群を追加。GetOwnedMonitorStackDepthInfo関数を追加。GetCurrentThread関数を追加。「導入されたバージョン」というバージョン・マーカーを追加。AddToSystemClassLoaderSearchを追加。AddToBootstrapClassLoaderSearchのライブ段階での使用を許可。IterateOverHeapおよびIterateOverInstancesOfClass関数のheap_object_callbackパラメータの説明に含まれていた歴史的な不要情報を整理。このパラメータでのNULLの使用を禁止。明確化、修正、一貫性の向上: PopFrameでの現在のスレッド、不透明なフレーム、および不十分な数のフレームに関する表現。「最上位」ではなく「現在のフレーム」を一貫して使用。GetLocal*およびSetLocal*でのJVMTI_ERROR_TYPE_MISMATCHエラーを明確化するため、それらをForceEarlyReturn*での記述と互換性のあるものに変更。他の多くの明確化や表現のクリーン・アップ。
  </td>
</tr>
<tr>
<td><b>1.1.48</b> <br>2005年4月25日</td><td>
      GetConstantPoolの追加。VM仕様の第1版への参照を第2版への参照に切替え。
  </td>
</tr>
<tr>
<td><b>1.1.49</b> <br>2005年4月26日</td><td>
      GetConstantPoolでのマイナー/メジャー・バージョンの順番を明確化。
  </td>
</tr>
<tr>
<td><b>1.1.50</b> <br>2005年4月26日</td><td>
      SetNativeMethodPrefixとSetNativeMethodPrefixesの追加。GetOwnedMonitorStackDepthInfoを位置153に再割当て。「クラス・ローダー検索」を独立したドキュメント・カテゴリとして分離。XMLソース内の長すぎる行を処理。
  </td>
</tr>
<tr>
<td><b>1.1.51</b> <br>2005年4月29日</td><td>
      ライブ段階でのエージェントの起動を許可。エージェントの配備に関する段落を追加。  
  </td>
</tr>
<tr>
<td><b>1.1.52</b> <br>2005年4月30日</td><td>
      SetNativeMethodPrefix(es)に仕様の説明を追加。GetConstantPoolの条件の定義を改善。  
  </td>
</tr>
<tr>
<td><b>1.1.53</b> <br>2005年4月30日</td><td>
      GetConstantPoolからGetClassVersionNumber関数を分離。VM仕様への参照をクリーンアップ。  
  </td>
</tr>
<tr>
<td><b>1.1.54</b> <br>2005年5月1日</td><td>
      SetNativeMethodPrefix(es)の使用を任意の段階で許可。GetConstantPoolへの再定義の影響に関する説明を追加。  
  </td>
</tr>
<tr>
<td><b>1.1.56</b> <br>2005年5月2日</td><td>
      SetNativeMethodPrefix(es)に関するさまざまな明確化。
  </td>
</tr>
<tr>
<td><b>1.1.57</b> <br>2005年5月2日</td><td>
      欠落していたパフォーマンス警告をメソッド・エントリ・イベントに追加。
  </td>
</tr>
<tr>
<td><b>1.1.58</b> <br>2005年5月5日</td><td>
      内部的なJVMDIサポートを削除。
  </td>
</tr>
<tr>
<td><b>1.1.59</b> <br>2005年5月8日</td><td>
      <a href="#RetransformClasses"><code>RetransformClasses</code></a>を追加します。バイト・コード・インストゥルメンテーションのドキュメントを再編。<a href="#IsMethodObsolete"><code>IsMethodObsolete</code></a>がcan_redefine_classes権限を必要としないという記述に変更。
  </td>
</tr>
<tr>
<td><b>1.1.63</b> <br>2005年5月11日</td><td>
      再変換の明確化。
  </td>
</tr>
<tr>
<td><b>1.1.64</b> <br>2005年5月11日</td><td>
      レビューに基づく再変換の明確化。クラス・ロード有効時の「再変換可能(不可能)」を固定。
  </td>
</tr>
<tr>
<td><b>1.1.67</b> <br>2005年6月4日</td><td>
      プリミティブ値の報告をサポートし、参照側のタグ設定を可能にし、より強力なフィルタ・リング機能を備えた、新しいヒープ機能を追加: FollowReferences、IterateThroughHeap、およびそれらに関連するコールバック、構造体、列挙、および定数。
  </td>
</tr>
<tr>
<td><b>1.1.68</b> <br>2005年6月4日</td><td>
      明確化。
  </td>
</tr>
<tr>
<td><b>1.1.69</b> <br>2005年6月6日</td><td>
      FollowReferences、IterateThroughHeap: コールバックを構造体内に配置、欠落していたエラー・コードを追加、ビジット制御フラグのビットを低減。
  </td>
</tr>
<tr>
<td><b>1.1.70</b> <br>2005年6月14日</td><td>
      新ヒープ機能に関する追加作業: レビューに基づく仕様の整理。
  </td>
</tr>
<tr>
<td><b>1.1.71</b> <br>2005年6月15日</td><td>
      新ヒープ機能に関する追加作業: 旧ヒープ・セクションの名前を「ヒープ(1.0)」に変更。
  </td>
</tr>
<tr>
<td><b>1.1.72</b> <br>2005年6月21日</td><td>
      タイプ・ミスを修正。
  </td>
</tr>
<tr>
<td><b>1.1.73</b> <br>2005年6月27日</td><td>
      参照側情報構造体を共用体に変更。
  </td>
</tr>
<tr>
<td><b>1.1.74</b> <br>2005年9月9日</td><td>
      新規ヒープ関数群: 欠落していた参照の種類「スーパー・クラス」を追加。フィールド・インデックスの計算に単一の方式を使用。古くなった構造体ベース参照側情報への参照を削除。
  </td>
</tr>
<tr>
<td><b>1.1.75</b> <br>2005年9月12日</td><td>
      FollowReferences中に、あまり重要でないjava.lang.Objectスーパー・クラス上でコールバックを発生させない。
  </td>
</tr>
<tr>
<td><b>1.1.76</b> <br>2005年9月13日</td><td>
      文字列プリミティブ・コールバックで、長さをUnicode長に変更。配列プリミティブ・コールバックと文字列プリミティブ・コールバックで、値を「const」に変更。JNI関数テーブルの設定時のコンパイラの潜在的な影響についての注を追加。
  </td>
</tr>
<tr>
<td><b>1.1.77</b> <br>2005年9月13日</td><td>
      GetClassVersionNumbers()とGetConstantPool()は、配列またはプリミティブ・クラスの場合にエラーを返すようにする。
  </td>
</tr>
<tr>
<td><b>1.1.78</b> <br>2005年9月14日</td><td>
      文法に関する修正。
  </td>
</tr>
<tr>
<td><b>1.1.79</b> <br>2005年9月26日</td><td>
      IsModifiableClassクエリーを追加。
  </td>
</tr>
<tr>
<td><b>1.1.81</b> <br>2006年2月9日</td><td>
      jvmtiHeapReferenceCallbackにreferrer_class_tagパラメータを追加。
  </td>
</tr>
<tr>
<td><b>1.1.82</b> <br>2006年2月13日</td><td>
      ドキュメント修正: can_redefine_any_classに再変換が含まれるように更新。例外イベントがすべてのThrowableをカバーすることを明記。GetStackTraceでstart_depthがゼロの場合、大きすぎるstart_depthのテストが行われない。プリミティブ・フィールド・コールバックで報告されるフィールドを明確化 -- staticとインスタンス。わかりにくいヒープの型の名前を、コールバック名も含めて修正。スレッド起動メソッドのインタフェースで、スタックの深さの一貫した使用を要求。JVM<small style="font-size: xx-small">&nbsp;</small>TIのメモリー管理が他のシステムと非互換であることを述べた注を追加。
  </td>
</tr>
<tr>
<td><b>1.1.85</b> <br>2006年2月14日</td><td>
      タイプ・ミスの修正、名前の変更。
  </td>
</tr>
<tr>
<td><b>1.1.86</b> <br>2006年3月13日</td><td>
      jmethodIDとjfieldIDが保存可能であることを明確化。「クラスのインスタンスの反復」にサブクラスが含まれることを明確化。
  </td>
</tr>
<tr>
<td><b>1.1.87</b> <br>2006年3月14日</td><td>
      表現の修正。
  </td>
</tr>
<tr>
<td><b>1.1.88</b> <br>2006年3月16日</td><td>
      オブジェクト参照コールバック内のstaticフィールドのreferrer_indexが、リファレンス実装(および他のすべての既知の実装)に一致するように変更。つまり、インスタンス・フィールドの定義に一致するように変更。GetThreadListStackTracesで、JVMTI_ERROR_INVALID_THREADを追加してリスト内の無効なスレッドをカバーするようにするとともに、起動されていないスレッドからは空のスタックが返されることを規定。
  </td>
</tr>
<tr>
<td><b>1.1.89</b> <br>2006年3月17日</td><td>
      タイプ・ミス。
  </td>
</tr>
<tr>
<td><b>1.1.90</b> <br>2006年3月25日</td><td>
      タイプ・ミス。
  </td>
</tr>
<tr>
<td><b>1.1.91</b> <br>2006年4月6日</td><td>
      AddToBootstrapClassLoaderSearchとAddToSystemClassLoaderSearchに関する制限を削除。
  </td>
</tr>
<tr>
<td><b>1.1.93</b> <br>2006年5月1日</td><td>
      スタック深さを決定できない実装のモニター・スタックの深さに対して -1を返すように仕様を変更。 
  </td>
</tr>
<tr>
<td><b>1.1.94</b> <br>2006年5月3日</td><td>
      IBMのAlan Pratt氏に従って読みやすさと正確さを高めるための修正を実施。FollowReferencesで報告されるオブジェクトの関係を記載。
  </td>
</tr>
<tr>
<td><b>1.1.95</b> <br>2006年5月5日</td><td>
      FollowReferencesで報告されるオブジェクトの関係を明確化。
  </td>
</tr>
<tr>
<td><b>1.1.98</b> <br>2006年6月28日</td><td>
      DisposeEnvironmentの明確化、警告を追加。SetLocalXXXでのタイプ・ミスを修正(「retrieve」=>「set」)。ネイティブ・メソッド接頭辞の使用中は、その接頭辞の設定状態を保つ必要があることを明確化。エージェントごとに厳密に1つのAgent_OnXXXが呼び出されることを明確化。ライブラリのロードは起動に依存しないことを明確化。Agent_OnUnload仕様内でのAgent_OnLoadへのあいまいな参照を削除。
  </td>
</tr>
<tr>
<td><b>1.1.99</b> <br>2006年7月31日</td><td>
      関数と例外との相互作用を明確化。フィールド・インデックスの明確化と具体例の追加。わかりにくい「つまり(That is)」の文を、MonitorWaitおよびMonitorWaitedイベントから削除。Java 6をポイントするようにリンクを更新。
  </td>
</tr>
<tr>
<td><b>1.1.102</b> <br>2006年8月6日</td><td>
      ResourceExhaustedイベントを追加。
  </td>
</tr>
<tr>
<td><b>1.2.2</b> <br>2012年10月11日</td><td>
      LinkCheckツールから報告された「HTTP」および「Missing Anchor」のエラーを修正。
  </td>
</tr>
<tr>
<td><b>1.2.3</b> <br>2013年6月19日</td><td>
      静的リンク・エージェントのサポートを追加。
  </td>
</tr>
</table>
</body>
</html>
