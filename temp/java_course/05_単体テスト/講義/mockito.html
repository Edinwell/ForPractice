<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>MVC施設予約の単体テスト</title>
<link rel="stylesheet" type="text/css" href="../../css/main.css">
</head>

<body>

<center>
<h2>Mockito</h2>
</center>
<hr>
<p class="midasi0">Mockito</p>

Mockito はバイトコードの書き換えにより、モッククラスが存在するかのようなテストを記述する仕組みを提供します。<br>
<br>
といっても、イメージが難しいと思いますので、とりあえず使ってみることにします。<br>

<p class="midasi1">Mockito の設定</p>
まずは、Mockito を使用する環境を整えます。<br>
と言ってもやることは、Mockito で使用する jar ファイルをクラスパスに追加するだけです。<br>
<br>
下記ディレクトリにあるファイルをプロジェクト内の任意のディレクトリにコピーし<br>
<br>
<a href="files/mockito">mockito libraries</a><br>
<br>
プロジェクトを右クリック → [Properties] → [Java Build Path] → [Libraries] → [Add JARs...]
<br>
で、プロジェクトのビルドバスに追加します。
<br>

<p class="midasi1">基本的な使い方</p>

次のようなコードをテストすることを考えます。<br>
<br>
<xmp class="source">
public class UserService {

	public String getFullName(String id) {
		String fullName = null;

		UserDao dao = new UserDao();
		User user = dao.getUser(id);

		if (user != null) {
		    fullName = user.getLastName() + " " + user.getFirstName();
		}

		return fullName;
	}
}
</xmp>
<br>
このメソッドは UserDao のメソッドを使用してユーザを取得し、<br>
取得したユーザから「姓」「名」を取得して、「氏名」 を生成し、返却します。<br>
<br>
このメソッドの責任は UserDao のメソッドに対して「正しい引数を渡すこと」と、<br>
「戻り値のユーザを使用して、半角スペースを挟んだ氏名を正確に作成し返却すること」 の ２点です。<br>
<br>
この２点を検証するために、Dao の戻り値を固定にして、期待する「氏名」 が生成されることと、<br>
UserDao にたいして、「A」 という引数を正確に渡していることを確認します。<br>
<br>
ただし、このままでは少し苦しいので、以下のように、UserDao を外から自由に設定できるように変更します。<br>
<br>
<xmp class="source">
public class UserService {

	private UserDao dao = new UserDao();

	public setUserDao(UserDao userDao) {
		this.userDao = userDao;
	}

	public String getFullName(String id) {
		String fullName = null;

		User user = dao.getUser(id);

		if (user != null) {
		    fullName = user.getLastName() + " " + user.getFirstName();
		}

		return fullName;
	}
}
</xmp>
<br>
Mockito を使用すると、以下のようなコードで、このテストを行うことができます。<br>
<br>
<xmp class="source">
@Test
public void testGetFullName() throws Exception {

	// 条件（モックの設定）
	UserDao mockUserDao = Mockito.mock(UserDao.class);
	service.setUserDao(mockUserDao);

	User mockUser = new User();
	mockUser.setLastName("単体");
	mockUser.setFirstName("テスト");

	ArgumentCaptor<String> mockUserIdCaptor = ArgumentCaptor.forClass(String.class);
	Mockito.when(reserveDao.getUser(mockUserIdCaptor.capture())).thenReturn(mockUser);  --- (1)

	// 実行
	String name = service.getFullName("A");

	// 結果
	assertEquals("単体 テスト", name);
	assertEquals("A", mockUserIdCaptor.getValue()); --- (2)

}
</xmp>
<br>
(1) は、テスト対象の getFullName() メソッド内で呼ばれる UserDao クラスの getUser() メソッドの戻り値を固定で設定しています。<br>
(2) は、UserDao クラスの getUser() メソッドへ渡された引数を取得し、"A" と比較をしています。<br>
<br>
コードだけではわかりにくいと思いますので、上記のコードをイメージ的に表現してみます。<br>
尚、あくまでイメージ的な話であり、Mockito の実際のテクニカルな話ではありません。<br>
<br>
<h4>Mockito を使用しない場合</h4>
<img src="images/09_mockito0.png" alt="images/09_mockito0.png" border="1"><br>
<br>
まずは、モック等を使用せずに普通のJUnitテストを使って、getFullName() メソッドの テストをした場合の処理の流れを見てみます。<br>
テスト対象の Service クラスの getFullName(id) メソッドを実行して確認しています。<br>
Service クラスは内部で UserDao クラスを呼び出し、Dao はDBへのアクセスを行っています。<br>

<h4>Mockito を使用した場合</h4>
Mockito を使用するとこの処理の流れがどう変わるのかを見てゆきます。<br>
まず、上記のコードでは、 「thenReturn()」 を呼び出しています。<br>
すると、動的にモックが作成され、クラス名、メソッド名と オブジェクトをセットされた状態となります。<br>
<br>
<img src="images/09_mockito1.png" alt="images/09_mockito1.png" border="1"><br>
<br>
次に、テスト対象のメソッド  getFullName(id) を呼び出します。<br>
<br>
<img src="images/09_mockito2.png" alt="images/09_mockito2.png" border="1"><br>
<br>
この getFullName(id) メソッド内で、UserDao の getUser() メソッドが呼び出されようとした瞬間、<br>
Mockito が、Service クラスと UserDao クラス の間に割り込みます。<br>
<br>
自分が保持するクラス名、メソッド名に該当する メソッドが呼び出されたからです。<br>
Mockito は、渡されてきた引数を引き取り、最初に設定されたオブジェクトを戻り値として返却します。<br>
<br>
<img src="images/09_mockito3.png" alt="images/09_mockito3.png" border="1"><br>
<br>
Service クラスの処理が終わった後、Mockito が保存している 渡された引数を、Mockito から取得して、検証することができます。<br>
<br>
<img src="images/09_mockito4.png" alt="images/09_mockito4.png" border="1"><br>
<br>
この流れの中で、UserDao クラスは一度もアクセスされませんでした。<br>
<br>
これが、基本的な動作のイメージです。

<br>


<p class="midasi1">Mockito の使い方</p>

以下では、Mockito を使って、実際に Servlet のテストを行って行きますが、<br>
Mockito に用意されている様々なメソッドの一部しか使いません。<br>
細かい使い方については下記のドキュメントを参照してください。<br>
<br>
参考）<a href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html" target="top">http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html</a><br>
<br>

<p class="midasi1">サーブレットメソッドのJUnitテスト</p>
それでは、HttpTC (サーブレット用モック)、Mockito を利用した テストを実装してみます。<br>
<br>
まずは、正常なテストケースです。<br>
<br>

<xmp class="source">
	private ReserveDao reserveDao;

	@Before
	public void setUp() throws Exception {
		servlet = new ShowReserveServlet();
		servlet.init(HttpTCHelper.config);
		super.setUp();

		this.reserveDao = Mockito.mock(ReserveDao.class);
		servlet.dao = this.reserveDao;

		Mockito.when(reserveDao.getRoomList()).thenReturn(roomList);
	}

	・・・

	/**
	 * <pre>
	 * 【概要】
	 * ・更新ボタンを押下したとき施設リストと予約リストが取得されること.
	 *
	 * 【条件】
	 * リクエストパラメータ
	 * ・update : 更新
	 *
	 * 呼び出しメソッド戻り値
	 * ・{@link ReserveDao#getRoomList()} : 施設リスト
	 * ・{@link ReserveDao#getReserveList(Calendar reserveDate)} : 予約リスト
	 *
	 * 【実行】
	 * ・doPost
	 *
	 * 【結果】
	 * 呼び出しメソッド引数
	 * ・{@link ReserveDao#getRoomList()} : 施設リスト
	 * ・{@link ReserveDao#getReserveList(Calendar reserveDate)} : 予約リスト
	 *
	 * リクエスト情報
	 * ・{@link ReserveServlet#RESERVE_LIST} : 予約リスト
	 * ・{@link ReserveServlet#ROOM_LIST} : 施設リスト
	 *
	 * 遷移先情報
	 * ・WEB-INF/jsp/reserve.jsp
	 *
	 * </pre>
	 */
	@Test
	public void testDoPostGetReserveListRoomList() throws Exception {

		// 条件
		request.addParameter("update", "更新");

		ArgumentCaptor<java.sql.Date> mockDateCaptor = ArgumentCaptor.forClass(java.sql.Date.class);
		Mockito.when(reserveDao.getReserveList(mockDateCaptor.capture())).thenReturn(reserveList);

		// 実行
		servlet.doPost(request, response);

		// 結果
		assertEquals("2008-07-15", mockDateCaptor.getValue().toString());

		assertSame(reserveList, request.getAttribute("RESERVE_LIST"));
		assertSame(roomList, request.getAttribute("ROOM_LIST"));

		this.assertForwradPath("WEB-INF/jsp/reserve.jsp");
	}
</xmp>

<br>
<br>
まず、JavaDoc の、【条件】となっている部分を見てください。<br>
ここには、メソッドの実行前に設定しておくべき項目が挙げられています。<br>
<br>
『 <span class="bold">リクエストパラメータ</span> 』 は、doPost() 実行時に、request.getParameter("update") メソッドで取得される値です。<br>
これは、以下のように記述することによって、HttpTC クラスの request モックオブジェクトに設定することができます。<br>
<br>
<xmp class="source">
request.addParameter("update", "更新");
</xmp>
<br>
チェックボックスなどにて、同じキーで複数の値が送信されるような場合は、 addParameter() メソッドの第２引数に配列を指定します。<br>
<br>
<xmp class="modified_source">
request.addParameter("key", new String[]{"value1", "value2", "value3"});
</xmp><br>
<br>
『 <span class="bold">セッション情報</span> 』 は、上記のテストに記載されていませんが、<br>
doPost() 実行時に、session.getAttribute("LOGIN_USER") メソッドで取得される値です。<br>
メソッドの実行直前に以下のように HttpTC クラスの session モックオブジェクト内に格納します。<br>
<br>
<xmp class="source">
session.setAttribute(user, "LOGIN_USER"));
</xmp><br>
<br>
『 <span class="bold">呼び出しメソッド戻り値</span> 』 は、Mockito の機能を利用します。<br>
Mockito.when() ～ thenReturn() メソッドを使用することで、<br>
ここで指定されたオブジェクト、指定されたメソッドに対する呼び出しは Mockito で処理されるようになります。<br>
ここで、施設一覧取得 のリストはどのテストでも共通に使用するため、<br>
テストクラスのメンバとし、setUp() メソッドで初期化するようにしてあります。<br>
<br>
<xmp class="source">
@Before
public void setUp() throws Exception {
	・・・
	Mockito.when(reserveDao.getRoomList()).thenReturn(roomList);
}
</xmp>
<br>
尚、戻り値を void とするような DAO のメソッドがあった場合、以下のようなコードを記述します。<br>
<br>
<xmp class="modified_source">
doNothing().when(オブジェクト).戻り値がvoidのメソッド();
</xmp>
<br>
ユーティリティメソッドなどのように、同じクラスの同じメソッドが何回も呼び出されるような場合、<br>
各呼び出しで使用される戻り値を変更したい場合は、以下のようなコードを使用します。<br>
<br>
<xmp class="modified_source">
// ReserveUtil#isValidReserves() を1回目の呼び出し時は false を返し、2回目以降の呼び出し時は true を返すように設定
PowerMockito.mockStatic(ReserveUtil.class);

when(ReserveUtil.isValidReserves()).thenReturn(false).thenReturn(true);
</xmp>
<br>
【条件】 が全て設定できたら、 【実行】 で doPost() メソッド を呼び出します。<br>
引数には、前提条件が詰められている HttpTC の request モックオブジェクト, response モックオブジェクトを指定します。<br>
<br>
<xmp class="source">
servlet.doPost(request, response);
</xmp>
<br>
doPost() メソッドが終了したら、【結果】 が全て予想通りかどうかを検証していきます。<br>
<br>
『 <span class="bold">呼び出しメソッド引数</span> 』 では、<br>
テスト対象のクラスが他のメソッド呼び出しの際に、正しい引数を渡していることを検証します。<br>
【条件】 にて、ArgumentCaptor を使って呼び出されたメソッドについては、Mockito から引数を取得することができます。<br>
mockDateCaptor.getValue() として、<br>
ReserveDao の getReserveList() メソッドに引数として渡された値を取得しています。<br>
<br>
<xmp class="source">
assertEquals("2008-07-15", mockDateCaptor.getValue().toString());
</xmp>
<br>
『 <span class="bold">リクエスト情報</span> 』 では、現在のリクエスト内に格納されている情報を確認します。<br>
JSP等で必要となる情報が、doPost() 実行後にリクエスト内に格納されていることを検証します。<br>
リクエスト内に格納された情報は、サーブレットで通常処理する場合と同じように、「request.getAttribute("key")」 を使用して取得します。<br>
<br>
ここでは、Dao から取得したリストが、そのままリクエスト内に格納されていることを確認します。<br>
Dao メソッドの戻り値がそのまま リクエスト内に格納されることが検証できればよいため、assertSame (JUnitのメソッド) を使用しています。<br>
これは、オブジェクト同士を 「equals()」 ではなく、「==」 を使用して比較するメソッドです。<br>
<br>
<xmp class="source">
assertSame(reserveList, request.getAttribute("RESERVE_LIST"));
assertSame(roomList, request.getAttribute("ROOM_LIST"));
</xmp>
<br>
『 <span class="bold">セッション情報</span> 』 では、JSP等で必要となる情報が、doPost() 実行後にセッション内に格納されていることや、<br>
ログアウトの際などに、セッションから情報が削除されたことを検証します。<br>
セッション内に格納された情報は、サーブレットで通常処理する場合と同じように、「session.getAttribute("key")」 を使用して取得します。<br>
<br>
ここでは、例としてセッション内に保持されているユーザ名が、該当するIDから取得されたユーザ名と同じか確認しています。<br>
session オブジェクトから取得した、"A" と同じユーザ名であることを検証しています。<br>
<br>
<xmp class="source">
assertEquals("A", session.getAttribute("LOGIN_USER"));
</xmp>
<br>
『 <span class="bold">遷移先情報</span> 』 は、doPost() 実行後に、遷移先の情報が指定されているかどうかを確認します。<br>
遷移先が指定されているかどうかの確認は、HttpTC クラスが持つ遷移先確認用のメソッド、assertForwradPath() を使用して検証を行います。<br>
<br>
<xmp class="source">
this.assertForwradPath("WEB-INF/jsp/reserve.jsp");
</xmp>
<br>
次に例外が発生するケースを例にします。<br>
<br>
<xmp class="source">

	/**
	 * <pre>
	 * 【概要】
	 * ・「login」が送信されたが、ユーザ取得にて例外が発生した場合、
	 *   Exceptionがスローされること。
	 *
	 * 【条件】
	 * リクエストパラメータ
	 * ・login : ログイン
	 * ・userId : 123ABC
	 *
	 * 呼び出しメソッド戻り値
	 * ・{@link ReserveDao#getUser(String)} : {@link Exception}
	 *
	 * 【実行】
	 * ・doPost
	 *
	 * 【結果】
	 * 呼び出しメソッド引数
	 * ・{@link ReserveDao#getUser(String)} : id=123ABC
	 *
	 * セッション情報
	 * ・{@link ReserveServlet#LOGIN_USER} : null
	 *
	 * 例外
	 * ・{@link Exception}
	 *
	 * </pre>
	 */
	public void testDoPostLoginThrowException() throws Exception {

		try {
			// 条件
			request.addParameter("login", "ログイン");
			request.addParameter("userId", "123ABC");

			PowerMockito.mockStatic(ReserveUtil.class);
			when(ReserveUtil.isEmpty()).thenReturn(false);

			Mockito.doThrow(new Exception("ReserveDao#getUser")).when(reserveDao.getUser(Mockito.anyString()));

			// 実行
			servlet.doPost(request, response);

			fail();

		} catch (ServletException e) {
			assertNull(session.getAttribute("LOGIN_USER"));

			Throwable t = e.getRootCause();
			assertEquals("ReserveDao#getUser", t.getMessage());
		}

	}

</xmp><br>
<br>
正常のケースと違う部分は、【条件】 の、<br>
<br>
<xmp class="source">
Mockito.doThrow(new Exception("ReserveDao#getUser")).when(reserveDao.getUser(Mockito.anyString()));
</xmp>
<br>
です。ここでは、メソッドの戻り値に、「例外」 を生成して設定しています。<br>
<br>
例外のテストで気をつけなければいけないのは、例外を発生させる部分までに呼び出す他のユーティリティやDaoのメソッドがあった場合、<br>
Mockito を利用して、本物のDao などが呼び出されないようにしておく必要があるということです。<br>
<br>
<br>

<hr>
<center>&copy;日本インサイトテクノロジー株式会社</center>
<br>
<br>
<br>


</body>
</html>
